# UC 非交互式、主动门限 ECDSA

Ran Canetti

波士顿大学。邮箱：canetti@bu.edu。

Nikolaos Makriyannis

Fireblocks。邮箱：nikos@fireblocks.com, udi@fireblocks.com

Udi Peled

2024年3月27日

###### 摘要

基于 Gennaro & Goldfeder 和 Lindell & Nof 协议（CCS '18），我们提出了一种门限 ECDSA 协议，适用于任意数量的签名者和任意门限，相较于现有技术有以下改进：

*   **签名生成仅需 4 轮**（当前为 8 轮），计算成本相当。此外，其中 3 轮可以在已知待签名消息之前的预处理阶段进行，从而实现**非交互式**门限 ECDSA 协议。
*   该协议能够抵抗签名者的自适应腐化。此外，它包含一个周期性的刷新机制，并提供完全的**主动安全性**。
*   该协议在 UC 框架内，在全局随机预言机模型下，假设强 RSA、Paillier 加密的语义安全性以及 ECDSA 存在性不可伪造性的某种增强变体，实现了一个理想的门限签名功能。

这些特性（低延迟、与冷钱包架构兼容、主动安全性和可组合安全性）使得该协议非常适合用于基于 ECDSA 的加密货币的门限钱包。

## 目录

*   1 引言
    *   1.1 我们的成果
    *   1.2 我们的技术
        *   1.2.1 背景
        *   1.2.2 我们的方法
        *   1.2.3 协议概述
        *   1.2.4 在线与非交互式签名
        *   1.2.5 安全性
        *   1.2.6 非交互式零知识证明
        *   1.2.7 扩展到 $t$-out-of-$n$ 访问结构
    *   1.3 其他相关工作
*   2 预备知识
    *   2.1 定义
    *   2.2 NP 关系
    *   2.2.1 辅助关系
    *   2.3 Sigma 协议
    *   2.3.1 ZK 模块
*   3 协议
    *   3.1 密钥生成
    *   3.2 密钥刷新与辅助信息
    *   3.3 预签名
    *   3.4 签名
*   4 底层 $\Sigma$-协议
    *   4.1 Paillier 加密范围 ZK ($\Pi^{\text{enc}}$)
    *   4.2 具有群承诺的 Paillier 操作范围 ZK ($\Pi^{\text{aff-g}}$)
    *   4.3 Paillier-Blum 模数 ZK ($\Pi^{\text{mod}}$)
    *   4.3.1 Paillier-Blum 模数因式分解的提取
    *   4.4 Ring-Pedersen 参数 ZK ($\Pi^{\text{prm}}$)
    *   4.4.1 关于辅助 RSA 模数和 Ring-Pedersen 参数
*   5 安全性分析
    *   5.1 全局随机预言机
    *   5.2 理想门限签名功能
    *   5.3 安全性声明
    *   5.3.1 定理 5.2 的证明
    *   5.4 模拟器
    *   5.4.1 Paillier 区分器 (${\cal R}_{1}$)
    *   5.4.2 ECDSA 伪造者 (${\cal R}_{2}$)
    *   5.5 独立模拟器
    *   5.5.1 密钥生成模拟器 (${\cal S}^{1}$)
    *   5.5.2 辅助信息与密钥刷新模拟器 (${\cal S}^{2}$)
    *   5.5.3 预签名模拟器 (${\cal S}^{3}$)

## 附录

### A UC 模型概述

### B 更多 Sigma 协议

*   B.1 Schnorr 知识证明 ($\Pi^{\text{sch}}$)
*   B.2 群元素与 Paillier 加密范围 ZK ($\Pi^{\text{log}}$)
*   B.3 具有 Paillier 承诺的 Paillier 操作 ZK ($\Pi^{\text{aff-p}}$)
*   B.4 无小因子证明 ($\Pi^{\text{fac}}$)
*   C 复杂度基准测试
*   D 数论与概率事实
*   E 假设
    *   E.1 ECDSA 的增强存在性不可伪造性
    *   E.1.1 $O(1)$-增强伪造
    *   E.1.2 多重增强伪造：预备知识
    *   E.1.3 多重增强伪造：证明
    *   E.1.4 多重增强伪造：证明

## 1 引言

由 Desmedt [25] 以及 Desmedt 和 Frankel [26] 引入的门限签名允许一定数量的签名者共享数字签名的能力，使得当且仅当达到特定门限数量的签名者同意签名时，给定消息才会被签名。更详细地说，一个 $t$-out-of-$n$ 门限签名方案是一种机制，通过该机制，一组 $n$ 个签名者在面对消息 $m$ 时，共同且交互式地计算一个**签名** $\sigma$，使得 (1) 如果至少 $t$ 个签名者同意对 $m$ 签名，则对 $m, \sigma$ 被预定的公开验证算法接受为有效；(2) 任何控制最多 $t-1$ 个签名者的攻击者都无法伪造签名——即，它无法提出一个对 $m^{\prime}, \sigma^{\prime}$，使得验证算法接受 $\sigma^{\prime}$ 作为 $m^{\prime}$ 的有效签名，如果后者以前从未被签名过。

门限签名是“门限密码学”的一个实例，而门限密码学又是更通用的安全多方计算范式的核心应用领域之一。门限密码学通过将需要使用秘密密钥的能力分布在多个服务器/设备之间，为执行涉及使用私钥的密码任务的实体提供了额外的安全层。确实，这样系统就没有单点故障。例子包括门限 El-Gamal、RSA、Schnorr、Cramer-Shoup、ECEIS 等 [50, 23, 49, 51, 13]。

随着过去十年区块链技术和加密货币的出现，对门限密码学，特别是门限签名的兴趣重新高涨。具体来说，因为交易是通过数字签名实现的，许多利益相关者希望以分布式方式进行签名生成，许多公司现在提供基于（或结合）门限密码学的解决方案。[^1]

[^1]: 参见 https://www.mpcalliance.org/ 了解门限密码学领域的公司。

**门限 ECDSA**。**数字签名算法**（DSA）[41] 的椭圆曲线变体（ECDSA）[47] 是使用最广泛的签名方案之一。ECDSA 受到了密码学界的广泛关注，因为除了其流行度之外，它被认为有些“门限不友好”，即（朴素的）ECDSA 门限协议需要繁重的密码学工具和许多通信轮次。使门限（EC）DSA 实际高效的早期尝试包括诚实多数设置下的 Gennaro 等人 [32] 和两方设置下的 MacKenzie 和 Reiter [46]。（当然，门限 ECDSA 可以使用通用 MPC 协议如 [35, 16] 来完成。此外，这些解决方案甚至允许通过预处理进行非交互式签名。然而，它们的成本高得令人望而却步。）

近年来，涌现了大量的门限 ECDSA 协议 [33, 2, 31, 42, 45, 27, 28, 22, 20, 21]，它们支持任意数量 $n$ 的参与方，并允许任意门限 $t<n$。在整体效率方面突出的协议是 Gennaro 和 Goldfeder [31]、Lindell 等人 [45]、Doerner 等人 [28] 以及 Castagnos 等人 [21] 的最新工作。

我们注意到，所有最近的协议都实现了具有竞争力的实际性能（根据所使用的工具，在计算和通信成本之间存在权衡）。此外，所有最近的协议都至少需要八轮通信，这对于许多现代通信设置（涉及地理上分散的服务器和/或移动设备）来说是最耗时的资源。

### 1.1 我们的成果

我们提出了一种新的门限 ECDSA 协议。该协议基于 Gennaro 和 Goldfeder [31] 以及 Lindell 等人 [45] 的技术构建，但提供了新的功能，并具有改进的效率和安全性保证。我们首先在高层面上讨论协议的新特性，然后在构造和分析方面提供更多细节。图 1 对我们的方案与 Gennaro 和 Goldfeder [31]、Lindell 等人 [45]、Doerner 等人 [28] 和 Castagnos 等人 [21] 的主要成本和安全保证进行了粗略比较。

**非交互式签名**。如图 1 所示，在所有这些协议中，签名过程是高度交互的，即参与方交换信息以一系列轮次计算给定消息的签名。然而，在许多现实场景中，希望具有非交互式签名生成，即每个签名者在看到消息后，无需与任何其他签名者交互即可生成自己的“签名份额”，然后通过一个公共算法将签名份额组合成单个签名。例如，如果希望对某些签名者使用“冷钱包”机制——这在数字货币领域用于保护非门限钱包是一种常见做法——那么这种机制是强制性的。确实，许多流行的签名方案确实允许具有非交互式签名的门限协议（例如 RSA [39]、BLS [1]）。

在我们的协议中，签名过程可以分为两个阶段：第一个是预处理阶段，需要 3 轮，可以在消息未知时执行；随后是一个非交互式步骤，每个签名者在待签名消息已知后生成自己的签名份额。据我们所知，这是文献中第一个具有可管理性能并允许通过预处理进行非交互式签名的门限 ECDSA。此外，非交互式步骤非常高效：它归结为计算并发送单个域元素（例如，对于比特币曲线为 256 位）。我们提到，Dalskov 等人 [22] 注意到了 ECDSA 类似的预签名能力，他们在保护 DNSSEC 密钥的背景下使用通用（即全能）MPC 来计算 ECDSA 功能。

**轮次最少的交互式签名**。我们强调，即使在其交互式变体中，我们的协议也是现有技术中最轮次高效的，因此我们的协议可能显著提高许多需要 ECDSA 的应用（例如加密货币托管）的性能。

**主动密钥刷新**[48, 38, 14, 40]。虽然门限签名确实比普通签名方案提供了显著的安全改进，但它们仍然可能容易受到随着时间的推移以自适应方式逐个危害所有持有者的攻击。这种脆弱性在需要长期运行并保持安全的方案中尤其令人烦恼。主动安全性旨在缓解这种担忧：在主动门限签名方案中，时间被划分为**纪元**，使得在每个纪元结束时，参与方参与一个刷新其密钥和本地状态的协议。安全保证是，只要在**单个纪元内**，或者更准确地说，在**任何从一个密钥刷新开始到下一个密钥刷新结束的时间段内**，最多有 $t-1$ 个签名者被破坏，该方案就保持不可伪造。需要强调的是，该方案的公开签名验证算法（和密钥）在整个过程中保持不变。

我们的协议提供了一个两轮的密钥刷新阶段。刷新是我们协议中最昂贵的组件：对于安全参数的标准选择，计算大约需要 $400+330n+n^{2}$ 次 RSA

**图 1**：我们的方案与 [31, 45, 28, 21] 的方案在签名方面的比较。成本显示的是针对一个 $n$ 方协议、安全抵抗 $n-1$ 个腐化方、计算安全性为 128 位、统计安全性为 80 位时每方的成本。环操作包含两种类型的操作（模 $N$ 和 $N^{2}$），我们在表中未作区分；模 $N^{2}$ 的操作在所有协议的总环操作数中占比不到三分之一。通信列描述了每对参与方之间发送的群元素（由 $\kappa$ 位编码）和环元素（由 $N$ 位编码）的数量；在括号中，我们为比特币曲线大小和 Paillier 标准安全建议（即 $\kappa=256$ 和 $N=2048$）的具体实现提供了估计值，包括常数开销。（$^3$[45] 的估计包括了不保留 UC 的优化——参见第 1.3 节。$^4$报告的数字与 [45] 不同，因为环操作的统计方式不同。*我们注意到 [21] 依赖于某种程度上不可比较的硬度假设，并且它涉及的操作在与底层椭圆曲线不同的群中——参见第 1.3 节。）

环操作（更多细节见附录 C）。然而，考虑到刷新仅是定期进行的，并且可以安排在系统使用率低的时候，这可能是可以管理的。

我们强调，图 1 中的其他协议都不支持主动密钥刷新。事实上，这些协议甚至不知道在系统进展过程中对手自适应地腐化参与方时提供传统的门限安全性。

**通信模型**。为简化阐述，我们假设签名者通过经过认证的（但有损的）广播机制连接。也就是说，通信是公开的，每个发送的消息都可能被所有参与方接收。尽管如此，对手可以随意丢弃和延迟消息。我们注意到，使用经过认证的通信实际上对于获得主动安全性是**必不可少的**。确实，如果没有已建立的经过认证的通信，一个形式上“离开”先前被腐化参与方并控制该参与方与网络其余部分之间所有通信的对手可以无限期地继续冒充该参与方 [15]。

**安全性与可组合性**。我们在通用可组合（UC）安全框架 [10] 内提供我们协议的安全性分析。为此，我们首先制定了一个理想的门限签名功能，该功能保证合法签名可通过标准 ECDSA 验证算法进行验证，同时保证理想和无条件的不可伪造性。我们证明，即使存在在连续两个刷新阶段之间最多腐化 $t$ 个参与方的限制下自适应地腐化和控制参与方的攻击者，我们的协议也能 UC 实现这一理想功能。这样，我们可以使用通用可组合性来断言，即使与任意其他协议结合使用，该协议仍然保持不可伪造。如此强大的属性在去中心化、复杂且高度安全敏感的分布式系统（如加密货币）中尤为重要。

交互式协议的安全性在假设 ECDSA 的不可伪造性、Paillier 加密的语义安全性和强 RSA 的情况下得到证明。将 ECDSA 的不可伪造性作为基础假设可能看起来有点不尽如人意，因为它是一个交互式——绝非“简单”——的假设。我们这样做是因为这是人们可以期望的最弱假设：确实，回想一下，ECDSA 的不可伪造性并不已知遵循椭圆曲线群上的任何标准硬度假设（然而我们确实知道 ECDSA 在泛型群模型 [6] 中是存在性不可伪造的）。

非交互式协议的安全性在相同的假设下得到证明，但对 ECDSA 的不可伪造性有稍强的要求，考虑了对手提前获得签名者将用于生成即将到来的几个签名的随机字符串的一些“泄漏”信息的情况。尽管如此，即使给定此泄漏，对手也不应能够伪造签名。我们称此属性为**增强不可伪造性**，并证明 (a) ECDSA 在泛型群模型中具有增强不可伪造性，以及 (b) 在某些情况下，ECDSA 的增强不可伪造性在随机预言机模型中遵循 ECDSA 的标准不可伪造性。

### 1.2 我们的技术

此后，$\mathbb{F}_{q}$ 表示具有 $q$ 个元素的有限域，$\mathcal{H}:\bm{M}\rightarrow\mathbb{F}_{q}$ 表示用于将消息嵌入到具有 $q$ 个元素的域中的哈希函数。此外，让 $(\mathbb{G},q,g)$ 表示与 ECDSA 曲线关联的群-阶-生成元元组。我们对群操作使用乘法表示法。

#### 1.2.1 背景

**普通（非门限）ECDSA**。回忆一下，对于私钥 $x\in\mathbb{F}_{q}$ 和消息 msg 的 ECDSA 签名具有形式 $(\rho,k\cdot(m+\rho x))\in\mathbb{F}_{q}^{2}$，其中 $m=\mathcal{H}(\text{msg})$，$\rho$ 是点 $g^{k^{-1}}\in\mathbb{G}$ 的 $x$ 投影（模 $q$），$k$ 是 $\mathbb{F}_{q}$ 中均匀随机的元素。验证算法接受签名 $(\rho,\sigma)$ 对于消息 msg $\in\bm{M}$ 相对于公钥 $X=g^{x}\in\mathbb{G}$ 有效，如果 $\rho$ 是 $g^{m\sigma^{-1}}\cdot X^{\rho\sigma^{-1}}$ 的 $x$ 投影，其中 $m=\mathcal{H}(\text{msg})$。

**Gennaro 和 Goldfeder [31] 的门限 ECDSA 概述**。我们首先描述安全门限为 $t=n-1$ 的诚实但好奇情况的基本协议，即所有签名者都遵循协议的情况。每个签名者（此后称为参与方）$\mathcal{P}_{i}$ 选择一个随机的 $x_{i}\in\mathbb{F}_{q}$ 并将 $X_{i}=g^{x_{i}}$ 发送给所有其他参与方。公钥定义为 $X=X_{1}\cdot\ldots\cdot X_{n}\in\mathbb{G}$。[^2] 私钥则对应于值 $x=x_{1}+\ldots+x_{n}$（强调没有人知道 $x$）。此外，每个参与方 $\mathcal{P}_{i}$ 与一个加法同态公钥加密方案（具体是 Paillier 加密）的参数相关联。也就是说，所有参与方都知道 $\mathcal{P}_{i}$ 的公钥加密密钥，而 $\mathcal{P}_{i}$ 知道自己的解密密钥。我们写 $\mathsf{enc}_{i}$，$\mathsf{dec}_{i}$ 表示与 $\mathcal{P}_{i}$ 关联的加密和解密算法。强调所有参与方都可以运行加密算法。

[^2]: 为了 presentation 目的，我们使用私钥的加法 $n$-out-of-$n$ 秘密共享，而不是 [31] 中规定的 $n$-out-of-$n$ Shamir 秘密共享。

为了对消息 msg 签名，参与方 $\mathcal{P}_{1},\ldots,\mathcal{P}_{n}$ 分别生成随机值 $k=k_{1}+\ldots+k_{n}$ 的本地份额 $k_{1},\ldots,k_{n}$，以及用于掩盖 $k$ 的临时值 $\gamma=\gamma_{1}+\ldots+\gamma_{n}$ 的本地份额 $\gamma_{1},\ldots,\gamma_{n}$。使用他们各自的加密方案，每对参与方 $\mathcal{P}_{i}$, $\mathcal{P}_{j}$ 计算加法份额 $\alpha_{i,j},\hat{\alpha}_{i,j}$ 给 $\mathcal{P}_{i}$ 和 $\beta_{j,i},\hat{\beta}_{j,i}$ 给 $\mathcal{P}_{j}$，使得 $\alpha_{i,j}+\beta_{j,i}=\gamma_{j}k_{i}$ 且 $\hat{\alpha}_{i,j}+\hat{\beta}_{j,i}=x_{j}k_{i}$。更详细地说，$\mathcal{P}_{i}$ 和 $\mathcal{P}_{j}$ 之间计算 $\alpha_{i,j}$ 和 $\beta_{j,i}$ 的份额计算阶段进行如下（$\hat{\alpha}_{i,j}$ 和 $\hat{\beta}_{j,i}$ 类似构造）。参与方 $\mathcal{P}_{i}$ 将 $K_{i}=\mathsf{enc}_{i}(k_{i})$ 发送给 $\mathcal{P}_{j}$，即 $K_{i}$ 是 $k_{i}$ 在他自己的公钥下的加密。然后，$\mathcal{P}_{j}$ 从合适的范围中采样一个随机的 $\beta_{j,i}$，并使用加密方案的同态属性，计算 $D_{i,j}=(\gamma_{j}\odot K_{i})\oplus\mathsf{enc}_{i}(-\beta_{j,i})$，[^3] 即 $D_{i,j}$ 是 $\gamma_{j}k_{i}-\beta_{j,i}$ 在 $\mathcal{P}_{i}$ 公钥下的加密。最后，$\mathcal{P}_{j}$ 将 $D_{i,j}$ 发送给 $\mathcal{P}_{i}$，后者设置 $\alpha_{i,j}=\mathsf{dec}_{i}(D_{i,j})$，份额计算阶段结束。完成后，每个参与方 $\mathcal{P}_{i}$ 可以计算 $\delta_{i}=\gamma_{i}k_{i}+\sum_{j\neq i}\alpha_{i,j}+\beta_{i,j}$，其中 $\delta_{1},\ldots,\delta_{n}$ 是 $\gamma k$ 的加法共享，即 $\gamma k=\delta_{1}+\ldots+\delta_{n}$。

[^3]: 我们强调 $\oplus$ 和 $\odot$ 分别表示加法和（标量）乘法的同态评估，而不是标准的加法和乘法。

接下来，每个 $\mathcal{P}_{i}$ 将 $(g^{\gamma_{i}},\delta_{i})$ 发送给所有人，参与方计算 $g^{k^{-1}}=(\prod_{i}g^{\gamma_{i}})^{(\sum_{j}\delta_{j})^{-1}}$，并通过设置 $\sigma_{i}=k_{i}m+\rho(x_{i}k_{i}+\sum_{j\neq i}\hat{\alpha}_{i,j}+\hat{\beta}_{i,j})$ 获得 $\sigma=k(m+\rho x)$ 的各自份额 $\sigma_{1},\ldots,\sigma_{n}$，其中 $m=\mathcal{H}(\text{msg})$ 是 msg 的哈希值，$\rho$ 是 $g^{k^{-1}}$ 的 $x$ 投影。最后，每个 $\mathcal{P}_{i}$ 将 $\sigma_{i}$ 发送给所有人，签名设置为 $(\rho,\sigma)$。总结来说，从参与方 $\mathcal{P}_{i}$ 的角度来看，协议进行如下，其中每个项目表示一轮：

1.  采样 $k_{i}$，$\gamma_{i}$ 并将 $K_{i}=\mathsf{enc}_{i}(k_{i})$ 发送给所有人。
2.  当获得 $\{K_{j}\}_{j\neq i}$ 时，按照规定设置 $\{D_{j,i},\hat{D}_{j,i}\}_{j\neq i}$，并将 $(D_{j,i},\hat{D}_{j,i})$ 发送给 $\mathcal{P}_{j}$，对于每个 $j\neq i$。
3.  当获得 $\{(D_{i,j},\hat{D}_{i,j})\}_{j\neq i}$ 时，按照规定设置 $\delta_{i}$，并将 $(\Gamma_{i}=g^{\gamma_{i}},\delta_{i})$ 发送给所有人。
4.  当获得 $\{(\Gamma_{j},\delta_{j})\}_{j\neq i}$ 时，按照规定设置 $\sigma_{i}$，并将其发送给所有人。

**输出**。当获得 $\{\sigma_{j}\}_{j\neq i}$ 时，按照规定设置 $\sigma$ 和 $\rho$，并输出 $(\rho,\sigma)$。

上述协议需要四轮通信。对于安全性，可以看出，**如果所有计算都正确执行**，那么在释放 $\sigma_{i}$ 之前，最多 $n-1$ 个参与方的联盟不会获得关于私钥 $x$ 的任何信息。此外，释放 $\sigma_{i}$ 等同于释放签名 $(\rho,\sigma)$。

然而，如果被腐化的参与方偏离协议规范，那么释放诚实参与方的（受恶意影响的）签名份额 $\sigma_{i}$ 可能会泄露关于私钥份额的信息（可能是其全部）。为了缓解这个问题，Gennaro 和 Goldfeder [31] 设计了一种特殊的、巧妙的技术，允许参与方在释放签名份额之前验证其有效性。然而，这种替代技术最终增加了五轮通信。

#### 1.2.2 我们的方法

使用上述蓝图，我们展示了参与方如何在基本协议的 4 轮之上不增加任何轮次的情况下验证签名份额的有效性，并且计算成本与 [31] 相当。有趣的是，我们通过采用“通用”（通常被认为成本高得令人望而却步）的 GMW 方法来实现这一结果，即通过零知识证明一路上每个计算的有效性，并利用签名功能性质的优化。此外，我们的方法保留了基本协议的自然属性，即消息仅在第四轮也是最后一轮中使用。这反过来又导致了我们的非交互式变体。主动密钥刷新阶段也以自然的方式构建在基本协议之上，并带有适当的零知识证明。

对于分析，我们采取了与 [31] 或 [45] 不同的方法。回想一下，Gennaro 和 Goldfeder [31] 仅证明了与他们的协议独立实例交互并（非自适应地）腐化 $t<n$ 个参与方的对手无法在参与方选择的公钥下伪造 ECDSA 签名。另一方面，Lindell 等人 [45] 表明，他们的协议在存在非自适应地腐化 $t<n$ 个参与方的对手的情况下 UC 实现 ECDSA 功能。后者确实是一个比独立不可伪造性更强的属性，体现在两个方面：首先，即使门限签名协议是更大系统的一部分，这个结果也成立。其次，安全评估 ECDSA 功能明显强于单纯的不可伪造性。虽然第一个加强显然是需要的，但第二个可能过于强（例如，它意味着秘密随机性 $k$ 的分布对于所有签名几乎是均匀的，无论消息如何）。

我们采取折衷方法：我们制定了 [11] 的理想签名功能 $\mathcal{F}_{\textsf{sign}}$ 的门限变体，并表明我们的协议 UC 实现此功能。这样，我们获得了一个即使我们的门限签名协议是更大系统的一部分也成立的结果。另一方面，我们避免了需要证明我们的协议 UC 实现 ECDSA 功能。这种看似微小的差异结果至关重要：首先，这使我们能够证明在参与方的**自适应**（甚至移动 [48]）腐化下的安全性。它还允许在协议中进行许多重要的简化。

#### 1.2.3 协议概述

我们继续我们的协议概述。为简单起见，我们省略了许多细节，特别是关于零知识证明的细节。我们请读者参阅后续技术部分以获取更多细节。让 $\bm{P}=\{\mathcal{P}_{1},\ldots,\mathcal{P}_{n}\}$ 表示参与方集合。让 $(\mathsf{enc}_{i},\mathsf{dec}_{i})$ 表示与参与方 $\mathcal{P}_{i}$ 关联的 Paillier 加密-解密算法；公钥在下面指定。在整个过程中，当我们说某个参与方广播消息时，我们指的是该参与方简单地将消息发送给所有其他参与方。

**密钥生成**。与基本协议一样，每个 $\mathcal{P}_{i}$ 采样（主）私钥 $x=\sum_{i}x_{i}$ 的本地随机秘密份额 $x_{i}\leftarrow\mathbb{F}_{q}$，然后通过以顺序方式承诺然后解承诺群元素来揭示 $X_{i}=g^{x_{i}}$。此外，每个参与方 $\mathcal{P}_{i}$ 广播一个 Schnorr NIZK（非交互式零知识知识证明）关于 $x_{i}$。

**辅助信息与密钥刷新**。每个 $\mathcal{P}_{i}$ 本地生成一个 Paillier 密钥 $N_{i}$ 并将其发送给其他参与方，同时附带一个 $N_{i}$ 构造良好（即，它是合适素数的乘积）的 NIZK。接下来，每个 $\mathcal{P}_{i}$ 选择 $0=\sum_{j}x_{i}^{j}$ 的随机秘密共享，并为每个 $j$（**包括他自己**）[^4] 计算 $X_{i}^{j}=g^{x_{i}^{j}}$ 和 $C_{i}^{j}=\mathsf{enc}_{j}(x_{i}^{j})$。然后 $\mathcal{P}_{i}$ 广播 $(X_{i}^{j},C_{i}^{j})_{j}$，同时附带一个 NIZK 证明 $C_{j}^{j}$ 的明文值模 $q$ 等于 $X_{i}^{j}$ 的指数。如果所有证明都有效**并且**对于每个 $j$，$\prod_{k}X_{j}^{k}=\mathsf{id}_{\mathbb{G}}$，则参与方通过设置 $x_{i}^{*}=x_{i}+\sum_{j}\mathsf{dec}_{i}(C_{j}^{i})\mod q$ 来更新他们的密钥份额。

[^4]: 这个指令可能看起来相当多余，但这对我们的安全性分析很重要；它允许提取对手的随机性。

**预签名**。我们的协议与 [31] 的一个技术区别是我们使用 Paillier 密码系统作为承诺方案。即，在参与方自己的公钥下加密值的过程产生了一个完美绑定和计算隐藏的承诺方案（只要 Paillier 是语义安全的）。因此，在协议中，我们指示每个参与方通过在他们自己的密钥下加密那些值来承诺 $\gamma_{i}$ 和 $k_{i}$，并广播 $G_{i}=\mathsf{enc}_{i}(\gamma_{i})$ 和 $K_{i}=\mathsf{enc}_{i}(k_{i})$。[^5] 同时，参与方启动份额计算阶段（对于 $x_{j}k_{i}=\alpha_{i,j}+\beta_{j,i}$ 和 $\gamma_{j}k_{i}=\hat{\alpha}_{i,j}+\hat{\beta}_{j,i}$），同时零知识证明乘法中使用的值与 $G_{i}$、$K_{i}$ 中加密的值以及公钥份额 $X_{i}=g^{x_{i}}$ 的指数相同。最后，当上述份额计算阶段结束时，参与方通信一个额外的消息以获得计算曲线上点 $R=g^{k^{-1}}\in\mathbb{G}$ 的信息，该点对应于（未来）签名的 nonce，同时零知识证明相关消息与承诺值 $K_{i},G_{i}$ 和 $X_{i}$ 一致。在预签名阶段结束时，每个参与方 $\mathcal{P}_{i}$ 在内存中存储元组 $(k_{i},\chi_{i},R)$，即 $k$ 的份额 $k_{i}$（即 $\sum_{i}k_{i}=k$），$kx$ 的份额 $\chi_{i}$（即 $\sum_{i}\chi_{i}=kx$），以及 nonce $R=g^{k^{-1}}\in\mathbb{G}$。

[^5]: 我们强调，加密是在参与方自己的公钥下进行的，而不是在接收方的公钥下。

使用 Paillier 密码系统作为承诺方案的好处是双重的。一方面，Paillier 密文适用于 Schnorr 型证明来证明指定计算的正确性。另一方面，在安全性分析中，它允许模拟器提取对手的秘密，因为被腐化参与方的 Paillier 密钥在之前的辅助信息阶段被提取。我们在以下小节中详细说明这一点。

ZK 证明的主要目的是绕过使用 Paillier 加密（它驻留在 RSA 模数的整数环中）来推导与 ECDSA 关联的椭圆曲线上的群元素所产生的安全陷阱（也在 [31] 和 [45] 中强调）。更详细地说，$k$ 和 $\gamma$ 的恶意选择可能允许对手探测诚实参与方秘密的位，这可能产生破坏性影响。为了补救这一点，与 [31, 45] 类似，我们使用 ZK 范围证明，目的是“强制”对手从合适的范围中选择值，从而防止上述攻击。为此，我们利用使用 Paillier 加密作为完美绑定承诺的优势，设计了新的更高效的范围证明。

总之，凭借“Paillier 承诺”和伴随的 ZK 证明，参与方 $\mathcal{P}_{i}$ 确信元组 $(R,k_{i},\chi_{i})$ 在预签名阶段结束时是良构的，并且与 [31, 45, 28, 21] 不同，不需要额外的通信轮次来验证元组的正确性。

**签名**。一旦消息 msg 已知，为了为预签名数据 $(R,k_{i},\chi_{i})$ 生成签名，每个 $\mathcal{P}_{i}$ 设置 $m=\mathcal{H}(\text{msg})$，计算 $\rho=R|_{x\text{-axis}}$，并将 $\sigma_{i}=k_{i}m+\rho\chi_{i}\mod q$ 发送给所有参与方。在收到其他参与方的 sigma 后，参与方输出签名 $(\rho,\sum_{i}\sigma_{i})=(\rho,k(m+\rho x))$。

#### 1.2.4 在线与非交互式签名

**在线签名**。对于交互式（在线签名），参与方简单地运行预签名阶段，然后是签名阶段，总共 4 轮。

**非交互式签名**。为了能够非交互式地签名，参与方需要在离线阶段准备一定数量的预签名。也就是说，对于某个预签名参数 $L\in\mathbb{N}$，参与方并发地运行预签名阶段 $L$ 次，并获得预签名数据 $\{(\ell,R_{\ell},k^{\ell}_{i},\chi^{\ell}_{i})\}_{\ell=1,\ldots,L}$。之后，对于每个使用预签名数据 $(\ell,R_{\ell},k^{\ell}_{i},\chi^{\ell}_{i})$ 和消息 msg 的签名请求，参与方运行相关输入的签名阶段以生成签名。然后参与方擦除预签名元组 $(\ell,\ldots)$。重要的是要确保，作为刷新阶段的一部分，任何未使用的预签名都被丢弃。[^6]

[^6]: 或者，只要预签名数据被适当刷新，即通过重新随机化对 $(k_{i},\chi_{i})$，就可以保留预签名数据。

**备注 1.1**。强调非交互式协议的安全性分析与在线协议不同，因为签名 nonce（$R$）在相应要签名的消息之前很久就知道了。如前所述，为了证明安全性，我们依赖于关于底层（非门限）方案不可伪造性的更强假设，我们将在下一节更详细地介绍它。

#### 1.2.5 安全性

本节假设对理想与现实范式和 UC 框架有一定熟悉度。

**现实与理想范式 & UC**。我们通过现实与理想范式和通用可组合性框架证明安全性。即，我们表明我们的协议模拟了一个涉及任务理想化版本的理想过程，并且我们证明对于每个攻击协议的对手，存在一个实现相同目标的理想对手（称为模拟器）。在非 UC（独立）框架中，这是通过使用对手的代码并通过（通常通过回绕）提取对手的秘密来完成的。

UC 框架通过一个称为**环境**的实体来增强上述范式，该实体与对手（在现实世界中）或模拟器（在理想世界中）以及计算中的参与方交互。环境的目标是猜测执行的是哪个过程（现实或理想）。如果没有环境能够区分现实和理想过程，那么可以得出结论，协议即使在“野外”也是安全的；即即使它与某个更大系统的其他（密码或非密码）组件任意组合。

独立安全协议和 UC 安全协议之间的一个主要技术区别是，在后者的安全性分析中，模拟器的提取技术库缺乏回绕。这通常使协议更加复杂，因为它需要适用于所谓在线提取的工具（例如，参见 Fischlin [29] 中 Schnorr 的 NIZK 知识证明的非回绕版本）。在安全性分析中不允许回绕技术也是实现针对自适应参与方腐化的安全性的主要障碍之一。

**UC 安全门限 ECDSA 与门限签名**。我们的安全性证明与 [45; 28] 的基于模拟的安全性证明之间的一个重要区别是我们的协议 UC 实现了一个“通用”理想门限签名功能，而不是 ECDSA 功能本身。我们选择前者的原因如下。首先，它更准确地捕捉了我们协议的目的；我们的目标是计算可通过 ECDSA 算法验证的不可伪造签名，而不是实现 ECDSA 功能本身。其次，更重要的是，它允许我们在安全性分析中重新引入回绕技术，这极大地简化了协议和安全性分析，如下所述。

**门限签名理想功能与 UC 模拟**。我们定义了一个理想门限签名功能，模仿了 Canetti [11] 的（非门限）签名功能。该功能的定义旨在捕捉任何门限签名方案的本质。即（非常松散地）：

1.  授权的参与方集合可以为任何给定消息生成有效签名。
2.  未经授权的参与方集合无法为以前从未签名过的消息计算有效签名。

我们强调，理想功能完全不了解签名方案的格式（实际上没有私钥/公钥）。因此，UC 模拟器很简单：它不加修改地运行未腐化参与方的程序，以与真实系统中分布相同的方式与环境交互——只要环境没有设法伪造签名。确实，只要环境不伪造签名，模拟就是**完美的**。

为了证明模拟的有效性，仍然需要表明环境**无法伪造**以前从未签名过的某些消息的签名；这是我们安全性证明的关键。在我们描述证明之前，我们强调这里我们只关心通过归约到底层假设的硬度来证明 UC 模拟的有效性。这些归约被允许“使环境离线”并使用整个提取技术库，包括回绕。更重要的是，这种方法通过随机预言机赋予证明全部权力，因此任何归约都可以适当地编程环境对随机预言机的查询，只要这些查询以前从未被查询过。

**不可伪造性证明**。我们通过归约到非门限 ECDSA 的不可伪造性来展示不可伪造性。更详细地说，我们考虑以下涉及模拟器试图模拟环境与诚实参与方交互的实验。

1.  在第一个实验中，模拟器遵循协议规范，除了：
    (a) 模拟器采样一个 ECDSA 密钥对 $(x,X)$ 并将门限协议的公钥固定为 $X$（这是通过回绕环境实现的）。
    (b) 模拟器提取被腐化参与方的 Paillier 密钥（这是通过编程随机预言机实现的）。
    (c) 模拟器从不解密在诚实参与方 Paillier 密钥下加密的密文。相反，为了进行模拟，模拟器使用在项目 1b 中提取的 Paillier 密钥从被腐化参与方的消息中提取相关值。
    (d) 为了计算诚实参与方的 ZK 证明，模拟器调用零知识模拟器生成有效证明，并相应地编程随机预言机。

2.  第二个实验与第一个相同，除了：
   
    (a) 在实验开始时，模拟器选择一个随机的诚实参与方，该参与方从此被视为特殊参与方（实际上，为了处理自适应腐化，每次执行密钥刷新阶段时都会重新选择这个随机参与方。如果环境决定腐化特殊参与方，则实验重置到最后一次密钥刷新；通过回绕环境）。

    (b) 每次指示诚实参与方在特殊参与方的 Paillier 密钥下加密一个值并将其发送给被腐化的参与方时，模拟器发送一个随机加密的 $0$ 代替。

3.  第三个实验与第二个类似，除了模拟是在**没有**特殊参与方秘密知识的情况下进行的，使用标准/增强的 ECDSA 预言机。

我们通过展示如果环境在我们协议的执行中伪造签名，那么环境也在上述所有三个实验中伪造签名，并且从第三个实验我们得出结论，环境为普通（非门限）ECDSA 签名方案伪造签名，与其假定的安全性相矛盾。

前两个实验是证明环境在第三个实验中伪造的垫脚石。更详细地说，只要所有 ZK 证明都是可靠的（并且模拟器提取了正确的值），真实执行和第一个实验在统计上是接近的。只要 Paillier 密码系统是语义安全的，第一个和第二个实验在计算上是接近的。最后，第二个和第三个实验是（在完美意义上）相同的。

**处理自适应参与方腐化**。为了表明我们的协议实现了针对自适应参与方腐化的安全性，足以论证实验 2 和 3 终止。假设 CDR 和强 RSA，我们的分析得出两个实验都在与参与方数量准成正比的时间内终止，并且环境在第三个实验中伪造签名，与假定的普通 ECDSA 安全性相矛盾。因此，在合适的密码学假设下，除非环境在密钥刷新阶段之间同时腐化所有参与方，否则我们的方案是不可伪造的。

**我们协议的整体 UC 安全性**。从以上所述可以得出，如果 ECDSA 签名方案是存在性不可伪造的，那么我们协议的在线变体 UC 实现理想签名功能。类似地，如果 ECDSA 是**增强**存在性不可伪造的，那么我们协议的离线变体 UC 实现理想签名功能。

我们提醒读者，存在性不可伪造性是通过一个游戏定义的，在该游戏中，一个潜在的伪造者被授予访问签名预言机的权限，允许攻击者签名（任意）自己选择的消息。如果攻击者设法为以前未签名的消息生成有效签名，则攻击者赢得游戏。我们定义了不可伪造性游戏的增强变体，其中签名的独立于消息的数据（即 $g^{k^{-1}}$，此后称为签名的 _nonce_）可以被攻击者在生成要签名的消息**之前**查询；这样攻击者可以为签名预言机选择与随机 nonce 相关的消息，这可能有助于生成伪造。

**增强不可伪造性的证据**。为了支持我们关于 ECDSA 是**增强**存在性不可伪造的假设，我们表明它在以下理想化模型中成立：

1.  在随机预言机模型中，只要没有提前查询太多 nonce，并且标准（非增强）ECDSA 是存在性不可伪造的。
2.  在随机预言机和泛型群模型中，无条件地。[^7]

[^7]: 更准确地说，我们表明任何泛型伪造者找到 $x$, $y$ 使得 $\mathcal{H}(x)/\mathcal{H}(y)=e$，对于随机 $e\leftarrow\mathbb{F}_{q}$，其中 $\mathcal{H}$ 表示哈希函数。我们推测后者对于涉及 SHA 的 ECDSA 实际实现也是困难的。

以上两者都通过归约来展示。对于项目 1，归约模拟随机预言机并尝试猜测对手将要请求签名的消息；这就是为什么不能提前查询太多 nonce，因为猜测概率（超）指数下降。对于项目 2，归约模拟群，**就好像**它是一个由两个基点 $G$ 和 $X$（分别对应于群生成器和 ECDSA 公钥）生成的自由群。由于模拟的（自由）群与泛型群无法区分，因此任何伪造都利用了哈希函数中的弱点，我们通过假设排除了这一点。

#### 1.2.6 非交互式零知识证明

我们的协议广泛使用非交互式零知识证明（NIZK），通过使用 Fiat-Shamir 变换（FS）编译三移动零知识协议（也称为 $\Sigma$-协议）的标准技术，即验证者的消息由证明者自己通过调用预定的哈希函数来计算。

在随机预言机模型中，Fiat-Shamir 变换产生了 NIZK 证明系统。此外，因为我们完全避免了“在线提取”的需要（参见第 1.2.5 节），我们对 Fiat-Shamir 变换的使用**不会**干扰通用可组合性，并且我们的协议如所述是 UC 的。

我们通过呈现我们使用的（交互式）零知识技术的原始版本来结束对我们技术的概述。该技术有些标准 [3, 7, 8, 30, 46]；我们在这里为了方便而详细说明。然而，分析有些复杂，并且对于理解我们的门限签名协议不是至关重要的。因此，如果需要，可以跳过本节。

**Paillier & 强 RSA**。我们回忆 Paillier 密文具有形式 $C=(1+N)^{x}r^{N}\mod N^{2}$，其中 $N$ 表示公钥，$x\in\mathbb{Z}_{N}$ 是明文，$r$ 是 $\mathbb{Z}^{*}_{N}$ 的随机元素。我们进一步回忆强 RSA 假设：对于未知因式分解的 RSA 模数 $N$，对于均匀随机的 $y\in\mathbb{Z}_{N}$，找到 $(x,e)$ 使得 $e>1$ 且 $x^{e}=y\mod N$ 是不可行的。最后，在我们描述零知识技术之前，我们（非正式地）定义 Ring-Pedersen 承诺。[^8]

[^8]: 我们使用前缀 'ring' 来区分驻留在已知阶群中的“群”Pedersen 承诺。

**定义 1.2**（Ring-Pedersen - 非正式）。让 $N$ 是一个 RSA 模数，让 $s$, $t\in\mathbb{Z}^{*}_{N}$ 是非平凡的二次剩余。具有公共参数 $(N,s,t)$ 的 $m\in\mathbb{Z}_{N}$ 的 Ring-Pedersen 承诺计算为 $C=s^{m}t^{\rho}\mod N$，其中 $\rho\leftarrow\mathbb{Z}_{N}$。

**原始 ZK 范围证明**。考虑以下关系：

$$R=\{(C_{0},N_{0},C_{1},N_{1},s,t;\alpha,\beta,r) \mid C_{0}=(1+N_{0})^{\alpha}r^{N_{0}}\mod N_{0}^{2} \wedge C_{1}=s^{\alpha}t^{\beta}\mod N_{1} \wedge \alpha \in \pm 2^{\ell}\}.$$

换句话说，证明者必须表明 $C_{0}$ 的 Paillier 明文等于 Ring-Pedersen 承诺 $C_{1}$ 中的隐藏值，并且它位于范围 $\pm 2^{\ell}=[-2^{\ell},+2^{\ell}]$ 内，其中 $2^{\ell}\ll N_{0},N_{1}$。假设 Paillier 模数 $N_{0}$ 由证明者生成，而 Ring-Pedersen 参数 $(N_{1},s,t)$ 由验证者生成。我们进一步假设 $N_{0}$ 和 $N_{1}$ 是作为合适[^9] 素数的乘积生成的，并且 $s$ 和 $t$ 是 $\mathbb{Z}^{*}_{N_{1}}$ 中的非平凡二次剩余。这个假设不会丧失一般性，因为在实际协议中，我们指示参与方零知识证明所有参数都是正确生成的。[^10]

[^9]: $N_{0}$ 和 $N_{1}$ 应该是作为安全素数的乘积获得的双素数。
[^10]: 实际上，出于效率原因，我们证明了对于我们的目的足够弱的陈述。

我们现在转向描述关系 $R$ 的 ZK 证明在其交互式变体下的描述（实际证明使用 Fiat-Shamir 变换编译为非交互式）。我们执行 Schnorr 型证明如下：证明者加密一个随机值 $\gamma$ 为 $D_{0}=(1+N_{0})^{\gamma}\rho^{N_{0}}\mod N_{0}^{2}$ 对于合适的随机 $\rho$，计算一个 Ring-Pedersen 承诺 $D_{1}=s^{\gamma}t^{\delta}\mod N_{1}$ 给 $\gamma$ 对于合适的随机 $\delta$，并将 $(D_{0},D_{1})$ 发送给验证者。验证者然后回复一个挑战 $e\leftarrow \pm 2^{\ell}$，证明者通过发送 $z_{1}=\gamma+e\alpha$ 来解决挑战。验证者仅当 $z_{1}$ 在合适的范围内并通过两个等式检查（一个用于加密，一个用于承诺）时才接受。直观上，证明者无法欺骗验证者，因为证明者作弊的“唯一方式”是知道 $\mathbb{Z}^{*}_{N_{1}}$ 的阶，这由验证者秘密生成，因此会违反强 RSA 假设。更详细地说：

1.  证明者计算 $D_{0}=(1+N_{0})^{\gamma}\rho^{N_{0}}\mod N_{0}^{2}$ 和 $D_{1}=s^{\gamma}t^{\delta}\mod N_{1}$，对于随机元素 $\gamma\leftarrow \pm 2^{\ell+\varepsilon}$，$\delta\leftarrow \pm N_{1}\cdot 2^{\varepsilon}$ 和 $\rho\leftarrow\mathbb{Z}^{*}_{N_{0}}$，并将 $(D_{0},D_{1})$ 发送给验证者。
2.  验证者回复 $e\leftarrow \pm 2^{\ell}$。
3.  证明者计算
    $$\begin{cases}z_{1}&=\gamma+e\alpha\\ z_{2}&=\delta+e\beta\\ w&=\rho\cdot r^{e}\mod N_{0}\\ \end{cases}$$
    并将 $(z_{1},z_{2})$ 发送给验证者。

*   **验证**：如果 $z_{1}\in \pm 2^{\ell+\varepsilon}$ 且 $(1+N_{0})^{z_{1}}w^{N}=C_{0}^{e}\cdot D_{0}\mod N_{0}^{2}$ 且 $s^{z_{1}}t^{z_{2}}=C_{1}^{e}\cdot D_{1}\mod N_{1}$，则接受。

我们注意到，$z_{1}$ 的范围检查与期望范围之间存在（乘法因子）$2^{\varepsilon}$ 的差异，称为松弛参数；这是证明的一个特性，因为 $\alpha$ 的范围仅在该松弛参数内得到保证。我们现在转向 ZK 证明的分析（完备性、诚实验证者零知识性和可靠性）。

很容易证明上述协议满足完备性和（诚实验证者）零知识性，并带有一些统计误差。困难的任务是证明可靠性 [8, 30, 46]。遵循标准范式，我们通过从形式为 $(D_{0},D_{1},e,z_{1},z_{2},w)$ 和 $(D_{0},D_{1},e^{\prime},z_{1}^{\prime},z_{2}^{\prime},w^{\prime})$ 的两个接受转录本中提取秘密来展示特殊可靠性，使得 $e\neq e^{\prime}$。让 $\Delta_{e}$，$\Delta_{z_{1}}$，$\Delta_{z_{2}}$ 表示相关差异。我们观察到，如果 $\Delta_{e}$ 整除 $\Delta_{z_{1}}$ 和 $\Delta_{z_{2}}$（在整数中），那么所有值都可以如下提取而无问题：$\alpha$ 和 $\beta$ 分别设置为 $\Delta_{z_{1}}/\Delta_{e}\in \pm 2^{\ell+\varepsilon}$ 和 $\Delta_{z_{2}}/\Delta_{e}$，并且 $\rho$ 可以从等式 $(w\cdot w^{\prime-1})^{N}=(C_{0}(1+N_{0})^{-\alpha})^{\Delta_{e}}\mod N_{0}^{2}$ 中提取（这允许计算 $w/w^{\prime}$ 模 $N_{1}$ 的 $\Delta_{e}$ 次根，参见事实 D.2）。因此，可靠性证明归结为表明 $\Delta_{e}$ 整除 $\Delta_{z_{1}}$ 和 $\Delta_{z_{2}}$，**除非强 RSA 问题是易处理的**。即，存在一个算法 $\mathcal{S}$ 具有对证明者的黑盒访问权限，可以解决强 RSA 挑战 $t$（第二个 Ring-Pedersen 参数）。[^11]

[^11]: 参数 $t$ 在 $\mathbb{Z}_{N_{1}}$ 中不是完全随机的，因为它是一个二次剩余，但这不影响分析。

为了进一步阐述，假设 $\mathcal{S}$ 知道 $\lambda$ 使得 $t^{\lambda}=s\mod N_{1}$ 并且 $\lambda$ 是从 $[N_{1}^{2}]$ 中采样的（而不仅仅是 $[N_{1}]$）。因此，不深入细节，如果 $\Delta_{e}\nmid \Delta_{z} = \lambda\Delta_{z_{1}}+\Delta_{z_{2}}$，那么 $\mathcal{S}$ 可以通过计算 $\Delta_{e}$ 和 $\Delta_{z}$ 上的 Euclid 扩展算法来解决强 RSA 挑战。另一方面，如果 $\Delta_{e}\nmid \Delta_{z_{1}}$ 或 $\Delta_{z_{2}}$，我们声称 $\Delta_{e} \mid \Delta_{z}$ 的概率最多为 $1/2$。要了解原因，观察到存在至少另一个 $\lambda^{\prime}\neq \lambda$ 在 $[N_{1}^{2}]$ 中使得 $t^{\lambda}=t^{\lambda^{\prime}}=s\mod N_{1}$，因为 $t$ 的阶是 $\phi(N_{1})/4=O(N_{1})$ 并且 $\lambda$ 是从 $[N_{1}^{2}]$ 中均匀采样的。由于证明者无法区分两个 $\lambda$（在完美信息论意义上），如果 $\Delta_{e}\nmid \Delta_{z_{1}}$ 或 $\Delta_{z_{2}}$，那么 $\Delta_{e}$ 整除 $\lambda\Delta_{z_{1}}+\Delta_{z_{2}}$ 的概率最多为 $1/2$（即证明者正确猜出了算法 $\mathcal{S}$ 知道哪个 $\lambda$）。[^12] 总之，提取失败的概率最多是破解强 RSA 概率的两倍，假设后者是可忽略的。

[^12]: 论证更加微妙，因为我们需要表明 $\Delta_{e}$ 不能同时整除两个值（参见第 4.1 节）。

**在 ZK 证明中移除计算假设**。我们指出，有一种有些标准的方法 [3, 4, 7] 可以调整上述 ZK 证明以获得无条件提取器（不依赖于强 RSA 或任何其他硬度假设），但代价是更高的通信成本。[^13] 考虑关系

[^13]: 在不同上下文中的类似技巧出现在 Lindell [42]，来自 Boudot [3] 和 Brickell 等人 [4]。

$$R=\{(C_{0},N_{0};\alpha,r) \mid C_{0}=(1+N_{0})^{\alpha}r^{N_{0}}\mod N_{0}^{2} \wedge \alpha \in \pm 2^{\ell}\}.$$

注意它与之前的关系相同，只是我们去掉了 Ring-Pedersen 承诺。然后，通过从上述协议中移除 $D_{1}$ 和 $z_{2}$，**并限制** $e\leftarrow\{0,1\}$（而不是 $\pm 2^{\ell}$），我们获得了一个具有无条件提取和可靠性错误 $1/2$ 的零知识知识证明。使用与之前相同的符号，注意新协议保证 $\Delta_{e}$ 整除 $\Delta_{z_{1}}$，因为 $\Delta_{e}\in\{-1,1\}$，因此可除性无需任何硬度假设即可保证。缺点在于，恶意证明者可能总是以 $1/2$ 的概率作弊，因此必须重复协议以达到令人满意的可靠性。由于协议涉及 Paillier 操作，这将导致证明大小的相当昂贵（超对数）膨胀因子。

#### 1.2.7 扩展到 $t$-out-of-$n$ 访问结构

在这项工作中，我们主要关注 $n$-out-of-$n$ 多方签名，并没有明确考虑更一般的 $t$-out-of-$n$ 门限签名，其中 $t<n$。这样的协议几乎可以立即从我们这里的在线变体协议中导出，使用 Shamir 秘密共享，并对协议的组件进行相关更改，类似于 Gennaro 和 Goldfeder [31]。

相同的技术也可以应用于非交互式变体，但必须特别注意参与方存储在内存中的预处理数据。具体来说，每个不同的“授权”参与方集合（大小至少为 $t$）应生成新的独立预处理数据。参与不同授权集合的参与方**不得**在集合之间使用相同的预处理数据。我们强调，使用依赖的共享预处理数据对两个不同的消息进行签名可能启用揭示私钥的攻击。

### 1.3 其他相关工作

**门限 ECDSA**。所有最近的门限 ECDSA 协议都遵循第 1.2.1 节中描述的蓝图的（变体），其中参与方本地生成 $k$ [45, 28] 或 $k^{-1}$ [31, 21] 的份额 $k_{1}^{*}\ldots k_{n}^{*}$，然后通过结合本小节开头描述的掩码技术的配对乘法协议共同计算 $r=g^{k^{-1}}|_{x\text{-axis}}$ 和 $k(m+rx)$ 的份额。此外，所有协议都采取某种乐观的方法，其中乘法中计算值的正确性仅在计算发生后进行验证；这是轮复杂度成本的主要来源。

在安全性方面，如前所述，Gennaro 和 Goldfeder [31] 表明他们的协议在标准假设（DDH、CDR、强 RSA、ECDSA）下满足基于游戏的安全性定义（即他们协议的不可伪造性）。Castagnos 等人 [21] 的协议遵循相同的模板，只是它用基于类群 [20] 的加密方案替换了 Paillier。具体来说，他们表明他们的方案在假设 DDH 和虚二次域类群上的额外假设（特别是硬子群成员资格、低阶假设和强根）的情况下是不可伪造的。[^14]

[^14]: 这些假设可以被视为类群的 CDR 和强 RSA 的类似物。

Lindell 等人 [45] 和 Doerner 等人 [28] 展示了 ECDSA 功能的安全函数评估，并证明他们各自的协议在具有理想承诺和零知识证明的混合模型中 UC 实现所述功能，假设 DDH。然而，正如作者自己指出的那样，他们推荐用于替换理想调用的实际子程序不保留通用可组合性（即使在 ROM 中）。我们强调，我们的协议**按原样**满足通用可组合性（尽管在随机预言机模型中）。

**并发工作**。我们讨论 Damgard 等人 [24] 和 Gagol 和 Straszak [37] 的同时期工作。在 [24] 中，作者考虑了**诚实多数**设置下的门限 ECDSA，并基于早期 Gennaro 等人 [32] 的诚实多数协议设计了一个协议。作者表明他们的协议是 UC 安全且可中止的，并且他们还展示了如何引导他们的协议以实现公平性。作者还提到了他们协议的非交互式变体，通过预处理除一轮之外的所有轮次，但没有为后者提供安全性分析。

在 [37] 中，受具有**大量**签名者的 MPC 钱包应用的推动，作者基于 [45] 设计了一个协议，该协议还通过用额外的 ZK 证明增强协议来支持可识别中止形式的鲁棒性，并且他们表明他们的协议在具有理想承诺和零知识证明的混合模型中在独立（非 UC）设置下是安全的。我们强调，无论是 [24] 还是 [37] 都不支持密钥的主动刷新，并且这些协议不知道在系统进展过程中对手自适应地腐化参与方时提供传统的门限安全性。

**非交互式签名的替代方案**。最近有了一些实现与离线设备（冷钱包）兼容的 MPC 签名的替代提案，通过在 MPC 系统之上构建——而不是将这种能力纳入 MPC 系统内部 [43, 44]。更详细地说，[43, 44] 有两种类型的受托人：签名受托人和解密受托人。指示签名受托人（共同）计算一个**加密的**签名，该签名随后被转发给解密受托人，后者共同解密密文并获得签名。虽然签名者和解密者之间的通信确实是单向的，但签名生成的整体过程仍然被潜在显著的交互所减慢。此外，一旦所有签名者被腐化，他们可以在没有任何解密者参与的情况下自行生成签名。

**为主动安全性引导认证**。Kondi 等人 [40] 考虑了在主动刷新阶段某些签名者保持离线的情况，并且当他们重新上线时与其他签名者没有可靠的经过认证的通信。（确实，在加密货币托管的背景下，可能希望离线“冷”钱包以自己的节奏参与刷新，这反过来可能为攻击打开大门。）他们展示了这样的迟到签名者如何通过使用区块链本身作为认证其他签名者公钥的手段来重新获得与系统其余部分的经过认证的通信。该解决方案可以被视为使用区块链作为实现 Canetti 等人 [15] 解决方案中持久门限签名方案的一种方式。

## 2 预备知识

**符号**。整篇论文中 $\mathbb{G}$ 表示一个素数阶 $q$ 的群，$\mathbb{F}_{q}$ 表示具有 $q$ 个元素的有限域。我们让 $\mathbb{Z},\mathbb{N}$ 分别表示整数集和自然数集。我们使用无衬线字母（enc,dec,$\ldots$）或书法体（$\mathcal{S},\mathcal{A},\ldots$）表示算法。秘密值总是用小写字母（$p,q,\ldots$）表示，公共值**通常**用大写字母（$A,B,N,\ldots$）表示。此外，对于同时包含公共和秘密值的元组，例如 RSA 模数及其因子 $(N,p,q)$，我们使用分号来区分公共值和秘密值（因此我们写 $(N;p,q)$ 而不是 $(N,p,q)$）。对于 $t\in\mathbb{Z}_{N}$，我们写 $\langle t\rangle=\{t^{k}\bmod N \ \text{ s.t. } \ k\in\mathbb{Z}\}$ 表示由 $t$ 生成的乘法群。对于 $\ell\in\mathbb{Z}$，我们让 $\pm\ell$ 表示整数区间 $\{-|\ell|,\ldots,0,\ldots,|\ell|\}$。我们写 $x\gets X$ 表示从集合 $X$ 中均匀采样 $x$（或根据分布 $X$）。最后，让 $\gcd:\mathbb{N}^{2}\rightarrow\mathbb{N}$ 和 $\phi:\mathbb{N}\rightarrow\mathbb{N}$ 分别表示 gcd 操作和欧拉函数。

### 2.1 定义

**定义 2.1**。我们说 $N\in\mathbb{N}$ 是一个 Paillier-Blum 整数当且仅当 $\gcd(N,\phi(N))=1$ 且 $N=pq$，其中 $p$, $q$ 是满足 $p,q\equiv 3\mod 4$ 的素数。

**定义 2.2**（Paillier 加密）。将 Paillier 密码系统定义为下面的三元组 $(\mathsf{gen},\mathsf{enc},\mathsf{dec})$。

1.  让 $(N;p,q)\gets\mathsf{gen}(1^{\kappa})$，其中 $p$ 和 $q$ 是 $\kappa/2$ 长的素数且 $N=pq$。写 $\mathsf{pk}=N$ 和 $\mathsf{sk}=(p,q)$。
2.  对于 $m\in\mathbb{Z}_{N}$，让 $\mathsf{enc}_{\mathsf{pk}}(m;\rho)=(1+N)^{m}\cdot\rho^{N}\mod N^{2}$，其中 $\rho\gets\mathbb{Z}^{*}_{N}$。
3.  对于 $c\in\mathbb{Z}_{N^{2}}$，让 $\mu=\phi(N)^{-1}\mod N$，
    $$\mathsf{dec}_{\mathsf{sk}}(c)=\left(\frac{\left[c^{\phi(N)}\mod N^{2}\right]-1}{ N}\right)\cdot\mu\mod N.$$

**定义 2.3**（ECDSA）。让 $(\mathbb{G},g,q)$ 表示与给定曲线关联的群-生成元-阶元组。我们回忆 $\mathbb{G}$ 中的元素表示为对 $a=(a_{x},a_{y})$，其中 $a_{x}$ 和 $a_{y}$ 分别称为 $a$ 在 $x$ 轴和 $y$ 轴上的投影，分别表示为 $a_{x}=a|_{x\text{-axis}}$ 和 $a_{y}=a|_{y\text{-axis}}$。下面的安全参数隐式设置为 $\kappa=\log(q)$。

_参数_：群-生成元-阶元组 $(\mathbb{G},q,g)$ 和哈希函数 $\mathcal{H}:\bm{M}\rightarrow\mathbb{F}_{q}$。

1.  $(X;x)\gets\mathsf{gen}(\mathbb{G},q,g)$ 使得 $x\gets\mathbb{F}_{q}$ 且 $X=g^{x}$。
2.  对于 $\operatorname{msg}\in\bm{M}$，让 $\mathsf{sign}_{x}(m;k)=(r,k(m+rx))\in\mathbb{F}_{q}^{2}$，其中 $k\gets\mathbb{F}_{q}$ 且 $m=\mathcal{H}(\operatorname{msg})$ 且 $r=g^{k^{-1}}|_{x\text{-axis}}\bmod q$。
3.  对于 $(r,\sigma)\in\mathbb{F}_{q}^{2}$，定义 $\mathsf{vrfy}_{X}(m,\sigma)=1$ 当且仅当 $r=(g^{m}\cdot X^{r})^{\sigma^{-1}}|_{x\text{-axis}}\mod q$。

### 2.2 NP 关系

**Schnorr**。对于由群 $\mathbb{G}$ 中元素 $g$ 组成的参数 $(\mathbb{G},g)$，以下关系验证证明者知道群元素 $X$ 的指数。对于形式为 $(\mathbb{G},g)$ 的 $\mathsf{PUB}_{0}$，定义
$$R_{\mathsf{sch}}=\left\{(\mathsf{PUB}_{0},X;x) \mid X=g^{x}\right\}.$$

**Paillier 加密范围**。对于 Paillier 公钥 $N_{0}$，以下关系验证 Paillier 密文 $C$ 的明文值在期望范围 $\mathcal{I}$ 内。定义
$$R_{\mathsf{enc}}=\left\{(N_{0},\mathcal{I},C;x,\rho) \mid x\in\mathcal{I} \ \wedge\ C=(1+N_{0})^{x}\rho^{N_{0}}\in\mathbb{Z}_{N_{0}^{2}}^{*}\right\}.$$

**群元素与 Paillier 加密范围**。对于由群 $\mathbb{G}$ 和 Paillier-Blum 模数 $N$ 组成的参数 $(\mathbb{G},N)$，以下关系验证 $X$ 以 $g$ 为底的离散对数等于 $C$ 的明文值且在范围 $\mathcal{I}$ 内。对于形式为 $(\mathbb{G},N)$ 的 $\mathsf{PUB}_{1}$，定义
$$R_{\mathsf{log}}=\left\{(\mathsf{PUB}_{1},\mathcal{I},C,X,g;x,\rho) \mid x\in\mathcal{I} \ \wedge\ C=(1+N)^{x}\rho^{N}\in\mathbb{Z}_{N^{2}}^{*} \ \wedge\ X=g^{x}\right\}.$$

**具有群承诺的 Paillier 仿射操作范围**。对于由群 $\mathbb{G}$ 中的元素 $g$ 和 Paillier 公钥 $N_{0}$, $N_{1}$ 组成的参数 $(\mathbb{G},g,N_{0},N_{1})$，以下关系验证 Paillier 密文 $C\in\mathbb{Z}_{N_{0}^{2}}^{*}$ 是通过对 $C_{0}$ 进行仿射类变换获得的，使得乘法系数（即 $\varepsilon$）等于 $X\in\mathbb{G}$ 在范围 $\mathcal{I}$ 内的指数，并且加法系数（即 $\delta$）等于 $Y\in\mathbb{Z}_{N_{1}}$ 的明文值并驻留在范围 $\mathcal{J}$ 内。对于形式为 $(\mathbb{G},g,N_{0},N_{1})$ 的 $\mathsf{PUB}_{2}$，定义 $R_{\sf aff-g}$ 为所有元组 $(\mathsf{PUB}_{2},\mathcal{I},\mathcal{J},C,C_{0},Y,X;\varepsilon,\delta,r,\rho)$ 使得
$$(\varepsilon,\delta)\in\mathcal{I}\times\mathcal{J} \ \wedge\ C=C_{0}^{\varepsilon}\cdot(1+N_{0})^{\delta}r^{N_{0}}\in\mathbb{Z}_{N_{0}^{2}}^{*} \ \wedge\ Y=(1+N_{1})^{\delta}\rho^{N_{1}}\in\mathbb{Z}_{N_{1}^{2}}^{*} \ \wedge\ X=g^{\varepsilon}\in\mathbb{G}.$$

**具有 Paillier 承诺的 Paillier 仿射操作范围**。这是前一个关系的变体，唯一区别是现在 $\varepsilon$ 等于 $X\in\mathbb{Z}_{N_{1}^{2}}^{*}$ 的明文值（而不是之前 $X\in\mathbb{G}$ 的指数）。对于形式为 $(N_{0},N_{1})$ 的 $\mathsf{PUB}_{3}$，定义 $R_{\sf aff-p}$ 为所有元组 $(\mathsf{PUB}_{3},\mathcal{I},\mathcal{J},C,C_{0},Y,X;\varepsilon,\delta,r,\rho,\mu)$ 使得
$$(\varepsilon,\delta)\in\mathcal{I}\times\mathcal{J} \ \wedge\ C=C_{0}^{\varepsilon}\cdot(1+N_{0})^{\delta}r^{N_{0}}\in\mathbb{Z}_{N_{0}^{2}}^{*} \ \wedge\ Y=(1+N_{1})^{\delta}\rho^{N_{1}}\in\mathbb{Z}_{N_{1}^{2}}^{*} \ \wedge\ X=(1+N_{1})^{\varepsilon}\mu^{N_{1}}\in\mathbb{Z}_{N_{1}^{2}}^{*}.$$

#### 2.2.1 辅助关系

**Paillier-Blum 模数**。以下关系验证模数 $N$ 与 $\phi(N)$ 互质并且恰好是两个合适奇素数的乘积，其中 $\phi(\cdot)$ 是欧拉函数。
$$R_{\sf mod}=\{(N;p,q) \mid {\sf PRIMES}\ni p,q\equiv 3\mod 4 \ \wedge\ N=pq \ \wedge\ \gcd(N,\phi(N))=1\}.$$

**Ring-Pedersen 参数**。以下关系验证元素 $s\in\mathbb{Z}_{N}^{*}$ 属于由 $t\in\mathbb{Z}_{N}$ 生成的（乘法）群。
$$R_{\sf prm}=\left\{(N,s,t;\lambda) \mid s=t^{\lambda}\mod N\right\}.$$

**无小因子模数**。对于参数 $\ell$，以下关系验证模数 $N$ 可以分解为两个大于 $2^{\ell}$ 的数。
$$R_{\sf fac}=\left\{(\ell,N;p,q) \mid N=pq \ \wedge\ p,q>2^{\ell}\right\}.$$

**备注 2.4**。在下文中，为简化符号，当不会引起混淆时，我们省略写由 $\mathsf{PUB}_{*}$ 描述的公共参数。

### 2.3 Sigma 协议

在本节中，我们定义零知识协议，重点介绍交互式三移动协议，称为 $\Sigma$-协议。在第 2.3.1 节中，我们使用随机预言机通过 Fiat-Shamir 启发式编译这些协议以生成（非交互式）证明。我们定义两种 $\Sigma$-协议的概念。第一种是“不可提取的”零知识，具有标准可靠性，即对于关系 $R$ 和 $x$，使得**不存在** $w$ 满足 $(x,w)\in R$，作弊证明者使验证者相信 $x$ 满足关系的概率是可忽略的。第二个定义增强了可靠性属性，使得能够从两个合适的接受转录本中提取；后一个属性称为特殊可靠性。

**定义 2.5**。关系 $R$ 的 $\Sigma$-协议 $\Pi$ 是一个 PPT 算法的元组 $(\mathsf{P}_{1},\mathsf{P}_{2},\mathsf{V}_{1},\mathsf{V}_{2})$，使得

*   $\mathsf{P}_{1}$ 接受输入 $\kappa=|x|$ 和随机输入 $\tau$ 并输出 $A$，而 $\mathsf{V}_{1}$ 输出其随机输入 $e$。
*   $\mathsf{P}_{2}$ 接受输入 $(x,w,\tau,e)$ 并输出 $z$，而 $\mathsf{V}_{2}$ 接受输入 $(x,A,e,z)$ 并（确定性地）输出一个位 $b$。

安全属性：

*   _完备性_。如果 $(x,w)\in R$，那么对于 $e\gets\mathsf{V}_{1}$ 的选择（作为 $|x|$ 的函数），对于每个 $A\gets\mathsf{P}_{1}(\tau)$ 和 $z\gets\mathsf{P}_{2}(x,w,\tau,e)$，以压倒性概率成立 $V_{2}(x,A,e,z)=1$。

*   _可靠性_。如果 $x$ 对于 $R$ 是假的（即对于所有 $w$，$(x,w)\notin R$），那么对于任何 PPT 算法 $\mathsf{P}^{*}$ 和每个 $A$，以下对于 $e\gets V_{1}$（作为 $\kappa$ 的函数）以压倒性概率成立：如果 $z\gets\mathsf{P}^{*}(x,A,e)$ 那么 $V_{2}(x,A,e,z)=0$。
*   _HVZK_。存在一个模拟器 $\mathcal{S}$ 使得 $(A,e,z)\gets\mathcal{S}(x)$ 成立并且 $V_{2}(x,A,e,z)=1$ 对于每个 $x$，以压倒性概率超过 $\mathcal{S}$ 的随机硬币。此外，以下分布在统计上不可区分。对于 $(x,w)\in R$：
    *   $(A,e,z)$ 其中 $e\gets V_{1}$ 且 $A\gets\mathsf{P}_{1}(x,w,\tau)$，且 $z=\mathsf{P}_{2}(x,w,\tau,e)$。
    *   $(A,e,z)$ 其中 $e\gets V_{1}$ 且 $(A,z)\gets\mathcal{S}(x,e)$。

我们使用 $\Sigma$-协议来证明 Paillier-Blum 模数是良构的（$R_{\mathsf{mod}}$）并且 Ring-Pedersen 参数是合适的（$R_{\mathsf{prm}}$），我们分别表示这些 $\Sigma$-协议为 $\Pi^{\mathsf{mod}}$ 和 $\Pi^{\mathsf{prm}}$（分别参见第 4.3 和 4.4 节）。注意对于 $\Pi^{\mathsf{mod}}$ 第一条消息 $A$ 是空的，所以我们可以假设 $A$ 是某个常量默认字符串。

**定义 2.6**。具有设置 $\sigma$ 和特殊可靠性的关系 $R$ 的 $\Sigma$-协议 $\Pi_{\sigma}$ 是一个 PPT 算法的元组 $(\mathsf{S},\mathsf{P}_{1},\mathsf{P}_{2},\mathsf{V}_{1},\mathsf{V}_{2})$，满足（无设置和特殊可靠性）$\Sigma$-协议定义的相同功能和安全性属性，具有以下变化：

1.  设置算法 $\mathsf{S}$ 最初生成 $\sigma$，它是所有其他算法的公共输入。
2.  可靠性属性被替换为：
    *   _特殊可靠性_。存在一个高效的提取器 $\mathcal{E}$，使得对于任何 $x$ 和 $\mathsf{P}^{*}$，以下以压倒性概率（超过 $\sigma\gets\mathsf{S}$ 的选择）成立：如果 $(A,e,z)$, $(A,e^{\prime},z^{\prime})\gets\mathsf{P}^{*}(x,w,\sigma)$ 使得 $V_{2}(x,A,e,z)=V_{2}(x,A,e^{\prime},z^{\prime})=1$ 且 $e\neq e^{\prime}$，那么对于 $w^{\prime}\gets\mathcal{E}(x,A,e,e^{\prime},z,z^{\prime})$ 成立 $(x,w^{\prime})\in R$。

我们注意到 Schnorr 知识证明（参见附录 B.1）是一个具有特殊可靠性的 $\Sigma$-协议，它不接受任何设置参数，我们表示该协议为 $\Pi^{\mathsf{sch}}$（注意 $\sigma$ 被省略）。相比之下，我们对于 $R_{\mathsf{enc}}$、$R_{\mathsf{log}}$、$R_{\mathsf{aff-g}}$ 和 $R_{\mathsf{aff-p}}$ 的协议（即范围证明）需要一个设置参数，形式为 RSA 模数 $N$ 和 Ring-Pedersen 参数 $s,t\in\mathbb{Z}_{N}^{*}$（分别参见第 4.1 和 4.2 节以及附录 B.2 和 B.3），我们分别表示相应的协议为 $\Pi^{\mathsf{enc}}_{\sigma}$、$\Pi^{\mathsf{log}}_{\sigma}$、$\Pi^{\mathsf{aff-g}}_{\sigma}$ 和 $\Pi^{\mathsf{aff-p}}_{\sigma}$。然而，我们的门限签名协议不假设任何可信设置，实际上设置参数是由参与方自己生成的（每个参与方一个不同的）。我们接下来详细说明这一点。

**为范围证明生成设置参数**。展望我们门限签名协议的安全性分析，我们强调，尽管上述定义规定了可信设置 $\sigma=(N,s,t)$，但实际上设置参数是由验证者（证明的预期接收者）生成的，并附带一个 ZK 证明，证明 $N$ 是良构的（使用 $\Pi^{\mathsf{mod}}$ 和下面的编译器）并且 $s$, $t\in\mathbb{Z}_{N}^{*}$ 是合适的（使用 $\Pi^{\mathsf{prm}}$ 和下面的编译器）。特别是，证明者生成不同的证明（对每个验证者使用其个人的 $\sigma$）来向多个验证方证明相同的陈述 $x$。

**符号 2.7**。在后续中，我们将设置参数 $\sigma$ 纳入协议描述中，并且我们写 $\Pi^{*}_{j}$ 表示使用 $\mathcal{P}_{j}$ 的设置参数（作为验证者）的相应协议，对于 $*\in\{\mathsf{enc},\mathsf{log},\mathsf{aff-g},\mathsf{aff-p}\}$，并且我们省略提及“可信”算法 $\mathsf{S}$。

#### 2.3.1 ZK 模块

接下来，我们介绍如何使用随机预言机通过 Fiat-Shamir 启发式编译上述协议。即，为了生成证明，证明者通过查询预言机在合适的输入上来计算挑战 $e$，该输入包含定理和第一条消息。然后，证明者通过计算关于 $e$ 的最后一条消息来完成转录本，并将整个转录本作为证明进行通信。之后，验证者接受证明，如果它是底层 $\Sigma$-协议的有效转录本并且 $e$ 是良构的（通过像证明者应该做的那样查询预言机来验证）。

形式上，我们通过图 2 中的 ZK 模块定义编译器。注意，除了标准的证明/验证操作之外，ZK 模块包含一个提交操作，用于生成 ZK 证明的第一条消息 $A\gets\mathsf{P}_{1}$。

**图 2**：用于 $\Sigma$-协议的 ZK 模块 $\mathcal{M}$

这将有助于后面的签名协议，特别是需要提取的安全性分析，因为我们强制对手承诺（未来）证明的第一条消息。完备性、零知识性、可靠性和特殊可靠性的属性对于生成的证明系统类似地定义。

**符号 2.8**。有时我们在元组 $(\texttt{prove},\Pi,\texttt{aux},x;w,\tau)$ 中省略写随机性 $\tau$，表示采样新的随机性。

## 3 协议

我们的 ECDSA 协议包括四个阶段；一个用于生成（共享）密钥的阶段，运行一次（图 5），一个用于刷新秘密密钥份额并生成签名所需的辅助信息（即 Paillier 密钥和 Ring-Pedersen 参数 - 图 6）的阶段，一个用于在消息未知之前预处理签名（图 7），最后一个是用于在消息已知后计算签名份额（图 8）的阶段。

我们为我们的协议提供了两种变体；一种用于在线签名（图 3），一种用于非交互式签名（图 4）。这两个协议仅在上述组件如何组合方面有所不同。即，对于在线变体，指示参与方在每次为所有参与方已知的某个新消息请求新签名时（顺序地）运行预签名和签名阶段。对于离线变体，预签名阶段提前运行，在消息未知之前。最后，对于两个协议，密钥生成在激活时执行，而辅助信息和密钥刷新阶段根据密钥刷新计划执行。

**备注 3.1**。我们的协议由一个哈希函数 $\mathcal{H}$ 参数化，该函数被调用来获得不同长度域（例如具有 $q$ 个元素的有限域或 $\ell$ 大小的位流）中的哈希值。形式上，这通过引入多个不同长度的哈希函数来捕捉。然而，为了简化符号，我们简单地为每个（单独的）哈希函数写 $\mathcal{H}$。

### 3.1 密钥生成

接下来，我们描述密钥生成阶段。其核心是，密钥生成包括每个参与方 $\mathcal{P}_{i}\in\bm{P}$ 采样 $x_{i}\gets\mathbb{F}_{q}$ 并将公钥份额 $X_{i}=g^{x_{i}}$ 发送给所有其他参与方，同时附带一个关于指数的 Schnorr 知识证明。然后公钥设置为 $X=\prod_{j}X_{j}$。对于恶意安全性，我们指示参与方承诺（使用预言机）他们的公钥份额 $X_{i}$**以及** Schnorr 证明的第一条消息 $A_{i}$。因此，对手无法通过选择 $X$ 作为诚实参与方公钥份额的函数来影响私钥的分布，并且对手承诺了 Schnorr 证明的第一条消息（即 $A_{i}$），这将在后面的归约中用于提取见证。

**图 3**（门限 ECDSA：在线签名）

*   **密钥生成**：在从 $\mathcal{P}_{i}$ 接收到输入 (keygen, $ssid,i$) 时激活：
    1.  运行图 5 中的密钥生成阶段并获得 ($srid,\bm{X},x_{i}$)。
    2.  在输入 (aux-info, $ssid,srid,\bm{X},i$) 上运行图 6 中的辅助信息阶段，并执行：
        *   当获得输出 ($\bm{X},\bm{N},\bm{s},\bm{t}$) 和 ($x_{i},p_{i},q_{i}$) 时，设置 $sid=(ssid,srid,\bm{X},\bm{N},\bm{s},\bm{t})$ 并待命。

*   **签名**：在从 $\mathcal{P}_{i}$ 接收到输入 (sign, $sid,\ell,i,\text{msg}$) 时，执行：
    1.  在输入 (pre-sign, $sid,0,i$) 上运行图 7 中的预签名阶段。
    2.  设置 $m=\mathcal{H}(\text{msg})$ 并在输入 (sign, $sid,0,i,m$) 上运行图 8 中的签名阶段。
        *   当获得输出时待命。

*   **密钥刷新**：在从 $\mathcal{P}_{i}$ 接收到输入 (key-refresh, $ssid,srid,\bm{X},i$) 时，
    1.  在输入 (aux-info, $ssid,srid,\bm{X},i$) 上运行图 6 中的辅助信息阶段。
    2.  在获得输出 ($\bm{X},\bm{N},\bm{s},\bm{t}$) 和 ($x_{i},p_{i},q_{i}$) 时，执行：
        *   擦除所有形式为 ($ssid,\ldots$) 的预签名和辅助信息。
        *   重置 $sid=(ssid,srid,\bm{X},\bm{N},\bm{s},\bm{t})$ 并待命。

**图 4**（门限 ECDSA：非交互式签名）

*   **密钥生成**：与图 3 相同。

*   **预签名**：在从 $\mathcal{P}_{i}$ 接收到输入 (pre-sign, $sid,L,i$) 时，执行：
    1.  擦除所有预签名数据 ($ssid,\ldots$)。
    2.  在输入 (pre-sign, $sid,1,i$), ..., (pre-sign, $sid,L,i$) 上并发运行图 7 中的预签名阶段。
        *   当获得输出时待命。

*   **签名**：在从 $\mathcal{P}_{i}$ 接收到输入 (sign, $sid,\ell,i,\text{msg}$) 时，执行：设置 $m=\mathcal{H}(\text{msg})$ 并在输入 (sign, $sid,\ell,i,m$) 上运行图 8 中的签名阶段。
    *   当获得输出时待命。

*   **密钥刷新**：与图 3 相同。

在获得所有相关值后，如果没有检测到不一致，设置 $X=\prod_{j}X_{j}$ 并存储秘密密钥份额 $x_{i}$ 以及公钥份额 $\bm{X}=(X_{1},\ldots,X_{n})$。完整细节见图 5。

**备注 3.2**。我们观察到协议指示参与方（可验证地）广播他们的一些消息（与“发送给所有人”的消息相对，后者不需要相等性验证）。对于非一致停止 [36]，这可以在点对点网络中使用回声广播和一轮额外的通信来实现。

### 3.2 密钥刷新与辅助信息

在很高层面上，辅助信息和密钥刷新阶段进行如下。每个参与方 $\mathcal{P}_{i}$ 采样一个 Paillier 模数 $N_{i}$，作为安全素数的乘积获得，以及 Ring-Pedersen 参数 $(s_{i},t_{i})$。然后，$\mathcal{P}_{i}$ 采样 $0\in\mathbb{F}_{q}$ 的秘密共享 $(x^{1}_{i},\ldots,x^{n}_{i})$，计算 $\bm{Y}_{i}=(X^{1}_{i}=g^{x^{1}_{i}},\ldots,X^{n}_{i}=g^{x^{n}_{i}})$，并向所有人广播 $\bm{Y}_{i},N_{i},s_{i},t_{i}$。在收到所有相关值后，参与方 $\mathcal{P}_{i}$ 在 $\mathcal{P}_{k}$ 的 Paillier 公钥 $N_{k}$ 下加密每个 $x^{k}_{i}$（**包括**他自己的）并获得密文 $C^{k}_{i}$，对于所有 $k$，他将这些密文发送给所有参与方（原因在下面解释）。然后，每个 $\mathcal{P}_{i}$ 刷新到一个新的私钥份额 $x^{*}_{i}=x_{i}+\sum_{\ell}x^{i}_{\ell}\mod q$，更新所有参与方的公钥份额 $X^{*}_{j}=X_{j}\cdot\prod_{\ell}X^{j}_{\ell}$，并存储新的 $(N_{1},s_{1},t_{1}),\ldots,(N_{n},s_{n},t_{n})$。对于恶意安全性，上述过程通过以下 ZKP 增强：

(a) $N_{i}$ 是一个 Paillier-Blum 模数并且它不允许小因子。
(b) $N_{i}$ 可以分解为两个不大于 $\sqrt{N}\cdot 2^{\ell+\varepsilon}$ 的因子。

**图 5**：ECDSA 密钥生成

(c) ZK 证明 $s_{i}$ 属于 $\mathbb{Z}_{N_{i}}^{*}$ 中由 $t_{i}$ 生成的乘法群。
(d) $C^{k}_{i}$ 的明文值模 $q$ 等于 $X^{k}_{i}$ 的离散对数。

展望安全性分析，我们指出我们的模拟器在项目 (a) 中提取恶意参与方的 Paillier 密钥，因此我们可以毫无问题地从密文 $\{C^{k}_{i}\}_{i,k}$ 中提取所有秘密值。上述步骤被交织以获得图 6 中的两轮协议。

**备注 3.3**。对于更高效的密钥刷新（这会产生额外的一轮通信），我们请读者参阅 Canetti 等人 [19] 的协议。

### 3.3 预签名

我们给出预签名阶段（图 7）的高层概述。回忆在辅助信息阶段结束时，每个参与方 $\mathcal{P}_{i}$ 有一个 Paillier 加密方案 $(\mathsf{enc}_{i},\mathsf{dec}_{i})$，公钥为 $N_{i}$，以及 Ring-Pedersen 参数 $s_{i},t_{i}\in\mathbb{Z}_{N_{i}}$。进一步回忆 ECDSA 签名具有形式 $(r=g^{k^{-1}}|_{x\text{-axis}},\sigma=k(m+rx))$，其中 $\mathcal{P}_{i}$ 有 $x$ 的加法份额 $x_{i}$。

为了比较，我们还回忆 G&G 协议 [31] 的要点。参与方（共同）计算一个随机点 $g^{k^{-1}}$ 以及 $k$ 和 $k\cdot x$ 的本地加法份额 $k_{i},\chi_{i}$。进一步回忆 $g^{k^{-1}}$ 是从 $(g^{\gamma})^{\delta^{-1}}$ 获得的，对于某个共同计算的随机值 $\delta=k\gamma$，其中 $\gamma$ 是 $k$ 的（隐藏的）共同生成的掩码。更详细地说，协议进行如下：

1.  每个参与方 $\mathcal{P}_{i}$ 生成本地份额 $k_{i}$ 和 $\gamma_{i}$，计算 Paillier 加密 $K_{i}=\mathsf{enc}_{i}(k_{i})$ 和 $G_{i}=\mathsf{enc}_{i}(\gamma_{i})$，在 $\mathcal{P}_{i}$ 的密钥下，并广播 $(K_{i},G_{i})$。
2.  对于每个 $j\neq i$，参与方 $\mathcal{P}_{i}$ 采样 $\beta_{i,j},\hat{\beta}_{i,j}\gets\mathcal{J}_{\varepsilon}$ 并使用 Paillier 的同态属性计算 $D_{j,i}=\mathsf{enc}_{j}(\gamma_{i}\cdot k_{j}-\beta_{i,j})$ 和 $\hat{D}_{j,i}=\mathsf{enc}_{j}(x_{i}\cdot k_{j}-\hat{\beta}_{i,j})$。此外，$\mathcal{P}_{i}$ 加密 $F_{j,i}=\mathsf{enc}_{i}(\beta_{i,j})$, $\hat{F}_{j,i}=\mathsf{enc}_{i}(\hat{\beta}_{i,j})$，设置 $\Gamma_{i}=g^{\gamma_{i}}$，并将 $(D_{j,i},\hat{D}_{j,i},F_{j,i},\hat{F}_{j,i})$ 发送给所有参与方。
3.  每个 $\mathcal{P}_{i}$ 解密（并模 $q$ 约简）$\alpha_{i,j}=\mathsf{dec}_{i}(D_{i,j})$ 和 $\hat{\alpha}_{i,j}=\mathsf{dec}_{i}(\hat{D}_{i,j})$。并计算 $\delta_{i}=\gamma_{i}\cdot k_{i}+\sum_{j\neq i}\alpha_{i,j}+\beta_{i,j}\mod q$, $\chi_{i}=x_{i}\cdot k_{i}+\sum_{j\neq i}\hat{\alpha}_{i,j}+\hat{\beta}_{i,j}\mod q$。最后，$\mathcal{P}_{i}$ 设置 $\Gamma=\prod_{j}\Gamma_{j}$, $\Delta_{i}=\Gamma^{k_{i}}$ 并将 $\delta_{i},\Delta_{i}$ 发送给所有参与方。

当获得所有 $\delta_{j}$ 时，参与方 $\mathcal{P}_{i}$ 设置 $\delta=\sum_{j}\delta_{j}\mod q$ 并验证 $g^{\delta}=\prod_{j}\Delta_{j}$。如果没有检测到不一致，$\mathcal{P}_{i}$ 设置 $R=\Gamma^{\delta^{-1}}$ 并存储 $(R,k_{i},\chi_{i})$。对于恶意安全性，上述过程通过以下 ZK 证明增强：

(a) $K_{i}$ 的明文位于范围 $\mathcal{I}_{\varepsilon}$ 内。
(b) 密文 $D_{j,i}$ 是通过对 $K_{j}$ 进行仿射类操作获得的，其中乘法系数等于 $G_{i}$ 的隐藏值，并且它位于范围 $\mathcal{I}_{\varepsilon}$ 内，并且加法系数等于 $F_{j,i}$ 的隐藏值，并位于范围 $\mathcal{J}_{\varepsilon}$ 内。
(c) 密文 $\hat{D}_{j,i}$ 是通过对 $K_{j}$ 进行仿射操作获得的，其中乘法系数等于 $X_{i}$ 的指数，并且它位于范围 $\mathcal{I}_{\varepsilon}$ 内，并且加法系数等于 $\hat{F}_{j,i}$ 的隐藏值，并且它位于范围 $\mathcal{J}_{\varepsilon}$ 内。
(d) $\Gamma_{i}$ 的指数等于 $G_{i}$ 的明文值。

展望安全性分析，为了模拟协议，足以提取对手的 $k$、$\gamma$ 和 $\beta$。由于上述值在恶意参与方的 Paillier 密钥下加密，并且 Paillier 密钥在先前阶段被提取，我们可以毫无问题地提取所需值。

**准备多个签名**。要准备 $L$ 个签名，参与方并发地遵循上述步骤 $L$ 次。在预签名阶段结束时，每个 $\mathcal{P}_{i}$ 存储元组 $\{(\ell,R_{\ell},k_{i,\ell},\chi_{i,\ell})\}_{\ell\in[L]}$，并进入待命状态。

**图 6**（辅助信息与密钥刷新）

**第 1 轮**。

在从 $\mathcal{P}_{i}$ 接收到输入 $(\texttt{aux-info},std,i)$ 时，执行：

*   采样两个 $4\kappa$ 位长的安全素数 $(p_{i},q_{i})$。设置 $N_{i}=p_{i}q_{i}$。
*   采样 $x^{1}_{i},\ldots,x^{n}_{i}\gets\mathbb{F}_{q}$ 满足 $\sum_{j}x^{j}_{i}=0$。设置 $X^{j}_{i}=g^{x^{j}_{i}}$, $\boldsymbol{Y}_{i}=(X^{j}_{i})_{j}$, $\boldsymbol{x}_{i}=(x^{j}_{i})_{j}$。
*   采样 $r\gets\mathbb{Z}_{N_{i}}^{\times},\lambda\gets\mathbb{Z}_{\psi(N_{i})}$，设置 $t_{i}=r^{2}\mod N_{i}$ 和 $s_{i}=t_{i}^{\lambda}\mod N_{i}$。
*   采样 $u_{i}\gets\{0,1\}^{\kappa}$ 并计算 $V_{i}=\mathcal{H}(std,i,\boldsymbol{Y}_{i},u_{i})$。
*   计算 $\psi_{i}=\mathcal{M}(\texttt{prove},\Pi^{\textsf{mod }},(std,i),N_{i};(p_{i},q_{i}))$
*   计算 $\psi^{\prime}_{i}=\mathcal{M}(\texttt{prove},\Pi^{\textsf{mod }},(std,i,\psi_{i}),N_{i};(p_{i},q_{i}))$。
*   计算 $\psi^{\prime\prime}_{i}=\mathcal{M}(\texttt{prove},\Pi^{\textsf{prm }},(std,i),(N_{i},s_{i},t_{i});\lambda)$。

广播 $(std,i,V_{i},N_{i},s_{i},t_{i},\psi_{i},\psi^{\prime}_{i},\psi^{\prime\prime}_{i})$。

**第 2 轮**。

1.  在从 $\mathcal{P}_{j}$ 接收到 $(std,j,V_{j},N_{j},s_{j},t_{j},\psi_{j},\psi^{\prime}_{j},\psi^{\prime\prime}_{j})$ 时，执行：
    *   验证 $N_{j}\geq 2^{8\kappa}$。
    *   验证 $\mathcal{M}(\texttt{vrfy},\Pi^{\textsf{mod }},(std,j),N_{j},\psi_{j})=1$。
    *   验证 $\mathcal{M}(\texttt{vrfy},\Pi^{\textsf{mod }},(std,j,\psi_{j}),N_{j},\psi^{\prime}_{j})=1$。
    *   验证 $\mathcal{M}(\texttt{vrfy},\Pi^{\textsf{prm }},(std,j),(N_{j},s_{j},t_{j}),\psi^{\prime\prime}_{j})=1$。

2.  当对所有 $\mathcal{P}_{j}$ 通过上述验证时，对每个 $\mathcal{P}_{k}$ 执行：
    *   采样 $\rho_{k}\gets\mathbb{Z}_{N_{k}}^{\times}$，并设置 $C^{k}_{i}=\mathsf{enc}_{k}(x^{k}_{i};\rho_{k})$。
    *   对每个 $\mathcal{P}_{j}$ 计算 $\psi_{j,i,k}=\mathcal{M}(\texttt{prove},\Pi^{\mathsf{log}}_{j},(std,i),(\mathcal{I}_{\varepsilon},C^{k}_{i},X^{k}_{i},g);(x^{k}_{i},\rho_{k}))$。
    *   对每个 $\mathcal{P}_{j}$ 计算 $\pi_{j,i}=\mathcal{M}(\texttt{prove},\Pi^{\mathsf{fac}}_{j},(std,i),(\ell,N_{i});(p_{i},q_{i}))$。
        将 $(std,i,\boldsymbol{Y}_{i},u_{i},\pi_{j,i},(\psi_{j,i,k},C^{k}_{i})_{k})$ 发送给每个 $\mathcal{P}_{j}$。

**输出**。

1.  在从 $\mathcal{P}_{j}$ 接收到 $(std,j,\boldsymbol{Y}_{j},u_{j},\pi_{i,j},(\psi_{i,j,k},C^{k}_{j})_{k})$ 时，执行：
    *   验证 $\prod_{k}X^{k}_{j}=\mathsf{id}_{\mathbb{G}}$。
    *   验证 $\mathcal{H}(std,j,\boldsymbol{Y}_{j},u_{j})=V_{j}$ 且 $\mathcal{M}(\texttt{vrfy},\Pi^{\mathsf{fac}}_{j},(std,i),(\ell,N_{i}),\pi_{i,j})=1$。
    *   对每个 $k$ 验证 $\mathcal{M}(\texttt{vrfy},\Pi^{\mathsf{log}}_{i},(std,j),(\mathcal{I}_{\varepsilon},C^{k}_{j},X^{k}_{j},g),\psi_{i,j,k})=1$。

2.  当对所有 $\mathcal{P}_{j}$ 通过上述验证时，执行：
    *   设置 $x^{*}_{i}=x_{i}+\sum_{j}\mathsf{dec}_{i}(C^{i}_{j})\mod q$。
    *   对每个 $k$ 设置 $X^{*}_{k}=X_{k}\cdot\prod_{j}X^{k}_{j}$。
        输出 $(std,i,\boldsymbol{X}^{*}=(X^{*}_{k})_{k},\boldsymbol{N}=(N_{j})_{j},\boldsymbol{s}=(s_{j})_{j},\boldsymbol{t}=(t_{j})_{j})$。

**错误**。当任何验证步骤失败或从任何其他 $\mathcal{P}_{j}\in\boldsymbol{P}$ 收到投诉时，报告投诉并停止。

**存储状态**。存储 $x^{*}_{i},p_{i},q_{i}$。

**图 6**：辅助信息与密钥刷新

回忆 $P_{i}$ 的秘密状态包含 $x_{i},p_{i},q_{i}$ 使得 $X_{i}=g^{x_{i}}$ 且 $N_{i}=p_{i}q_{i}$。

**第 1 轮**。

在从 $\mathcal{P}_{i}$ 接收到输入 $(\texttt{pre-sign},std,\ell,i)$ 时，解释 $std=(\ldots,\mathbb{G},q,g,\boldsymbol{P},srid,\boldsymbol{X},\boldsymbol{N},\boldsymbol{s},\boldsymbol{t})$，并执行：

*   采样 $k_{i}$, $\gamma_{i}\gets\mathbb{F}_{q}$, $\rho_{i},\nu_{i}\gets\mathbb{Z}_{N_{i}}^{*}$ 并设置 $G_{i}=\mathsf{enc}_{i}(\gamma_{i};\nu_{i})$, $K_{i}=\mathsf{enc}_{i}(k_{i};\rho_{i})$。
*   对每个 $j\neq i$ 计算 $\psi_{j,i}^{0}=\mathcal{M}(\texttt{prove},\Pi_{j}^{\mathsf{enc}},(std,i),(\mathcal{I}_{\varepsilon},K_{i});(k_{i},\rho_{i}))$。

广播 $(std,i,K_{i},G_{i})$ 并将 $(std,i,\psi_{j,i}^{0})$ 发送给每个 $\mathcal{P}_{j}$。

**第 2 轮**。

1.  在从 $\mathcal{P}_{j}$ 接收到 $(std,j,K_{j},G_{j},\psi_{i,j}^{0})$ 时，执行：
    *   验证 $\mathcal{M}(\texttt{vrfy},\Pi_{i}^{\mathsf{enc}},(std,j),(\mathcal{I}_{\varepsilon},K_{j}),\psi_{i,j})=1$。

2.  当对所有 $\mathcal{P}_{j}$ 通过上述验证时，设置 $\Gamma_{i}=g^{\gamma_{i}}$ 并执行：对于每个 $j\neq i$，采样 $r_{i,j},s_{i,j},\hat{r}_{i,j},\hat{s}_{i,j}\gets\mathbb{Z}_{N_{j}}$, $\beta_{i,j},\hat{\beta}_{i,j}\gets\mathcal{J}$ 并计算：
    *   $D_{j,i}=(\gamma_{i}\odot K_{j})\oplus\mathsf{enc}_{j}(-\beta_{i,j},s_{i,j})$ 和 $F_{j,i}=\mathsf{enc}_{i}(\beta_{i,j},r_{i,j})$。
    *   $\hat{D}_{j,i}=(x_{i}\odot K_{j})\oplus\mathsf{enc}_{j}(-\hat{\beta}_{i,j},\hat{s}_{i,j})$ 和 $\hat{F}_{j,i}=\mathsf{enc}_{i}(\hat{\beta}_{i,j},\hat{r}_{i,j})$。
    *   $\psi_{j,i}=\mathcal{M}(\texttt{prove},\Pi_{j}^{\mathsf{aff-p}},(std,i),(\mathcal{I}_{\varepsilon},\mathcal{J}_{\varepsilon},D_{j,i},K_{j},F_{j,i},G_{i});(\gamma_{i},\beta_{i,j},s_{i,j},r_{i,j},\nu_{i}))$。
    *   $\hat{\psi}_{j,i}=\mathcal{M}(\texttt{prove},\Pi_{j}^{\mathsf{aff-g}},(std,i),(\mathcal{I}_{\varepsilon},\mathcal{J}_{\varepsilon},\hat{D}_{j,i},K_{j},\hat{F}_{j,i},X_{i});(x_{i},\hat{\beta}_{i,j},\hat{s}_{i,j},\hat{r}_{i,j}))$。
    *   $\psi_{j,i}^{\prime}=\mathcal{M}(\texttt{prove},\Pi_{j}^{\mathsf{log}},(std,i),(\mathcal{I}_{\varepsilon},G_{i},\Gamma_{i},g);(\gamma_{i},\nu_{i}))$。
        将 $(std,i,\Gamma_{i},D_{j,i},F_{j,i},\hat{D}_{j,i},\hat{F}_{j,i},\psi_{j,i},\hat{\psi}_{j,i},\psi_{j,i}^{\prime})$ 发送给每个 $\mathcal{P}_{j}$。

**第 3 轮**。

1.  在从 $\mathcal{P}_{j}$ 接收到 $(std,j,\Gamma_{j},D_{i,j},F_{i,j},\hat{D}_{i,j},\hat{F}_{i,j},\psi_{i,j},\hat{\psi}_{i,j},\psi_{i,j}^{\prime})$ 时，执行
    *   验证 $\mathcal{M}(\texttt{vrfy},\Pi_{i}^{\mathsf{aff-p}},(std,j),(\mathcal{I}_{\varepsilon},\mathcal{J}_{\varepsilon},D_{i,j},K_{i},F_{j,i},G_{j}),\psi_{i,j})=1$。
    *   验证 $\mathcal{M}(\texttt{vrfy},\Pi_{i}^{\mathsf{aff-g}},(std,j),(\mathcal{I}_{\varepsilon},\mathcal{J}_{\varepsilon},\hat{D}_{k,j},K_{i},\hat{F}_{j,i},X_{j}),\hat{\psi}_{i,j})=1$。
    *   验证 $\mathcal{M}(\texttt{vrfy},\Pi_{i}^{\mathsf{log}},(std,j),(\mathcal{I}_{\varepsilon},G_{j},\Gamma_{j},g),\psi_{i,j}^{\prime})=1$。

2.  当对所有 $\mathcal{P}_{j}$ 通过上述验证时，设置 $\Gamma=\prod_{j}\Gamma_{j}$ 和 $\Delta_{i}=\Gamma^{k_{i}}$，并执行：
    *   对于每个 $j\neq i$，设置 $\alpha_{i,j}=\mathsf{dec}_{i}(D_{i,j})$ 和 $\tilde{\alpha}_{i,j}=\mathsf{dec}_{i}(\hat{D}_{i,j})$ 并且
        $$\begin{cases}\delta_{i}=\gamma_{i}k_{i}+\sum_{j\neq i}(\alpha_{i,j}+\beta_{i,j})\mod q\\ \chi_{i}=x_{i}k_{i}+\sum_{j\neq i}(\tilde{\alpha}_{i,j}+\hat{\beta}_{i,j})\mod q\end{cases}.$$
    *   对于每个 $j\neq i$，计算 $\psi_{j,i}^{\prime\prime}=\mathcal{M}(\texttt{prove},\Pi_{j}^{\mathsf{log}},(std,i),(\mathcal{I}_{\varepsilon},K_{i},\Delta_{i},\Gamma);(k_{i},\rho_{i}))$。
        将 $(std,i,\delta_{i},\Delta_{i},\psi_{j,i}^{\prime\prime})$ 发送给每个 $\mathcal{P}_{j}$。擦除内存中除存储状态外的所有项目。

**输出**。

1.  在从 $\mathcal{P}_{j}$ 接收到 $(std,j,\delta_{j},\Delta_{j},\psi_{i,j}^{\prime\prime})$ 时，执行：
    *   验证 $\mathcal{M}(\texttt{vrfy},\Pi_{i}^{\mathsf{log}},(std,j),(\mathcal{I}_{\varepsilon},K_{j},\Delta_{j},\Gamma),\psi_{i,j}^{\prime\prime})=1$。

2.  当对所有 $\mathcal{P}_{j}$ 通过上述验证时，设置 $\delta=\sum_{j}\delta_{j}$，并执行：
    *   验证 $g^{\delta}=\prod_{j}\Delta_{j}$。
    *   设置 $R=\Gamma^{\delta^{-1}}$ 并输出 $(std,i,R,k_{i},\chi_{i})$。
        擦除除存储状态外的所有项目。

**错误**。当任何验证步骤失败或从任何其他 $\mathcal{P}_{j}\in\boldsymbol{P}$ 收到投诉时，报告投诉并停止。

**存储状态**。存储 $\boldsymbol{X}$, $\boldsymbol{N}$, $\boldsymbol{s}$, $\boldsymbol{t}$ 和 $(x_{i},p_{i},q_{i})$。

**图 7**：ECDSA 预签名


**注意**。回忆公钥份额 $\{X_{i}=g^{x_{i}}\}_{i\in[n]}$ 对所有参与方已知，并让 $\mathcal{I}=\pm 2^{\ell}$, $\mathcal{J}=\pm 2^{\ell^{\prime}}$, $\mathcal{I}_{\varepsilon}=\pm 2^{\ell+\varepsilon}$ 和 $\mathcal{J}_{\varepsilon}=\pm 2^{\ell^{\prime}+\varepsilon}$ 表示整数区间，其中 $\ell$, $\ell^{\prime}$ 和 $\varepsilon$ 是固定参数（由分析确定）。我们表示模 $N$ 的整数在区间 $\{-N/2,\ldots,N/2\}$ 中（而不是规范表示）；这个约定对安全性分析至关重要。

### 3.4 签名

一旦（消息的哈希）$m$ 已知，在输入 $(\mathtt{sign},\ell,i,m)$ 对于曲线上第 $\ell$ 个揭示的点时，签名归结为检索相关数据并计算正确的签名份额。即，检索 $(\ell,R,k,\chi)$ 计算 $r=R|_{x\text{-axis}}$ 并将 $\sigma_{i}=km+r\chi\mod q$ 发送给所有人。擦除元组 $(\ell,R,k,\chi)$。完整细节见图 8。

## 4 底层 $\Sigma$-协议

我们呈现与第 2.2 节的 NP 关系相关的 $\Sigma$-协议。Schnorr ZK-PoK 以及两个与下面非常相似的协议被移到附录 B。

### 4.1 Paillier 加密范围 ZK ($\Pi^{\text{enc}}$)

在图 9 中，我们给出了一个 $\Sigma$-协议，用于形式为 $(\mathcal{I}=\pm 2^{\ell},C;k,r_{0})$ 的元组，满足关系 $R_{\text{enc}}$。即，证明者声称他知道 $k\in \pm 2^{\ell}$ 使得 $C=(1+N_{0})^{k}\cdot r_{0}^{N_{0}}\mod N_{0}^{2}$。让 $(\hat{N},s,t)$ 是证明的辅助设置参数，即 $\hat{N}$ 是一个合适的（安全双素数）Blum 模数，$s$ 和 $t$ 是 $\mathbb{Z}^{*}_{\hat{N}}$ 中的随机平方（这意味着 $s\in \langle t\rangle$ 以压倒性概率）。

**完备性**。协议可能拒绝一个有效陈述仅当 $|\alpha|\geq 2^{\ell+\varepsilon}-q2^{\ell}$，这以最多 $q/2^{\varepsilon}$ 的概率发生。 $\square$

**诚实验证者零知识**。模拟器采样 $z_{1}\gets \pm 2^{\ell+\varepsilon}$, $z_{2}\gets\mathbb{Z}^{*}_{N_{0}}$, $z_{3}\gets \pm \hat{N}\cdot 2^{\ell+\varepsilon}$，和 $S\gets \langle t\rangle$ 通过 $S=t^{\lambda}\mod \hat{N}$ 其中 $\lambda\gets \pm 2^{\ell}\cdot \hat{N}$，并设置 $A=(1+N_{0})^{z_{1}}w^{N_{0}}\cdot K^{-\varepsilon}\mod N_{0}^{2}$ 和 $C=s^{z_{1}}t^{z_{3}}\cdot S^{-\varepsilon}\mod \hat{N}$。我们观察到真实分布和模拟分布是 $2\cdot q2^{-\varepsilon}+2^{-\ell}\approx 3q2^{-\varepsilon}$ 统计接近的（通过选择 $\ell=\varepsilon$ 正如我们在分析中所做的那样）。这遵循事实 D.6, D.7，这意味着 $z_{1},z_{3}$（每个）与真实分布接近 $q2^{-\varepsilon}$，并且 $S$ 与真实分布接近 $2^{-\ell}$。

**图 8**：ECDSA 签名

*   **设置**：辅助 RSA 模数 $\hat{N}$ 和 Ring-Pedersen 参数 $s,t\in\mathbb{Z}_{N}^{*}$。
*   **输入**：公共输入是 $(N_{0},K)$。证明者有秘密输入 $(k,\rho)$ 使得 $k\in \pm 2^{\ell}$，且 $K=(1+N_{0})^{k}\cdot \rho^{N_{0}}\mod N_{0}^{2}$。

1.  证明者采样
    $$\alpha\gets \pm 2^{\ell+\varepsilon}\text{ 和 }\begin{cases}\mu\gets \pm 2^{\ell}\cdot \hat{N}\\ r\gets\mathbb{Z}_{N_{0}}^{*}\\ \gamma\gets \pm 2^{\ell+\varepsilon}\cdot \hat{N}\end{cases} \text{，并计算 }\begin{cases}S=s^{k}t^{\mu}\mod \hat{N}\\ A=(1+N_{0})^{\alpha}\cdot r^{N_{0}}\mod N_{0}^{2}\\ C=s^{\alpha}t^{\gamma}\mod \hat{N}\end{cases} \text{，}$$
    并将 $(S,A,C)$ 发送给验证者。
2.  验证者回复 $e\gets \pm q$
3.  证明者将 $(z_{1},z_{2},z_{3})$ 发送给验证者，其中
    $$\begin{cases}z_{1}&=\alpha+ek\\ z_{2}&=r\cdot \rho^{e}\mod N_{0}\\ z_{3}&=\gamma+e\mu\end{cases}.$$

*   **等式检查**：
    $$\begin{cases}(1+N_{0})^{z_{1}}\cdot z_{2}^{N_{0}}=A\cdot K^{e}\mod N_{0}^{2}\\ s^{z_{1}}t^{z_{3}}=C\cdot S^{e}\mod \hat{N}\end{cases}$$

*   **范围检查**：
    $$z_{1}\in \pm 2^{\ell+\varepsilon}$$
    证明保证 $k\in \pm 2^{\ell+\varepsilon}$。

**图 9**：Paillier 加密范围 ZK – $\Pi^{\mathsf{enc}}$

_可靠性_。可靠性属性遵循特殊可靠性（见下文）以及集合 $\{(e,e^{\prime}\in(\pm q)^{2}) \ \text{s.t.} \ e-e^{\prime} \text{ 整除 } N_{0}\}$ 与 $(\pm q)^{2}$ 相比可忽略地小（因为 $N_{0}$ 的除数大于 $2^{\ell}\approx q$）。 $\square$

_特殊可靠性_。让 $(S,A,C,e,z_{1},z_{2},z_{3})$ 和 $(S,A,C,e^{\prime},z_{1}^{\prime},z_{2}^{\prime},z_{3}^{\prime})$ 表示两个接受转录本，并让 $(\Delta_{e},\Delta_{z_{1}},\Delta_{z_{2}},\Delta_{z_{3}})$ 表示相关差异，并假设 $\Delta_{e}\neq 0$ 不整除 $N_{0}$。注意，如果 $\Delta_{e}$ 整除 $\Delta_{z_{1}}$ 和 $\Delta_{z_{3}}$（在整数中），那么所有值都可以如下提取而无问题：$k$ 和 $\mu$ 设置为 $\Delta_{z_{1}}/\Delta_{e}$ 和 $\Delta_{z_{3}}/\Delta_{e}$。最后，$\rho$ 可以从等式 $(z_{2}/z_{2}^{\prime})^{N_{0}}=((1+N_{0})^{-k}\cdot K)^{\Delta_{e}} \mod N_{0}^{2}$ 和事实 D.2 中提取。因此，足以证明以下主张。

**主张 4.1**（Fujisaki 和 Okamoto [30], MacKenzie 和 Reiter [46]）。_假设_ **sRSA**，_成立 $\Delta_{e} \mid \Delta_{z_{1}}$ 且 $\Delta_{e} \mid \Delta_{z_{3}}$ 的概率至少为 $1-\mathsf{negl}(\kappa)$。_

定义谓词 $\neg\text{extract}\equiv(\Delta_{e}\nmid\Delta_{z_{1}})\vee(\Delta_{e}\nmid\Delta_{z_{3}})$。我们证明如果 $\neg\text{extract}$ 以显著概率发生，那么存在一个算法 $\mathcal{S}$ 具有对证明者的黑盒访问权限，可以以显著概率破解 sRSA。更精确地说，我们展示如何如下破解 sRSA。强 RSA 挑战是第二个 Ring-Pedersen 参数 $t$。[^15] 我们假设 $\mathcal{S}$ 知道 $\lambda\in[\hat{N}^{2}]$ 使得 $s=t^{\lambda}\mod \hat{N}$，并且 $\lambda$ 在 $[\hat{N}^{2}]$ 中是均匀的。我们强调选择 $\hat{N}^{2}$ 而不是 $\hat{N}$ 对归约至关重要。

[^15]: 以 $1/4$ 的概率，$\mathbb{Z}_{\hat{N}}$ 中的均匀元素是一个随机二次剩余，因此计算 $t$ 的非平凡根会破坏 sRSA，因为 $t$ 是一个随机二次剩余。

**主张 4.2**。_如果 $\Delta_{e}\nmid (\lambda\Delta_{z_{1}}+\Delta_{z_{3}})$，那么_ **sRSA** _被破坏。_

主张 4.2 的证明。定义 $\delta=(\lambda\Delta_{z_{1}}+\Delta_{z_{3}},\Delta_{e})$ 并让 $\delta_{e}=\Delta_{e}/\delta$ 和 $\delta_{z}=(\lambda\Delta_{z_{1}}+\Delta_{z_{3}})/\delta$。注意 $(S^{\nu_{z}}t^{\nu_{e}})^{\delta_{e}}=t\mod \hat{N}$，其中 $(\nu_{e},\nu_{z})$ 是 $\delta_{z}$ 和 $\delta_{e}$ 的 Bezout 系数（即 $\nu_{e}\delta_{e}+\nu_{z}\delta_{z}=1$），因为 $S^{\delta_{e}}=t^{\delta_{z}}$。推导出对 $(S^{\nu_{z}}t^{\nu_{e}},\delta_{e})$ 是强 RSA 挑战的成功响应，如果 $\Delta_{e}\nmid (\lambda\Delta_{z_{1}}+\Delta_{z_{3}})$。 $\square$

总结，我们排除（限制概率）$\Delta_{e} \mid \lambda\Delta_{z_{1}}+\Delta_{z_{3}}$ 和 -extract；足以限制 $(\Delta_{e} \mid \lambda\Delta_{z_{1}}+\Delta_{z_{3}}) \wedge (\Delta_{e}\nmid\Delta_{z_{1}})$ 的概率。[^16] 写 $\lambda=\lambda_{0}+p_{0}q_{0}\lambda_{1}$，其中 $(p_{0},q_{0})=((p-1)/2,(q-1)/2)$。因为 $\Delta_{z}$ 不整除 $p_{0}q_{0}\Delta_{z_{1}}$（因为 $\langle\Delta_{e},p_{0}q_{0}\rangle=1$ 以压倒性概率）我们注意到，根据事实 D.4，存在一个素数幂 $a^{b}$ 使得 $a^{b} \mid p_{0}q_{0}\Delta_{z_{1}}$, $a^{b+1}\nmid\Delta_{z_{1}}$，且 $\Delta_{z}=(\lambda_{0}\Delta_{z_{1}}+\Delta_{z_{3}})+\lambda_{1}p_{0}q_{0}\Delta_{z_{1}}=0\mod a^{b+1}$ 因此 $\lambda_{1}$ 由 $a$ 模唯一确定。另一方面，以证明者的视图为条件，$\lambda_{1}$ 具有完全熵，因为 $t^{\lambda}=t^{\lambda_{0}}\mod \hat{N}$，因为 $t$ 是模 $\hat{N}$ 的二次剩余，这意味着，如果 $\Delta_{e}\nmid\Delta_{z_{1}}$，那么 $\Delta_{e} \mid \lambda\Delta_{z_{1}}+\Delta_{z_{3}}$ 的概率最多为 $\frac{1}{a}+\mathsf{negl}\leq \frac{1}{2}+\mathsf{negl}$ 超过证明者的硬币，其中可忽略项的形式为 $(p+q)\cdot \mathsf{polylog}(\hat{N})/\hat{N}$。总之，$\Delta_{e}\nmid\Delta_{z_{1}}$ 或 $\Delta_{e}\nmid\Delta_{z_{3}}$ 的概率最多是解决 RSA 挑战的概率除以 $(1/2-\mathsf{negl})$，整体是可忽略的。更详细地说，

[^16]: 因为 $\Delta_{e}\nmid\Delta_{z_{3}}$ 且 $\Delta_{e} \mid \lambda\Delta_{z_{1}}+\Delta_{z_{3}}$ 意味着 $\Delta_{e}\nmid\Delta_{z_{1}}$。

$$\begin{aligned}
\Pr[\neg\text{extract}] &=\Pr[\Delta_{e} \mid (\lambda\Delta_{z_{1}}+\Delta_{z_{3}})\wedge\neg\text{extract}]+\Pr[\Delta_{e}\nmid (\lambda\Delta_{z_{1}}+\Delta_{z_{3}})\wedge\neg\text{extract}]\\
&=\Pr[\Delta_{e} \mid (\lambda\Delta_{z_{1}}+\Delta_{z_{3}})\wedge \Delta_{e}\nmid\Delta_{z_{1}}]+\Pr[\mathsf{sRSA}]\\
&\leq(1/2+\mathsf{negl})\cdot\Pr[\Delta_{e}\nmid\Delta_{z_{1}}]+\Pr[\mathsf{sRSA}]\\
&\leq(1/2+\mathsf{negl})\cdot\Pr[\neg\text{extract}]+\Pr[\mathsf{sRSA}]
\end{aligned}$$

### 4.2 具有群承诺的 Paillier 操作范围 ZK ($\Pi^{\mathsf{aff-g}}$)

在图 10 中，我们给出了一个 $\Sigma$-协议，用于形式为 $(\mathcal{I}=\pm 2^{\ell},\mathcal{J}=\pm 2^{\ell^{\prime}},C,Y,X;x,y,k,r_{0})$ 的元组，满足关系 $R_{\mathsf{aff-g}}$。即，证明者声称他知道 $x\in \pm 2^{\ell}$ 和 $y\in \pm 2^{\ell^{\prime}}$ 在对应于群元素 $X=g^{\pi}$（在曲线上）和 Paillier 密文 $Y=\mathsf{enc}_{N_{1}}(y)\in\mathbb{Z}^{*}_{N_{1}^{2}}$ 和 $C,D\in\mathbb{Z}^{*}_{N_{0}^{2}}$ 的范围内，使得 $D=C^{x}(1+N_{0})^{y}\cdot \rho^{N_{0}}\mod N_{0}^{2}$，对于某个 $\rho\in\mathbb{Z}^{*}_{N_{0}}$。让 $(\hat{N},s,t)$ 是证明的辅助设置参数，即 $\hat{N}$ 是一个合适的（安全双素数）Blum 模数，$s$ 和 $t$ 是 $\mathbb{Z}^{*}_{\hat{N}}$ 中的随机平方（这意味着 $s\in \langle t\rangle$ 以压倒性概率）。

**完备性**。协议可能拒绝一个有效陈述仅当 $|\alpha|\geq 2^{\ell+\varepsilon}-q2^{\ell}$ 或 $|\beta|\geq 2^{\ell^{\prime}+\varepsilon}-q2^{\ell^{\prime}}$，这以最多 $q/2^{\varepsilon-1}$ 的概率发生，通过并集界限。 $\square$

**诚实验证者零知识**。模拟器采样 $z_{1}\gets \pm 2^{\ell+\varepsilon}$, $z_{2}\gets \pm 2^{\ell^{\prime}+\varepsilon}$, $z_{3}\gets \pm \hat{N}\cdot 2^{\ell+\varepsilon}$, $z_{4}\gets \pm \hat{N}\cdot 2^{\ell+\varepsilon}$, $w\gets\mathbb{Z}^{*}_{N_{0}}$ 和 $S,T\gets \langle t\rangle$ 通过 $S=t^{\lambda_{1}}\mod \hat{N},T=t^{\lambda_{2}}\mod \hat{N}$ 其中 $\lambda_{1},\lambda_{2}\gets \pm 2^{\ell}\cdot \hat{N}$，并设置 $A=C^{z_{1}}(1+N_{0})^{z_{2}}w^{N_{0}}\cdot D^{-\varepsilon}\mod N_{0}^{2}$ 和 $B=g^{z_{1}}X^{-\varepsilon}\in\mathbb{G}$ 和 $E=s^{z_{1}}t^{z_{3}}\cdot S^{-\varepsilon}\mod \hat{N}$ 和 $F=s^{z_{2}}t^{z_{4}}\cdot T^{-\varepsilon}\mod \hat{N}$。我们观察到真实分布和模拟分布最多相差 $4q\cdot 2^{-\varepsilon}$，通过并集界限和事实 D.6, D.7。 $\square$

**可靠性**。可靠性属性遵循特殊可靠性（见下文）以及集合 $\{(e,e^{\prime}\in(\pm q)^{2}) \ \text{s.t.} \ e-e^{\prime} \text{ 整除 } N_{1}\}$ 与 $(\pm q)^{2}$ 相比可忽略地小（因为 $N_{1}$ 的除数大于 $2^{\ell}\approx q$）。 $\square$

**特殊可靠性**。让 $(S,T,A,B,E,F,e,z_{1},z_{2},z_{3},z_{4},w,w_{y})$ 和 $(S,T,A,B,E,F,e^{\prime},z_{1}^{\prime},z_{2}^{\prime},z_{3}^{\prime},z_{4}^{\prime},w^{\prime},w_{y}^{\prime})$ 表示两个接受转录本使得 $e\neq e^{\prime}$ 并让 $\Delta_{e}$, $\Delta_{z_{1}}$, $\Delta_{z_{2}}$, $\Delta_{z_{3}}$, $\Delta_{z_{4}}$ 表示相关差异，并且假设 $\Delta_{e}$ 不整除 $N_{1}$。类似于先前的范围证明，我们展示 $\Delta_{e}$ 整除（在整数 $\mathbb{Z}$ 上）每个 $\Delta_{z_{1}}$, $\Delta_{z_{2}}$, $\Delta_{z_{3}}$, $\Delta_{z_{4}}$ 并且所有秘密都可以毫无问题地提取。使用与先前证明相同的论证，我们观察到 $\Delta_{e}$ 不整除 $\Delta_{z_{1}}$ 或 $\Delta_{z_{3}}$ 的概率最多为 $\Pr[\mathsf{sRSA}]/(\frac{1}{2}-\mathsf{negl}_{1})$ 并且 $\Delta_{e}$ 不整除 $\Delta_{z_{2}}$ 或 $\Delta_{z_{4}}$ 的概率最多为 $\Pr[\mathsf{sRSA}]/(\frac{1}{2}-\mathsf{negl}_{2})$。因此，通过并集界限，我们得出结论

$$\Pr[\neg\text{extract}_{1}\vee\neg\text{extract}_{2}]\leq 2\cdot\Pr[\mathsf{sRSA}]\cdot\left(\frac{1}{2}-\max(\mathsf{negl}_{1},\mathsf{negl}_{2})\right)^{-1}$$

其中 $\neg\text{extract}_{j}$ 表示事件 $(\Delta_{e}\nmid\Delta_{z_{j}}\vee\Delta_{e}\nmid\Delta_{z_{j+2}})$。 $\square$

*   **设置**：辅助 Paillier 模数 $\hat{N}$ 和 Ring-Pedersen 参数 $s,t\in\mathbb{Z}_{N}^{*}$。
*   **输入**：公共输入是 $(\mathbb{G},g,N_{0},N_{1},C,D,Y,X)$，其中 $q=|\mathbb{G}|$ 且 $g$ 是 $\mathbb{G}$ 的生成元。证明者有秘密输入 $(x,y,\rho,\rho_{y})$ 使得 $x\in \pm 2^{\ell}$, $y\in \pm 2^{\ell^{\prime}}$, $g^{x}=X$, $(1+N_{1})^{y}\rho_{y}^{N_{1}}=Y\mod N_{1}^{2}$，且 $D=C^{c}(1+N_{0})^{y}\cdot \rho^{N_{0}}\mod N_{0}^{2}$。

1.  证明者采样 $\alpha\gets \pm 2^{\ell+\varepsilon}$ 和 $\beta\gets \pm 2^{\ell^{\prime}+\varepsilon}$ 和
    $$\begin{cases}r\gets\mathbb{Z}_{N_{0}}^{*},\,r_{y}\gets\mathbb{Z}_{N_{1}}^{*}\\ \gamma\gets \pm 2^{\ell+\varepsilon}\cdot \hat{N},\,m\gets \pm 2^{\ell}\cdot \hat{N}\\ \delta\gets \pm 2^{\ell+\varepsilon}\cdot \hat{N},\,\mu\gets \pm 2^{\ell}\cdot \hat{N}\end{cases} \quad\text{并计算}\begin{cases}A=C^{\alpha}\cdot((1+N_{0})^{\beta}\cdot r^{N_{0}})\mod N_{0}^{2}\\ B_{x}=g^{\alpha}\in\mathbb{G}\\ B_{y}=(1+N_{1})^{\beta}r_{y}^{N_{1}}\mod N_{1}^{2}\\ E=s^{\alpha}t^{\gamma},\,S=s^{x}t^{m}\mod \hat{N}\\ F=s^{\beta}t^{\delta},\,T=s^{y}t^{\mu}\mod \hat{N}\end{cases}$$
    并将 $(S,T,A,B,E,F)$ 发送给验证者。
2.  验证者回复 $e\gets \pm q$。
3.  证明者将 $(z_{1},z_{2},z_{3},z_{4},w,w_{y})$ 发送给验证者，其中
    $$\begin{cases}z_{1}=\alpha+ex\\ z_{2}=\beta+ey\\ z_{3}=\gamma+em\\ z_{4}=\delta+e\mu\\ w=r\cdot \rho^{\varepsilon}\mod N_{0}\\ w_{y}=r_{y}\cdot \rho_{y}^{\varepsilon}\mod N_{1}\end{cases}$$

*   **等式检查**：
    $$\begin{cases}C^{z_{1}}(1+N_{0})^{z_{2}}w^{N_{0}}=A\cdot D^{c}\mod N_{0}^{2}\\ g^{z_{1}}=B_{x}\cdot X^{e}\in\mathbb{G}\\ (1+N_{1})^{z_{2}}w_{y}^{N_{1}}=B_{y}\cdot Y^{e}\mod N_{1}^{2}\\ s^{z_{1}}t^{z_{3}}=E\cdot S^{e}\mod \hat{N}\\ s^{z_{2}}t^{z_{4}}=F\cdot T^{e}\mod \hat{N}\end{cases}$$

*   **范围检查**：
    $$\begin{cases}z_{1}\in \pm 2^{\ell+\varepsilon}\\ z_{2}\in \pm 2^{\ell^{\prime}+\varepsilon}\end{cases}$$
    证明保证 $x\in \pm 2^{\ell+\varepsilon}$ 和 $y\in \pm 2^{\ell^{\prime}+\varepsilon}$。

**图 10**：具有群承诺的 Paillier 仿射操作范围 ZK – $\Pi^{\mathsf{aff-g}}$

### 4.3 Paillier-Blum 模数 ZK ($\Pi^{\text{mod}}$)

在图 11 中，我们给出了一个 $\Sigma$-协议，用于满足关系 $R_{\text{mod}}$ 的元组 $(N;p,q)$。证明者声称 $N$ 是一个 Paillier-Blum 模数，即 $\gcd(N,\phi(N))=1$ 且 $N=pq$，其中 $p$, $q$ 是满足 $p,q\equiv 3\mod 4$ 的素数。以下协议是 van de Graaf 和 Peralta [52] 以及 Goldberg 等人 [34] 的组合（和简化）。

**图 11**（Paillier-Blum 模数 ZK - $\Pi^{\text{mod}}$）

*   **输入**：公共输入是 $N$。证明者有秘密输入 $(p,q)$ 使得 $N=pq$。

1.  证明者采样一个随机的 $w\gets\mathbb{Z}_{N}$，其雅可比符号为 $-1$，并将其发送给验证者。
2.  验证者发送 $\{y_{i}\gets\mathbb{Z}_{N}\}_{i\in[m]}$
3.  对于每个 $i\in[m]$ 设置：
    *   $x_{i}=\sqrt[4]{y_{i}^{\prime}}\mod N$，其中 $y_{i}^{\prime}=(-1)^{a_{i}}w^{b_{i}}y_{i}$ 对于唯一的 $a_{i},b_{i}\in\{0,1\}$ 使得 $x_{i}$ 是良定义的。
    *   $z_{i}=y_{i}^{N^{-1}\mod \phi(N)}\mod N$
        将 $\{(x_{i},a_{i},b_{i}),z_{i}\}_{i\in[m]}$ 发送给验证者。

*   **验证**：当且仅当以下所有条件成立时接受：
    *   $N$ 是一个奇合数。
    *   对于每个 $i\in[m]$，$z_{i}^{N}=y_{i}\mod N$。
    *   对于每个 $i\in[m]$，$x_{i}^{4}=(-1)^{a_{i}}w^{b_{i}}y_{i}\mod N$ 且 $a_{i},b_{i}\in\{0,1\}$。

**图 11**：Paillier-Blum 模数 ZK - $\Pi^{\text{mod}}$

_完备性_。概率 1 由构造。 $\square$

_可靠性_。我们首先观察到，如果 $\langle N,\phi(N)\rangle\neq 1$，$y_{i}$ 允许 $N$ 次根的概率最多为 $1/\left\langle N,\phi(N)\right\rangle\leq 1/2$。因此，以 $2^{-m}$ 的概率，成立 $\langle N,\phi(N)\rangle=1$，特别是 $N$ 是无平方因子的。接下来，如果 $N$ 是超过 3 个素数的乘积，那么对于每个 $i$，$\{y_{i},-y_{i},wy_{i},-wy_{i}\}$ 包含一个二次剩余（这是成为四次方的必要条件）的概率最多为 $(1/2)^{m}$，对于任何 $w$。

另一方面，如果 $N=pq$ 且要么 $q$ 要么 $p\equiv 1\mod 4$，那么对于每个 $i$，$\{y_{i},-y_{i},wy_{i},-wy_{i}\}$ 包含一个四次方的概率最多为 $(1/2)^{-m}$，原因如下。写 $\mathcal{L}:\mathbb{Z}_{N}^{*}\mapsto\{-1,1\}^{2}$ 使得 $\mathcal{L}(x)=(a,b)$，其中 $a$ 是 $x$ 关于 $p$ 的勒让德符号，$b$ 是 $x$ 关于 $q$ 的勒让德符号。对于固定的 $w$，下表根据 $\mathcal{L}(-1)$ 和 $\mathcal{L}(w)$ 的值上限了 $\{y_{i},-y_{i},wy_{i},-wy_{i}\}$ 包含四次方的概率；红色是它包含一个平方的概率，蓝色是随机平方也是四次方的概率，因为在这些情况下集合恰好包含一个平方。

| $\mathcal{L}(w)\setminus\mathcal{L}(-1)$ | $(1,1)$ | $(-1,1)$ | $(1,-1)$ | $(-1,-1)$ |
| :-------------------------------------: | :-----: | :------: | :------: | :-------: |
|                 $(1,1)$                 |  $1/4$  |  $1/2$   |  $1/2$   |   $1/2$   |
|                $(-1,1)$                 |  $1/2$  |  $1/2$   |  $1/2$   |   $1/2$   |
|                $(1,-1)$                 |  $1/2$  |  $1/2$   |  $1/2$   |   $1/2$   |
|               $(-1,-1)$                 |  $1/2$  |  $1/2$   |  $1/2$   |   $1/2$   |

因此，无平方因子非 Blum 模数通过上述测试的概率最多为 $2^{-m}$。总体而言，接受错误陈述的概率最多为 $2^{-m+1}$。 $\square$

_诚实验证者零知识_。采样一个随机的 $\gamma_{i}$ 并设置 $z_{i}^{\prime}=\gamma_{i}^{4}$，和 $x_{i}=\gamma_{i}^{N}$ 和 $y_{i}^{\prime}=z_{i}^{\prime N}=x_{i}^{4}\mod N$。采样一个具有雅可比符号 $-1$ 的随机 $u$ 并设置 $w=u^{N}\mod N$。最后采样独立同分布的随机位 $(a_{i},b_{i})_{i=1\ldots m}$ 并执行：

*   对于每个 $i\in[m]$，设置 $y_{i}=(-1)^{a_{i}}w^{-b_{i}}y_{i}^{\prime}$ 和 $z_{i}=(-1)^{a_{i}}u^{-b_{i}}z_{i}^{\prime}$
*   输出 $[w,\{y_{i}\}_{i},\{(x_{i},a_{i},b_{i}),z_{i}\}_{i}]$。

知道 $-1$ 不是模 $N$ 的平方且雅可比符号为 $1$，真实分布和模拟分布是相同的。 $\square$

#### 4.3.1 Paillier-Blum 模数因式分解的提取

我们强调上述协议仅对**诚实**验证者是零知识的，我们在我们门限签名协议的安全性分析中强烈利用了这一点。具体来说，假设证明者成功解决了所有挑战，如果验证者发送 $y_{i}$，他秘密知道 $v_{i}$ 使得 $v_{i}^{2}=(-1)^{a_{i}}w^{b_{i}}y_{i}\mod N$，那么，对于某个 $i$，验证者可以推导出 $v^{\prime}_{i}$ 使得 $v^{\prime}_{i}\neq v_{i},-v_{i}\mod N$ 且 $v^{\prime 2}_{i}=y_{i}\mod N$ 以压倒性概率。因此，恶意验证者可以使用对 $(v_{i},v^{\prime}_{i})$ 高效推导出 $N$ 的因式分解（参见事实 D.5）。

我们在我们协议的安全性分析中强烈利用上述内容。具体来说，当对手查询随机预言机以获得其 Paillier-Blum 模数良构的 ZK 证明的挑战时，模拟器相应地编程预言机以提取模数的因式分解。即：

_提取_。采样随机 $\{v_{i}\gets\mathbb{Z}_{N}\}_{i\in[m]}$ 和独立同分布的位 $\{(a_{i},b_{i})\}_{i\in[m]}$ 并设置 $y_{i}=(-1)^{a_{i}}w^{-b_{i}}v_{i}^{2}\mod N$。发送 $\{y_{i}\}_{i}$ 给证明者。如果 $N$ 是 Paillier-Blum 模数，那么 $-1$ 不是模 $N$ 的平方且雅可比符号为 $1$，因此只要 $w$ 的雅可比符号为 $-1$，$y_{i}$ 就是真正随机的。 $\square$

**备注 4.3**。我们指出提取技术仅在 $N$ 是 Paillier-Blum 模数时有效。这是为什么在辅助信息阶段，我们指示参与方“证明两次”的主要原因。这样，我们确保模数是 Paillier-Blum 的，然后模拟器可以准确地编程预言机以进行提取。

### 4.4 Ring-Pedersen 参数 ZK ($\Pi^{\text{prm}}$)

图 12 中关系 $R_{\text{prm}}$ 的 $\Sigma$-协议是一个 ZK 协议，用于证明 $s$ 属于模 $N$ 下由 $t$ 生成的乘法群。

**图 12**（Ring-Pedersen 参数 ZK - $\Pi^{\text{prm}}$）

*   **输入**：公共输入是 $(N,s,t)$。证明者有秘密输入 $\lambda$ 使得 $s=t^{\lambda}\mod N$。
1.  证明者采样 $\{a_{i}\gets\mathbb{Z}_{\phi(N)}\}_{i\in[m]}$ 并将 $A_{i}=t^{a_{i}}\mod N$ 发送给验证者。
2.  验证者回复 $\{e_{i}\gets\{0,1\}\}_{i\in[m]}$
3.  证明者将 $\{z_{i}=a_{i}+e_{i}\lambda\mod \phi(N)\}_{i\in[m]}$ 发送给验证者。

*   **验证**：如果对于每个 $i\in[m]$，$t^{z_{i}}=A_{i}\cdot s^{e_{i}}\mod N$，则接受。

_完备性_。概率 $1$，由构造。 $\square$

_可靠性_。假设 $s\notin \langle t\rangle$。首先观察到对于任何 $z\in\phi(N)$，成立 $s^{-1}\cdot t^{z}\notin \langle t\rangle$。接下来注意如果 $A\notin \langle t\rangle$，那么对于每个 $z$，$t^{z}\neq A\mod N$。因此，如果对手能正确猜出所有挑战，则他生成一个接受转录本，这以 $2^{-m}$ 的概率发生。 $\square$

_零知识_。采样 $\{z_{i}\gets \pm N/2\}_{i\in[m]}$ 和 $\{e_{i}\gets\{0,1\}\}_{i\in[m]}$ 并设置 $A_{i}=s^{-e_{i}}\cdot t^{z_{i}}$。真实分布和模拟分布在统计上 $m\cdot(1-\phi(N)/N)$-接近。 $\square$

最后，Pedersen 参数可以如下生成；采样 $\tau\gets\mathbb{Z}_{N}^{*}$ 和 $\lambda\gets\mathbb{Z}_{\phi(N)}$ 并设置 $t=\tau^{2}\mod N$ 和 $s=t^{\lambda}\mod N$。

**图 12**：Ring-Pedersen 参数 ZK – $\Pi^{\text{prm}}$

#### 4.4.1 关于辅助 RSA 模数和 Ring-Pedersen 参数

辅助模数总是属于验证者，并且必须作为安全双素数 RSA 模数进行采样。此外，对 $(s,t)$ 应由 $\mathbb{Z}_{\hat{N}}$ 中的非平凡二次剩余组成。在实际设置中，我们采样 $\hat{N}$ 作为 Blum（安全素数乘积）整数，并且 $s=\tau^{2d}\mod \hat{N}$ 和 $t=\tau^{2}\mod N$ 对于均匀的 $\tau\gets\mathbb{Z}_{\hat{N}}$。在辅助信息阶段，（未来）验证者向证明者证明 $s\in \langle t\rangle$。

第二个在以上证明中隐含解决的问题是如何在 $\langle t\rangle$ 中采样均匀元素。朴素的想法是通过在 $\hat{N}$ 中采样元素来在 $\phi(\hat{N})$ 中采样随机元素。然而，如果 $\hat{N}$ 有小因子，[^17] 那么接近零的小值将明显比其他值在模 $\phi(\hat{N})$ 下具有更多的权重。为了解决这个问题，我们指示证明者（以及零知识证明中的模拟器）从 $\pm 2^{\ell}\cdot N$ 中采样元素。这样，模 $\phi(\hat{N})$，结果分布与 $\phi(N)$ 中的均匀分布相差 $\frac{1}{2^{\ell}}$，根据事实 D.7。

[^17]: 如果 $N$ 有非常小的因子，这不是问题。更成问题的参数范围是（作为安全参数 $\kappa$ 的函数）$\hat{N}=\hat{p}\hat{q}$ 其中 $q\sim \text{poly}(\kappa)$ 且 $p\sim 2^{\kappa}/\text{poly}(\kappa)$。

**模数选择**。关于我们的 ECDSA 协议，对于 $\Pi^{\text{enc}}$ 协议，$N_{0}$ 是证明者的 Paillier 模数，而 $\hat{N}$ 是验证者的 Paillier 模数。对于 $\Pi^{\text{aff-g}}$ 协议，$N_{0},\hat{N}$ 是验证者的 Paillier 模数，他是同态评估的“接收者”，而 $N_{1}$ 是证明者的模数，他是同态“评估者”。有关所有细节，请参阅图 7 中的预签名协议。

## 5 安全性分析

在本节中，我们展示我们的协议 UC 实现了一个主动理想门限签名功能（$\mathcal{F}_{\textsf{tsig}}$ 来自图 14）。本节假定对 UC 框架熟悉（简要概述见附录 A）。我们在安全性分析中采用随机预言机模型，并假设所有哈希值（例如用于 Fiat-Shamir 启发式）通过查询随机预言机获得，定义如下。

### 5.1 全局随机预言机

我们使用 Canetti 等人 [18]、Camenisch 等人 [9] 的形式主义，将随机预言机模型纳入 UC 框架内。这种形式主义解释了随机预言机是实际公共哈希函数的抽象，该哈希函数在分析的系统及其环境中全局使用。具体来说，随机预言机被建模为一个理想功能，在真实系统**和理想系统**中都是全局可访问的。Canetti 等人 [18]、Camenisch 等人 [9] 为表示随机预言机的功能提供了许多替代公式。这里我们使用最简单（也是最严格）的公式，称为**严格随机预言机**。[^18]

[^18]: 我们的分析即使使用随机预言机的严格形式化也能工作，这意味着它可以与 Canetti 等人 [18]、Camenisch 等人 [9] 中讨论的任何其他（更复杂的）变体一起工作。

该功能接受任意大小的输入，并由输出长度 $h$ 参数化。当在新的消息 $m\in\{0,1\}^{*}$ 上查询时，该功能返回一个从 $\{0,1\}^{h}$ 中均匀选择的值。所有未来对 $m$ 的查询返回相同的值。

**图 13**（全局随机预言机功能 $\mathcal{H}$）

**参数**：输出长度 $h$。

*   在从机器 $\mathcal{X}$ 接收到输入 $(\texttt{query}, m)$ 时，执行：
    *   如果存储了元组 $(m,a)$，则输出 $(\texttt{answer}, a)$ 给 $\mathcal{X}$。
    *   否则采样 $a\gets\{0,1\}^{h}$ 并存储 $(m,a)$。输出 $(\texttt{answer}, a)$ 给 $\mathcal{X}$。

**图 13**：全局随机预言机功能 $\mathcal{H}$

### 5.2 理想门限签名功能

接下来，我们描述我们的理想门限签名功能。该功能主要是对 Canetti [11] 的（非门限）签名功能的改编，并增加了一个重要的补充以考虑主动安全性。参见图 14 对功能的正式描述。

**高层描述**。当被所有参与方激活时，该功能向理想世界对手 $\mathcal{S}$ 请求一个公钥 $X$ 和一个验证算法 $\mathcal{V}$。然后，当所有参与方调用该功能以获得某个消息 $m$ 的签名时，该功能向 $\mathcal{S}$ 请求一个“签名” $\sigma$ 并记录 $\sigma$ 是 $m$ 的有效签名。最后，当该功能被要求验证某个消息 $m$ 的签名 $\sigma$ 时，该功能要么返回真/假，如果对 $(m,\sigma)$ 被记录为有效/无效，要么它应用验证算法 $\mathcal{V}$ 并返回其输出。

**主动安全性**。该功能通过腐化/去腐化和密钥刷新接口增强以捕捉主动安全性，如下：(1) 对手可以在整个（理想）过程中注册参与方为腐化的，(2) 对手可以决定去腐化参与方，并且这些参与方被记录为“隔离的”，以及 (3) 如果密钥刷新接口被激活，则该功能擦除所有隔离玩家的记录。在任何时间点，如果该功能记录所有参与方同时被腐化/隔离，则该功能有效地将验证过程的控制权交给对手。

### 5.3 安全性声明

我们展示我们的协议 UC 实现功能（$\mathcal{F}_{\texttt{tsig}}$ 来自图 14）。我们的证明通过逆否命题进行；在合适的密码学假设下，我们展示如果我们的协议不 UC 实现功能 $\mathcal{F}_{\texttt{tsig}}$，那么存在一个 PPT 算法可以区分 Paillier 密文**或**存在一个 PPT 存在性伪造者用于标准/增强 ECDSA 算法，与假定的 Paillier 密码系统和 ECDSA 签名方案的安全性 respectively 相矛盾。

**定理 5.1**。_假设 Paillier 密码系统的语义安全性、强 RSA 假设和 ECDSA 的存在性不可伪造性，成立图 3 中的协议 UC 实现图 14 中的功能 $\mathcal{F}_{\texttt{tsig}}$。_

**定理 5.2**。_假设 Paillier 密码系统的语义安全性、强 RSA 假设和 ECDSA 的增强存在性不可伪造性，成立图 4 中的协议在存在全局随机预言机功能 $H$ 的情况下 UC 实现图 14 中的功能 $\mathcal{F}_{\texttt{tsig}}$。_

本节的其余部分致力于定理 5.2 的分析（模拟器和证明）。定理 5.1 的分析本质上是相同的。

#### 5.3.1 定理 5.2 的证明

定理 5.2 是以下两个引理的推论。

**引理 5.3**。_如果图 4 中的协议不 UC 实现功能 $\mathcal{F}_{\texttt{tsig}}$，那么存在一个环境 $\mathcal{Z}$，它可以在图 4 中协议的执行中为以前未签名的消息伪造签名。_

证明。该主张是直接的，因为理想过程模拟是完美的（参见第 5.4 节）。 $\square$

**引理 5.4**。_假设强 RSA，以下成立。如果存在一个环境 $\mathcal{Z}$，它可以在图 4 中协议的执行中为以前未签名的消息伪造签名，那么存在算法 $\mathcal{R}_{1}$ 和 $\mathcal{R}_{2}$ 具有对 $\mathcal{Z}$ 的黑盒访问权限，使得以下至少一项为真。_

1.  $\mathcal{R}_{1}$ 以明显大于 $1/2$ 的概率赢得 Paillier 的语义安全实验。
2.  $\mathcal{R}_{2}$ 以显著概率赢得（非门限）ECDSA 的增强存在性不可伪造性实验。

**图 14**（理想门限签名功能 $\mathcal{F}_{\texttt{tsig}}$）

**密钥生成**：

1.  在从某个参与方 $\mathcal{P}_{i}$ 接收到 $(\texttt{keygen}, ssid)$ 时，解释 $ssid=(\ldots,\boldsymbol{P})$，其中 $\boldsymbol{P}=(\mathcal{P}_{1},\ldots,\mathcal{P}_{n})$。
    *   如果 $\mathcal{P}_{i}\in \boldsymbol{P}$，发送给 $\mathcal{S}$ 并记录 $(\texttt{keygen}, ssid,\mathcal{P}_{i})$。
    *   否则忽略该消息。
2.  一旦为所有 $\mathcal{P}_{j}\in \boldsymbol{P}$ 记录了 $(\texttt{keygen}, ssid,j)$，发送 $(\texttt{pubkey}, ssid)$ 给对手 $\mathcal{S}$ 并执行：
    (a) 在从 $\mathcal{S}$ 接收到 $(\texttt{pubkey}, ssid,X,\mathcal{V})$ 时，记录 $(ssid,X,\mathcal{V})$。
    (b) 在从 $\mathcal{P}_{i}\in \boldsymbol{P}$ 接收到 $(\texttt{pubkey}, ssid)$ 时，如果记录了则输出 $(\texttt{pubkey}, ssid,X)$。否则忽略该消息。

**签名**：

1.  在从 $\mathcal{P}_{i}$ 接收到 $(\texttt{sign}, sid=(ssid,\ldots),m)$ 时，发送给 $\mathcal{S}$ 并记录 $(\texttt{sign}, sid,m,i)$。
2.  在从 $\mathcal{S}$ 接收到 $(\texttt{sign}, sid=(ssid,\ldots),m,j)$ 时，如果 $\mathcal{P}_{j}$ 被腐化则记录 $(\texttt{sign}, sid,m,j)$。否则忽略该消息。
3.  一旦为所有 $\mathcal{P}_{i}\in \boldsymbol{P}$ 记录了 $(\texttt{sign}, sid,m,i)$，发送 $(\texttt{sign}, sid,m)$ 给对手 $\mathcal{S}$ 并执行：
    (a) 在从 $\mathcal{S}$ 接收到 $(\texttt{signature}, sid,m,\sigma)$ 时，
    *   如果元组 $(sid,m,\sigma,0)$ 被记录，输出错误。
    *   否则，记录 $(sid,m,\sigma,1)$。
    (b) 在从 $\mathcal{P}_{i}\in \boldsymbol{P}$ 接收到 $(\texttt{signature}, sid,m)$ 时：
    *   如果 $(sid,m,\sigma,1)$ 被记录，输出 $(\texttt{signature}, sid,m,\sigma)$ 给 $\mathcal{P}_{i}$。
    *   否则忽略该消息。

**验证**：

在从参与方 $\mathcal{Q}$ 接收到 $(\texttt{sig-vrfy}, sid,m,\sigma,X)$ 时，发送元组 $(\texttt{sig-vrfy}, sid,m,\sigma,X)$ 给 $\mathcal{S}$ 并执行：

*   如果元组 $(m,\sigma,\beta^{\prime})$ 被记录，则设置 $\beta=\beta^{\prime}$。
*   否则，如果 $m$ 从未被签名且并非所有 $\boldsymbol{P}$ 中的参与方都被腐化/隔离，设置 $\beta=0$。 "_不可伪造性_"
*   否则，设置 $\beta=\mathcal{V}(m,\sigma,X)$。

记录 $(m,\sigma,\beta)$ 并输出 $(\texttt{istrue}, sid,m,\sigma,\beta)$ 给 $\mathcal{Q}$。

**密钥刷新**：

在从 $\mathcal{P}_{i}\in \boldsymbol{P}$ 接收到 $\texttt{key-refresh}$ 时，发送 $\texttt{key-refresh}$ 给 $\mathcal{S}$，并执行：

*   如果并非所有 $\boldsymbol{P}$ 中的参与方都被腐化/隔离，擦除所有 $(\texttt{quarantine},\ldots)$ 的记录。

**腐化/去腐化**：

1.  在从 $\mathcal{S}$ 接收到 $(\texttt{corrupt}, \mathcal{P}_{j})$ 时，记录 $\mathcal{P}_{j}$ 被腐化。
2.  在从 $\mathcal{S}$ 接收到 $(\texttt{decorrupt}, \mathcal{P}_{j})$ 时：
    *   如果并非所有参与方都被腐化/隔离，执行：如果有记录 $\mathcal{P}_{j}$ 被腐化，擦除它并记录 $(\texttt{quarantine}, \mathcal{P}_{j})$。
    *   否则什么也不做。

**图 14**：理想门限签名功能 $\mathcal{F}_{\texttt{tsig}}$

引理 5.4 的证明。让 $\mathcal{Z}$ 表示环境，它可以在图 4 中协议的执行中为以前未签名的消息伪造签名，并让 $T\in\mathsf{poly}$ 表示在伪造发生之前运行辅助信息阶段次数的上限。让 $N^{1},\ldots,N^{T}$ 和 $(X,x)$ 表示根据协议规范采样的 Paillier 公钥和 ECDSA 密钥对，并让 $\mathcal{R}_{1}$ 和 $\mathcal{R}_{2}$ 分别表示第 5.4.1 和 5.4.2 节的过程。考虑以下三个实验：

**实验 A**。在参数 $(X,x)$ 和 $(N^{k},c^{k})_{k=1,\ldots,T}$ 上运行 $\mathcal{Z}$ 与 $\mathcal{R}_{1}$，其中 $c^{k}=\mathsf{enc}_{N^{k}}(1)$。

**实验 B**。在参数 $(X,x)$ 和 $(N^{k},c^{k})_{k=1,\ldots,T}$ 上运行 $\mathcal{Z}$ 与 $\mathcal{R}_{1}$，其中 $c^{k}=\mathsf{enc}_{N^{k}}(0)$。

**实验 C**。在参数 $X$ 上运行 $\mathcal{Z}$ 与 $\mathcal{R}_{2}$。

换句话说，过程 $\mathcal{R}_{1}$，称为 _Paillier 区分器_，模拟诚实参与方与环境的交互如下。在密钥生成阶段，$\mathcal{R}_{1}$ 选择主秘密密钥 $x$，并选择诚实参与方的秘密密钥，使得主公钥等于 $X=g^{x}$（此步骤需要回绕环境）。接下来，在每个密钥刷新阶段开始时，$\mathcal{R}_{1}$ 选择一个随机的诚实参与方 $\mathcal{P}_{b}$ 并如下进行。对于除 $\mathcal{P}_{b}$ 之外的所有诚实参与方，模拟简单地遵循协议指令。对于 $\mathcal{P}_{b}$，模拟选择从 $N^{1}\ldots,N^{T}$（视为堆栈）中抽取的 Paillier 密钥，并且其消息通过 (1) 提取环境的秘密和 (2) 使用 Paillier 密码系统的同态属性来计算。为了进一步阐述后者，我们强调 $\mathcal{R}_{1}$ 将一系列密文 $c^{1},\ldots,c^{T}$ 作为输入，因为 $\mathcal{P}_{b}$ 在他自己的密钥（比如 $N^{t}$）下的密文被计算为 $c^{t}$ 的变换，而不是作为新的加密。此外，所有 $\mathcal{P}_{b}$ 的证明都使用相关模拟器并相应地编程预言机来模拟。预签名和签名以类似方式模拟。

根据 $c^{t}$ 的底层明文值（零或一），$\mathcal{R}_{1}$ 与 $\mathcal{Z}$ 交互的转录本要么是“真实的”，即统计接近诚实参与方与环境之间真实交互的实际转录本，要么是“伪造的”，因为所有特殊参与方的密文都是零的加密。最后，我们注意到特殊参与方的身份在每次刷新阶段重新随机化，并且如果环境请求腐化特殊参与方，则实验（通过回绕）重置到最后一次刷新。

**主张 5.5**。_假设强 RSA，如果 $\mathcal{Z}$ 在时间 $\tau$ 内以概率 $\alpha$ 在图 4 中协议的执行中输出伪造，那么 $\mathcal{Z}$ 在时间 $\tau\cdot n\log(n)$ 内以至少 $\alpha^{2}-\mathsf{negl}(\kappa)$ 的概率在实验 $A$ 中输出伪造。_

**主张 5.6**。_假设 Paillier 密码系统的语义安全性，如果 $\mathcal{Z}$ 在时间 $\tau$ 内以概率 $\alpha$ 在实验 $A$ 中输出伪造，那么 $\mathcal{Z}$ 在时间 $\tau$ 内以至少 $\alpha-\mathsf{negl}(\kappa)$ 的概率在实验 $B$ 中输出伪造。_

第二个过程 $\mathcal{R}_{2}$，称为 _ECDSA 伪造者_，仅使用公钥和用于普通（非门限）ECDSA 的增强签名预言机模拟环境与诚实参与方的交互，并且它不接受任何辅助输入。模拟进行如下。在密钥生成阶段，$\mathcal{R}_{2}$ 选择诚实参与方的公钥，使得主公钥等于 $X$（此步骤需要回绕环境）。更精确地说，模拟器为所有但一个诚实参与方按照规定选择值，并为随机选择的特殊参与方分配公钥份额 $X_{b}=X\cdot\prod_{j\neq b}X_{j}$。协议的其余阶段以类似方式模拟（通过使用特殊参与方“补偿”未知值），但有以下重要区别：

*   预签名模拟调用增强预言机以获得曲线上用于（未来）签名的点。
*   签名模拟请求预言机对先前发布的点进行签名。

最后，类似于 Paillier 区分器，我们注意到特殊参与方的身份在每次刷新阶段重新随机化，并且每当环境请求腐化特殊参与方时，实验（通过回绕）重置到最后一次刷新。

**主张 5.7**。_如果 $\mathcal{Z}$ 在时间 $\tau$ 内以概率 $\alpha$ 在实验 $B$ 中输出伪造，那么 $\mathcal{Z}$ 在时间 $\tau$ 内以概率 $\alpha$ 在实验 $C$ 中输出伪造。_

### 5.4 模拟器

**UC 模拟器**。如引言中所述，理想过程对手的描述基本上是微不足道的。即，模拟器按照规定采样所有诚实参与方的值，并遵循协议的指令，对于每个阶段。大体上：

1.  在密钥生成阶段结束时，模拟器将获得的公钥 $X$ 连同 ECDSA 验证算法发送给功能。
2.  在某个消息 msg 的每个签名阶段结束时，模拟器将计算的签名 $(r,\sigma)$ 发送给功能。
3.  当环境决定腐化/去腐化某个参与方时，模拟器将请求转发给功能。

#### 5.4.1 Paillier 区分器 ($\mathcal{R}_{1}$)

Paillier 区分器 $\mathcal{R}_{1}$ 由 $T$ 和 Paillier 公钥和密文 $N^{1},\ldots,N^{T}$ 和 $C^{1},\ldots,C^{T}$ 以及一个 ECDSA 密钥对 $(X,x)$ 参数化。让 $\mathbf{ctr}$ 表示一个计数器变量，初始化为 $\mathbf{ctr}=0$。让 $\boldsymbol{L}$ 表示模拟器保存在内存中的查询-答案列表，初始化为空集。算法 $\mathcal{R}_{1}$ 由以下与环境 $\mathcal{Z}$ 的交互定义。

**预言机调用**。在从 $\mathcal{Z}$ 接收到 $(\texttt{query},m)=(\texttt{query},ssid^{\prime},srid^{\prime},\ldots)$ 时，执行：

1.  如果 $(ssid^{\prime},srid^{\prime})\neq(ssid,srid)$ 返回 $(\texttt{answer},a=\mathcal{H}(m))$。
2.  否则如果 $m=([sid,j,\psi],N)$ 使得 $\mathcal{M}(\texttt{vrfy},\Pi^{\mathrm{mod}},N,\psi)=1$，那么：
    *   编程预言机并提取 $p$, $q$ 使得 $N=pq$（参见第 4.3.1 节）。
    *   将相关元组添加到 $\boldsymbol{L}$。
3.  否则
    (a) 如果 $(m,a)\in \boldsymbol{L}$，返回 $(\texttt{answer},a)$。
    (b) 否则均匀采样 $a$，返回 $(\texttt{answer},a)$ 并将 $(m,a)$ 添加到 $\boldsymbol{L}$。

**密钥生成**。环境将 $(\texttt{keygen},ssid=(\ldots,\boldsymbol{P}),i)$ 写在 $\mathcal{P}_{i}$ 的输入磁带上，对于每个 $\mathcal{P}_{i}$ 并腐化参与方的严格子集 $\boldsymbol{C}\subsetneq \boldsymbol{P}$。调用 $\mathcal{S}^{1}(ssid,\boldsymbol{C},\boldsymbol{L},X)$ 并获得输出并获得输出 $b$, $\boldsymbol{L}$, $srid$, $\{x_{k}\}_{k\neq b}$ 和 $\boldsymbol{X}=(X_{1},\ldots)$。设置 $x_{b}=x-\sum_{j\neq b}x_{j}\mod q$。

**辅助信息**。环境将 $(\texttt{aux-info},sid,\ell,i)$ 写在 $\mathcal{P}_{i}$ 的输入磁带上并腐化参与方的严格子集 $\boldsymbol{C}\subsetneq \boldsymbol{P}$。递增 $\mathbf{ctr}=\mathbf{ctr}+1$ 并设置 $\mathbf{aux}=(\{x_{i}\}_{i\notin \boldsymbol{C}},N^{\mathbf{ctr}},C^{\mathbf{ctr}})$ 调用 $\mathcal{S}^{2}(sid,\boldsymbol{L},\boldsymbol{C},\mathbf{aux})$ 并获得输出 $b$ 和 $\{N_{j},s_{j},t_{j},(C_{k}^{j})_{k}\}_{j\in \boldsymbol{P}}$ 和 $(p_{i},q_{i})_{i\in \boldsymbol{H}}$。重新分配 $\{x_{j}=x_{j}+\sum_{k}\mathsf{dec}_{j}(C_{k}^{j})\mod q\}_{k\neq b}$ 和 $x_{b}=x-\sum_{k\neq b}x_{k}\mod q$。

**预签名**。环境将 $(\texttt{pre-sign},sid,\ell,i)$ 写在 $\mathcal{P}_{i}$ 的输入磁带上并腐化参与方的严格子集 $\boldsymbol{C}:=\boldsymbol{C}\cup \boldsymbol{C}^{\prime}\subsetneq \boldsymbol{P}$。采样 $k_{b}$ 和 $\gamma_{b}\gets\mathbb{F}_{q}$ 并设置 $\boldsymbol{x}^{\setminus b}=(x_{j})_{j\neq b}$ 和 $\mathbf{aux}=(c^{\mathbf{ctr}},k_{b},x_{b},\gamma_{b})$。调用 $\mathcal{S}^{3}(sid,\boldsymbol{L},\boldsymbol{C},b,\boldsymbol{x}^{\setminus b},\mathbf{aux})$ 并获得输出 $\{(sid,\ell,R,k_{i},\chi_{i})\}_{i\notin \boldsymbol{C}^{\prime}}$。

**签名**。环境将 $(\texttt{sign},sid,\ell,m,i)$ 写在 $\mathcal{P}_{i}$ 的输入磁带上并腐化参与方的严格子集 $\boldsymbol{C}:=\boldsymbol{C}\cup \boldsymbol{C}^{\prime}\subsetneq \boldsymbol{P}$。

1.  检索 $R$ 和 $\{(k_{i},\chi_{i})\}_{i\notin \boldsymbol{C}}$，设置 $r=R_{\ell}|_{x=\text{axis}}$。
2.  移交 $\{(sid,i,\sigma_{i}=k_{i}m+r\chi_{i})\}_{i\notin \boldsymbol{C}}$。

**动态腐化**。

*   如果 $\mathcal{Z}$ 腐化 $\mathcal{P}_{i}\in \boldsymbol{H}$，则揭示该参与方的（模拟）秘密状态。
*   否则回到 ($\star$) 在模拟器 $\mathcal{S}^{2}$ 的最后一次调用开始时。擦除自那时以来添加到 $\boldsymbol{L}$ 的所有项目。

#### 5.4.2 ECDSA 伪造者 ($\mathcal{R}_{2}$)

我们的 ECDSA 伪造者 $\mathcal{R}_{2}$ 由公钥 $X$ 参数化，并由以下与环境和用于公钥 $X$ 的增强 ECDSA 签名预言机的交互定义。让 $\boldsymbol{L}$ 表示模拟器保存在内存中的查询-答案列表，初始化为空。

**预言机调用**。

在从 $\mathcal{Z}$ 接收到 $(\texttt{query},m)=(\texttt{query},ssid^{\prime},srid^{\prime},\ldots)$ 时，执行：

1.  如果 $(ssid^{\prime},srid^{\prime})\neq(ssid,srid)$ 返回 $(\texttt{answer},a=\mathcal{H}(m))$。
2.  否则如果 $m=([sid,j,\psi],N)$ 使得 $\mathcal{M}(\texttt{vrfy},\Pi^{\textsf{mod}},N,\psi)=1$，那么：
    *   编程预言机并提取 $p$, $q$ 使得 $N=pq$（参见第 4.3.1 节）。
    *   将相关元组添加到 $\boldsymbol{L}$。
3.  否则
    (a) 如果 $(m,a)\in \boldsymbol{L}$，返回 $(\texttt{answer},a)$。
    (b) 否则均匀采样 $a$，返回 $(\texttt{answer},a)$ 并将 $(m,a)$ 添加到 $\boldsymbol{L}$。

**密钥生成**。

环境将 $(\texttt{keygen},ssid=(\ldots,\boldsymbol{P}),i)$ 写在 $\mathcal{P}_{i}$ 的输入磁带上，对于每个 $\mathcal{P}_{i}$ 并腐化参与方的严格子集 $\boldsymbol{C}\subsetneq \boldsymbol{P}$。调用 $\mathcal{S}^{1}(ssid,\boldsymbol{C},\boldsymbol{L},X)$ 并获得输出并获得输出 $b$, $\boldsymbol{L}$, $srid$, $\{x_{k}\}_{k\neq b}$ 和 $\boldsymbol{X}=(X_{1},\ldots)$。

**辅助信息**。

环境将 $(\texttt{aux-info},sid=(ssid,srid,\ldots),i)$ 写在 $\mathcal{P}_{i}$ 的输入磁带上并腐化参与方的严格子集 $\boldsymbol{C}\subsetneq \boldsymbol{P}$。调用 $\mathcal{S}^{2}(sid,\boldsymbol{L},\boldsymbol{C},\texttt{aux})$ 并获得输出 $b$ 和 $\{N_{j},s_{j},t_{j},(C^{j}_{k})_{k}\}_{j\in \boldsymbol{P}}$ 和 $(p_{i},q_{i})_{i\notin \boldsymbol{C}}$。重新分配 $\{x_{j}=\sum_{k}\det_{j}(C^{j}_{k})\}_{j\neq b}$ 和 $x_{b}=$$\bot$。

**预签名**。

环境将 $(\texttt{pre-sign},sid,\ell,i)$ 写在 $\mathcal{P}_{i}$ 的输入磁带上并腐化参与方的严格子集 $\boldsymbol{C}:=\boldsymbol{C}\cup \boldsymbol{C}^{\prime}\subsetneq \boldsymbol{P}$。设置 $\boldsymbol{x}^{\setminus b}=(x_{j})_{j\neq b}$，并执行：

(a) 调用 ECDSA 预言机以获得一个点 $R\in\mathbb{G}$。采样 $\delta\gets\mathbb{F}_{q}$ 并设置 $\texttt{aux}=(R,\delta)$。
(b) 调用 $\mathcal{S}^{3}(sid,\boldsymbol{L},\boldsymbol{C},b,\boldsymbol{x}^{\setminus b},\texttt{aux})$ 并获得输出 $(sid,\ell,\eta^{0},\eta^{1})$ 和 $(sid,\ell,R,k_{i},\chi_{i})_{i\in \boldsymbol{H}}$。

**签名**。

环境将 $(\texttt{sign},sid,\ell,m,i)$ 写在 $\mathcal{P}_{i}$ 的输入磁带上并腐化 $\boldsymbol{C}:=\boldsymbol{C}\cup \boldsymbol{C}^{\prime}\subsetneq \boldsymbol{P}$。

*   检索 $(sid,\ell,\eta^{0},\eta^{1})$ 和 $(sid,\ell,R,k_{i},\chi_{i})_{i\in \boldsymbol{H}}$。
*   调用 ECDSA 预言机在点 $R$ 上对 $m$ 签名以获得签名 $(r,\sigma)$ 并执行：
    (a) 对于 $\mathcal{P}_{i}\in \boldsymbol{H}$，按照规定计算 $\sigma_{i}$ 并移交 $(sid,i,\sigma_{i})$。
    (b) 对于 $\mathcal{P}_{b}$，设置 $\sigma_{b}=\sigma-m\eta^{0}-r\eta^{1}$ 并移交 $(sid,b,\sigma_{b})$。

**动态腐化**。

*   如果 $\mathcal{Z}$ 腐化 $\mathcal{P}_{i}\in \boldsymbol{H}$，则揭示该参与方的（模拟）秘密状态。
*   否则回到 ($\star$) 在辅助信息模拟器 $\mathcal{S}^{2}$ 的第 2 轮中。擦除自那时以来添加到 $\boldsymbol{L}$ 的所有项目。

### 5.5 独立模拟器

**符号 5.8**。写 $\mathcal{S}^{\text{sch}},\mathcal{S}^{\text{mul}},\mathcal{S}^{\text{enc}}_{j},\mathcal{S}^{\text{log}}_{j},\mathcal{S}^{\text{aff}}_{j}$ 表示 $\Pi^{\text{sch}},\Pi^{\text{mul}},\Pi^{\text{enc}}_{j},\Pi^{\text{log}}_{j},\Pi^{\text{aff}}_{j}$ 的 ZK 模拟器。

#### 5.5.1 密钥生成模拟器 ($\mathcal{S}^{1}$)

模拟器 $\mathcal{S}^{1}(ssid,\boldsymbol{C},\boldsymbol{L},X)$ 接受输入会话标识符 $ssid$，列表 $\boldsymbol{L}$，参与方集合 $\boldsymbol{C}\subsetneq \mathcal{P}$ 并进行如下操作。

**第 1 轮**。

*   初始化 $\text{ext}=0$。
*   采样 $\{V_{i}\}_{i\notin \boldsymbol{C}}$ 在规定域中并将 $(ssid,i,V_{i})$ 发送给 $\mathcal{Z}$，对于每个 $\mathcal{P}_{i}\notin \boldsymbol{C}$。

**第 2 轮**。

(i) 当获得所有 $\mathcal{P}_{j}\in \boldsymbol{C}$ 的 $(ssid,j,V_{j})$ 时，
1.  如果 $\text{ext}=0$ 按照规定计算所有值并移交 $\{(ssid,i,{srid}_{i},X_{i},A_{i},u_{i})\}_{i\notin \boldsymbol{C}}$ 给 $\mathcal{Z}$。
2.  否则选择 $\mathcal{P}_{b}\gets \boldsymbol{P}\setminus \boldsymbol{C}$ 均匀随机并让 $\boldsymbol{H}=\boldsymbol{P}\setminus \boldsymbol{C}\cup \{\mathcal{P}_{b}\}$ 并执行：
(a) 对于 $\mathcal{P}_{i}\in \boldsymbol{H}$，按照规定采样所有项目并移交 $(ssid,i,{srid}_{i},X_{i},A_{i},u_{i})$ 给 $\mathcal{Z}$。
(b) 对于特殊参与方 $\mathcal{P}_{b}$，设置 $X_{b}=X\cdot \prod_{j\neq b}X_{j}^{-1}$。调用 ZK 模拟器 $\psi_{b}=(A_{b},\ldots)\gets \mathcal{S}^{\text{sch}}(X_{b},\ldots)$。移交 $(ssid,b,{srid}_{b},X_{b},A_{b},u_{b})$ 给 $\mathcal{Z}$，其中 $(srid_{b},u_{b})$ 按照规定采样。将相关元组添加到 $\boldsymbol{L}$。

**第 3 轮**。

当获得所有元组 $(ssid,j,{srid}_{j},X_{j},A_{j},u_{j})$，对于每个 $\mathcal{P}_{j}\in \boldsymbol{C}$，将 $\{\psi_{j}\}_{j\in \boldsymbol{C}}$ 添加到 $\boldsymbol{E}$ 并执行：设置 $srid=\oplus_{j}{srid}_{j}$ 并移交 $\{(ssid,i,\psi_{i})\}_{i\notin \boldsymbol{C}}$ 给 $\mathcal{Z}$。将相关元组添加到 $\boldsymbol{L}$。

**输出**。

1.  如果 $\text{ext}=0$，设置 $\text{ext}=1$ 并回到 (i) 在第 2 轮中。删除自那时以来添加到 $\boldsymbol{L}$ 的对。
2.  否则，提取 $\{x_{j}\}_{j\notin C}$。输出 $b$, $\boldsymbol{L}$, $srid$, $\{x_{k}\}_{k\neq b}$。

#### 5.5.2 辅助信息与密钥刷新模拟器 ($\mathcal{S}^{2}$)

辅助信息模拟器 $\mathcal{S}^{2}(sid,\boldsymbol{L},\boldsymbol{C},\text{aux})$ 接受输入 $sid=(ssid,srid,\ldots)$，列表 $\boldsymbol{L}$，参与方集合 $\boldsymbol{C}\subsetneq \boldsymbol{P}$，和辅助信息 $\text{aux}=\perp$ 或 $\text{aux}=(\{x_{i}\}_{i\notin \boldsymbol{C}},N^{*},C)$。

**第 1 轮**。

(a) 选择 $\mathcal{P}_{b}\gets \boldsymbol{P}\setminus \boldsymbol{C}$ 均匀随机并设置 $\boldsymbol{H}=\boldsymbol{P}\setminus \boldsymbol{C}\cup \{\mathcal{P}_{b}\}$。
1.  对于每个 $\mathcal{P}_{i}\in \boldsymbol{C}$，执行：按照规定采样所有项目并移交 $(sid,i,N_{i},s_{i},t_{i},V_{i},\psi_{i},\hat{\psi}_{i},\psi^{\prime}_{i})$ 给 $\mathcal{Z}$。
2.  对于 $\mathcal{P}_{b}$，执行：
(a) 如果 $\text{aux}=\perp$，按照规定采样 $(N_{b},p_{b},q_{b},s_{b},t_{b})$ 和 $V_{b}$ 均匀随机。
(b) 如果 $\text{aux}\neq \perp$，设置 $N_{b}=N^{*}$ 并按照规定采样 $(s_{b},t_{b})$ 和 $V_{b}$ 均匀随机。调用
$$\begin{cases}\psi_{b}\gets \mathcal{S}^{\text{mod}}(N_{b},\ldots)\\ \psi^{\prime}_{b}\gets \mathcal{S}^{\text{mod}}(N_{b},\ldots)\\ \psi^{\prime\prime}_{b}\gets \mathcal{S}^{\text{prm}}(s_{b},t_{b},\ldots)\end{cases}$$
移交 $(sid,b,N_{b},s_{b},t_{b},V_{b},\psi_{b},\psi^{\prime}_{b},\psi^{\prime\prime}_{b})$ 给 $\mathcal{Z}$。

将对应预言机调用的相关对添加到 $\bm{L}$。

**第 2 轮**。

当获得所有元组 $(sid,j,V_{j},N_{j},s_{j},t_{j},\psi_{j},\psi^{\prime}_{j},\psi^{\prime\prime}_{j})$，对于每个 $\mathcal{P}_{j}\in \bm{C}$，执行：

对于每个 $\mathcal{P}_{i}\notin \bm{C}$，执行：

(a) 如果 $\operatorname{aux}\neq \bot$，
*   采样 $\{x^{k}_{i}\}_{k}$ 均匀满足 $0=\sum_{k}x^{k}_{i}$ 并设置 $\{X^{k}_{i}=g^{x^{k}_{i}}\}_{k}$。
*   设置 $\{C^{k}_{i}=\mathsf{enc}_{k}(x^{k}_{i})\}_{k\neq b}$ 和 $C^{b}_{i}=C^{x^{k}_{i}}\cdot \mathsf{enc}_{b}(0)$。
*   调用 ZK 模拟器 $\{\psi_{j,i,b}\gets \mathcal{S}^{{\sf log}}_{j}(C^{b}_{i},g,X^{b}_{i}\dots)\}_{j\neq i}$ 和 $\{\pi_{j,b}\gets \mathcal{S}^{{\sf fac}}_{j}(N_{b},\dots)\}_{j\neq b}$。按照规定计算所有其他证明。
(b) 如果 $\operatorname{aux}=\bot$，
*   采样 $\{x^{k}_{i}\}_{k\neq b}$ 并设置 $\{X^{k}_{i}=g^{x^{k}_{b}}\}_{k\neq b}$ 和 $X^{b}_{i}={\sf id}_{\mathbb{G}}\cdot g^{-{\sum_{k\neq b}}x^{k}_{i}}$。
*   设置 $\{C^{k}_{i}=\mathsf{enc}_{k}(x^{k}_{i})\}_{k\neq b}$ 和 $C^{b}_{i}=\mathsf{enc}_{b}(0)$。
*   调用 $\{\psi_{j,i,b}\gets \mathcal{S}^{{\sf log}}_{j}(C^{b}_{i},X^{b}_{i}\dots)\}_{j\neq i}$，按照规定计算所有其他证明。

按照规定采样 $u_{i}$ 并为每个 $j\in \bm{P}$ 移交元组 $(sid,i,\bm{Y}_{i},u_{i},\pi_{j,i}\{\psi_{j,i,k},C^{k}_{i}\}_{k})$。

将奖励元组添加到 $\bm{L}$。

**输出**。

输出 $\{N_{j},s_{j},t_{j},(C^{j}_{k})_{k}\}_{j\in \bm{P}}$ 和 $(p_{j},q_{j})_{j\notin \bm{P}}$，其中 $p_{b},q_{b}$ 仅在 $\operatorname{aux}=\bot$ 时定义。

#### 5.5.3 预签名模拟器 ($\mathcal{S}^{3}$)

预签名模拟器 $\mathcal{S}^{3}(sid,\bm{L},\bm{C},b,\bm{x}^{\setminus b},\operatorname{aux})$ 接受输入 $sid=(\dots,\bm{P},\bm{X},\bm{N},\bm{s},t)$，列表 $\bm{L}$ 和参与方集合 $\bm{C}\subsetneq \bm{P}$，索引 $b$ 和 $\bm{x}^{\setminus b}=(x_{j})_{j\neq b}$ 使得 $\mathcal{P}_{b}\notin \bm{C}$ 且 $g^{x_{j}}=X_{j}$ 对于 $j\neq b$，和辅助信息 $\operatorname{aux}=(R,\delta)$ 或 $\operatorname{aux}=(c,x_{b},k_{b},\gamma_{b})$。

**第 1 轮**。

1.  对于 $\mathcal{P}_{i}\in \bm{H}$，按照规定计算所有项目并移交 $(sid,i,K_{i},G_{i},\psi^{0}_{j,i})$ 给 $\mathcal{Z}$。
2.  对于 $\mathcal{P}_{b}$，采样设置
    $$K_{b} =\begin{cases}c^{k_{b}}\cdot \mathsf{enc}_{b}(0)&\text{如果 }\operatorname{aux}\neq \bot\\ \mathsf{enc}_{b}(0)&\text{否则}\end{cases}$$
    $$G_{b} =\begin{cases}c^{\gamma_{b}}\cdot \mathsf{enc}_{b}(0)&\text{如果 }\operatorname{aux}\neq \bot\\ \mathsf{enc}_{b}(0)&\text{否则}\end{cases}$$
    调用 ZK 模拟器 $\psi^{0}_{j,b}\gets \mathcal{S}^{\mathsf{enc}}_{j}(K_{b},\dots)$。
    移交 $(sid,b,K_{b},G_{b},\psi^{0}_{j,b})$ 给 $\mathcal{Z}$ 并将相关元组添加到 $\bm{L}$。

**第 2 轮**。

*   在接收到 $(sid,j,K_{j},G_{j},\dots)$ 时检索 $(k_{j},\gamma_{j})$
*   当获得所有相关元组时，执行：
    1.  对于 $\mathcal{P}_{i}\in \bm{H}$，将元组 $(sid,i,\Gamma_{i},D_{j,i},F_{j,i},\hat{D}_{j,i},\hat{F}_{j,i},\psi_{j,i},\hat{\psi}_{j,i},\psi^{\prime}_{j,i})$ 发送给 $\mathcal{Z}$，对于每个 $j\neq i$，其中所有值按照规定计算。

2.  对于 $\mathcal{P}_{b}$，采样 $\{(\alpha_{\ell,b},\hat{\alpha}_{\ell,b}\gets \mathcal{J}^{2})\}_{\ell\neq b}$ 并设置 $\hat{D}_{\ell,b}=\mathsf{enc}_{\ell}(\hat{\alpha}_{\ell,b})$ 和 $D_{\ell,b}=\mathsf{enc}_{j}(\alpha_{\ell,b})$，并且
    $$\hat{F}_{b,\ell} =\begin{cases}c^{k_{\ell}x_{b}-\hat{\alpha}_{\ell,b}}\cdot \mathsf{enc}_{b}(0)&\text{如果 }x_{b}\neq \bot\\ \mathsf{enc}_{b}(0)&\text{否则}\end{cases}$$
    $$F_{b,\ell} =\begin{cases}c^{k_{\ell}\gamma_{b}-\alpha_{\ell,b}}\cdot \mathsf{enc}_{b}(0)&\text{如果 }\gamma_{b}\neq \bot\\ \mathsf{enc}_{b}(0)&\text{否则}\end{cases}$$
    $$\Gamma_{b} =\begin{cases}g^{\gamma_{b}}&\text{如果 }\gamma_{b}\neq \bot\\ R^{\delta}\cdot g^{-\sum_{j\neq b}\gamma_{j}}&\text{否则}\end{cases}$$
    然后，对于每个 $j\neq b$，调用 ZK 模拟器
    $$\begin{cases}\psi_{j,b}\gets \mathcal{S}^{\sf aff}_{j}(D_{j,b},K_{j},\ldots),\\ \hat{\psi}_{j,b}\gets \mathcal{S}^{\sf aff}_{a}(\hat{D}_{j,b},K_{j},\ldots)\\ \psi^{\prime}_{j,b}\gets \mathcal{S}^{\sf log}_{j}(\Gamma_{b},g,G_{b},\ldots)\end{cases}$$
    移交元组 $(sid,b,\Gamma_{b},D_{j,b},F_{j,b},\hat{D}_{j,b},\hat{F}_{j,b},\psi_{j,b},\hat{\psi}_{j,b},\psi^{\prime}_{j,b})$ ，对于每个 $j\neq b$。将对应预言机调用的相关对添加到 $\bm{L}$。

**第 3 轮**。在接收到所有 $(sid,j,\Gamma_{j},D_{i,j},F_{i,j},\hat{D}_{i,j},\hat{F}_{i,j},\psi_{i,j},\hat{\psi}_{i,j},\psi^{\prime}_{i,j})$ 对于 $j\neq i$ 时，执行：

1.  如果 $\operatorname{aux}=(R,\delta)$，设置 $\Delta_{b}=g^{\delta}\cdot \prod_{j\neq b}\Gamma^{k_{j}}$ 并设置
    $$\begin{cases}\eta^{0}=\sum_{j\neq b}k_{j}\\ \eta^{1}=\sum_{j,i\neq b}k_{i}x_{j}+\sum_{j\neq b}\hat{\alpha}_{j,b}+\hat{\beta}_{j,b}\\ \delta_{b}=\delta-\sum_{j\neq b}\alpha_{j,b}+\beta_{j,b}+\sum_{i,j\neq b}k_{i}\gamma_{j}\end{cases}$$
    调用 ZK 模拟器 $\psi^{\prime\prime}_{j,b}\gets \mathcal{S}^{\sf log}_{j}(\Delta_{b},\Gamma,K_{b},\ldots)$，对于 $j\neq b$。移交 $\{(sid,i,\delta_{i},\Delta_{i},\psi^{\prime\prime}_{j,i})\}_{j\neq i}$ 给 $\mathcal{Z}$，其中 $\{\delta_{i},\Delta_{i},\psi^{\prime\prime}_{j,i}\}_{i\in \bm{H}}$ 按照规定计算。

2.  否则，检索 $\{\beta_{j,k},\hat{\beta}_{j,k}\}_{j,k}$，并设置
    $$\begin{cases}\chi_{b}=k_{b}x_{b}+\sum_{j\neq b}(k_{b}x_{j}-\hat{\beta}_{j,b})+(k_{j}x_{b}-\hat{\alpha}_{j,b})\\ \delta_{b}=k_{b}\gamma_{b}+\sum_{j\neq b}(k_{b}\gamma_{j}-\beta_{j,b})+(k_{j}\gamma_{b}-\alpha_{j,b})\end{cases} \quad .$$
    调用 ZK 模拟器 $\psi^{\prime\prime}_{j,b}\gets \mathcal{S}^{\sf log}_{j}(\Delta_{b},\Gamma,K_{b},\ldots)$，对于 $j\neq b$。移交 $\{(sid,i,\delta_{i},\Delta_{i},\psi^{\prime\prime}_{j,i})\}_{j\neq i}$ 给 $\mathcal{Z}$，其中 $\{\delta_{i},\Delta_{i},\psi^{\prime\prime}_{j,i}\}_{i\in \bm{H}}$ 按照规定计算。

**输出**。在接收到所有 $(sid,j,\delta_{j},\Delta_{j},\psi^{\prime\prime}_{i,j})$ 对于 $j\neq i$ 时，执行：

1.  如果 $\operatorname{aux}=(R,\delta)$，输出 $(sid,\eta^{0},\eta^{1})$ 和 $(sid,\ell,R,k_{i},\chi_{i})_{i\in \bm{H}}$。
2.  否则，设置 $R=\Gamma^{(\sum_{j}\delta_{j})^{-1}}$ 并输出 $(sid,\ell,R,k_{i},\chi_{i})_{i\notin \bm{C}}$。

## 致谢

本文的先前版本包含一个在 GGM 中增强不可伪造性的安全界限，该界限不准确（参见附录 E）。我们感谢 Victor Shoup 指出这一点并就增强不可伪造性进行进一步讨论。


## 参考文献

[1] D. Boneh, B. Lynn, and H. Shacham. Short signatures from the weil pairing. _J. Cryptology_, 17(4):297-319, 2004. doi: 10.1007/s00145-004-0314-9. URL https://doi.org/10.1007/s00145-004-0314-9.

[2] D. Boneh, R. Gennaro, and S. Goldfeder. Using level-1 homomorphic encryption to improve threshold DSA signatures for bitcoin wallet security. In _Progress in Cryptology - LATINCRYPT 2017 - 5th International Conference on Cryptology and Information Security in Latin America, Havana, Cuba, September 20-22, 2017, Revised Selected Papers_, pages 352-377, 2017.

[3] F. Boudot. Efficient proofs that a committed number lies in an interval. In B. Preneel, editor, _Advances in Cryptology — EUROCRYPT 2000_, pages 431-444, Berlin, Heidelberg, 2000. Springer Berlin Heidelberg. ISBN 978-3-540-45539-4.

[4] E. F. Brickell, D. Chaum, I. B. Damgard, and J. van de Graaf. Gradual and verifiable release of a secret (extended abstract). In C. Pomerance, editor, _Advances in Cryptology — CRYPTO '87_, pages 156-166, Berlin, Heidelberg, 1988. Springer Berlin Heidelberg. ISBN 978-3-540-48184-3.

[5] D. R. L. Brown. The exact security of ecdsa. Technical report, Advances in Elliptic Curve Cryptography, 2000.

[6] D. R. L. Brown. Generic groups, collision resistance, and ECDSA. _Des. Codes Cryptogr._, 35(1):119-152, 2005. URL http://www.springerlink.com/index/10.1007/s10623-003-6154-z.

[7] J. Camenisch and M. Michels. Proving in zero-knowledge that a number is the product of two safe primes. In _Advances in Cryptology - EUROCRYPT '99, International Conference on the Theory and Application of Cryptographic Techniques, Prague, Czech Republic, May 2-6, 1999, Proceeding_, pages 107-122, 1999. doi: 10.1007/3-540-48910-X_8. URL https://doi.org/10.1007/3-540-48910-X_8.

[8] J. Camenisch and V. Shoup. Practical verifiable encryption and decryption of discrete logarithms. In _Advances in Cryptology - CRYPTO 2003, 23rd Annual International Cryptology Conference, Santa Barbara, California, USA, August 17-21, 2003, Proceedings_, pages 126-144, 2003. doi: 10.1007/978-3-540-45146-4_8. URL https://doi.org/10.1007/978-3-540-45146-4_8.

[9] J. Camenisch, M. Drijvers, T. Gagliardoni, A. Lehmann, and G. Neven. The wonderful world of global random oracles. In J. B. Nielsen and V. Rijmen, editors, _Advances in Cryptology - EUROCRYPT 2018_, pages 280-312, Cham, 2018. Springer International Publishing. ISBN 978-3-319-78381-9.

[10] R. Canetti. Universally composable security: A new paradigm for cryptographic protocols. In _42nd Annual Symposium on Foundations of Computer Science, FOCS 2001, 14-17 October 2001, Las Vegas, Nevada, USA_, pages 136-145, 2001.

[11] R. Canetti. Universally composable signature, certification, and authentication. In _Proceedings. 17th IEEE Computer Security Foundations Workshop, 2004._, pages 219-233, 2004.

[12] R. Canetti. Universally composable security: A new paradigm for cryptographic protocols. _IACR Cryptology ePrint Archive_, 2000:67, 2020. URL http://eprint.iacr.org/2000/067.

[13] R. Canetti and S. Goldwasser. An efficient _Threshold_ public key cryptosystem secure against adaptive chosen ciphertext attack. In _Advances in Cryptology - EUROCRYPT '99, International Conference on the Theory and Application of Cryptographic Techniques, Prague, Czech Republic, May 2-6, 1999, Proceeding_, pages 90-106, 1999.

[14] R. Canetti, R. Gennaro, S. Jarecki, H. Krawczyk, and T. Rabin. Adaptive security for threshold cryptosystems. In _Advances in Cryptology - CRYPTO '99, 19th Annual International Cryptology Conference, Santa Barbara, California, USA, August 15-19, 1999, Proceedings_, pages 98-115, 1999.

[15] R. Canetti, S. Halevi, and A. Herzberg. Maintaining authenticated communication in the presence of break-ins. _J. Cryptology_, 13(1):61-105, 2000. doi: 10.1007/s001459910004. URL https://doi.org/10.1007/s001459910004.

[16] R. Canetti, Y. Lindell, R. Ostrovsky, and A. Sahai. Universally composable two-party and multi-party secure computation. In _Proceedings on 34th Annual ACM Symposium on Theory of Computing, May 19-21, 2002, Montreal, Quebec, Canada_, pages 494-503, 2002.

[17] R. Canetti, Y. Dodis, R. Pass, and S. Walfish. Universally composable security with global setup. In _Theory of Cryptography, 4th Theory of Cryptography Conference, TCC 2007, Amsterdam, The Netherlands, February 21-24, 2007, Proceedings_, pages 61-85, 2007.

[18] R. Canetti, A. Jain, and A. Scafuro. Practical UC security with a global random oracle. In G. Ahn, M. Yung, and N. Li, editors, _Proceedings of the 2014 ACM SIGSAC Conference on Computer and Communications Security, Scottsdale, AZ, USA, November 3-7, 2014_, pages 597-608. ACM, 2014. doi: 10.1145/2660267.2660374. URL https://doi.org/10.1145/2660267.2660374.

[19] R. Canetti, R. Gennaro, S. Goldfeder, N. Makriyannis, and U. Peled. Uc non-interactive, proactive, threshold ecdsa with identifiable aborts. Cryptology ePrint Archive, Report 2021/060, 2021. https://ia.cr/2021/060.

[20] G. Castagnos, D. Catalano, F. Laguillaumie, F. Savasta, and I. Tucker. Two-party ECDSA from hash proof systems and efficient instantiations. In _Advances in Cryptology - CRYPTO 2019 - 39th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 18-22, 2019, Proceedings, Part III_, pages 191-221, 2019.

[21] G. Castagnos, D. Catalano, F. Laguillaumie, F. Savasta, and I. Tucker. Bandwidth-efficient threshold ECDSA. _IACR Cryptology ePrint Archive_, 2020:84, 2020. URL https://eprint.iacr.org/2020/084.

[22] A. P. K. Dalskov, M. Keller, C. Orlandi, K. Shrishak, and H. Shulman. Securing DNSSEC keys via threshold ECDSA from generic MPC. _IACR Cryptology ePrint Archive_, 2019:889, 2019.

[23] I. Damgard and M. Koprowski. Practical threshold RSA signatures without a trusted dealer. In _Advances in Cryptology - EUROCRYPT 2001, International Conference on the Theory and Application of Cryptographic Techniques, Innsbruck, Austria, May 6-10, 2001, Proceeding_, pages 152-165, 2001.

[24] I. Damgard, T. P. Jakobsen, J. B. Nielsen, J. I. Pagter, and M. B. Ostergard. Fast threshold ecdsa with honest majority. Cryptology ePrint Archive, Report 2020/501, 2020. https://eprint.iacr.org/2020/501.

[25] Y. Desmedt. Society and group oriented cryptography: A new concept. In _Advances in Cryptology - CRYPTO '87, A Conference on the Theory and Applications of Cryptographic Techniques, Santa Barbara, California, USA, August 16-20, 1987, Proceedings_, pages 120-127, 1987. doi: 10.1007/3-540-48184-2_8. URL https://doi.org/10.1007/3-540-48184-2_8.

[26] Y. Desmedt and Y. Frankel. Threshold cryptosystems. In _Advances in Cryptology - CRYPTO '89, 9th Annual International Cryptology Conference, Santa Barbara, California, USA, August 20-24, 1989, Proceedings_, pages 307-315, 1989. doi: 10.1007/0-387-34805-0_28. URL https://doi.org/10.1007/0-387-34805-0_28.

[27] J. Doerner, Y. Kondi, E. Lee, and A. shelat. Secure two-party threshold ecdsa from ecdsa assumptions. _2018 IEEE Symposium on Security and Privacy (SP)_, 2018.

[28] J. Doerner, Y. Kondi, E. Lee, and A. Shelat. Threshold ECDSA from ECDSA assumptions: The multiparty case. In _2019 IEEE Symposium on Security and Privacy, SP 2019, San Francisco, CA, USA, May 19-23, 2019_, pages 1051-1066, 2019. doi: 10.1109/SP.2019.00024. URL https://doi.org/10.1109/SP.2019.00024.

[29] M. Fischlin. Communication-efficient non-interactive proofs of knowledge with online extractors. In _Advances in Cryptology - CRYPTO 2005: 25th Annual International Cryptology Conference, Santa Barbara, California, USA, August 14-18, 2005, Proceedings_, pages 152-168, 2005. doi: 10.1007/11535218_10. URL https://doi.org/10.1007/11535218_10.


[30] E. Fujisaki and T. Okamoto. Statistical zero knowledge protocols to prove modular polynomial relations. In B. S. Kaliski, editor, _Advances in Cryptology — CRYPTO '97_, pages 16-30, Berlin, Heidelberg, 1997. Springer Berlin Heidelberg. ISBN 978-3-540-69528-8.

[31] R. Gennaro and S. Goldfeder. Fast multiparty threshold ECDSA with fast trustless setup. In _Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security, CCS 2018, Toronto, ON, Canada, October 15-19, 2018_, pages 1179-1194, 2018. doi: 10.1145/3243734.3243859. URL https://doi.org/10.1145/3243734.3243859.

[32] R. Gennaro, S. Jarecki, H. Krawczyk, and T. Rabin. Robust threshold DSS signatures. _Inf. Comput._, 164(1):54-84, 2001. doi: 10.1006/inco.2000.2881. URL https://doi.org/10.1006/inco.2000.2881.

[33] R. Gennaro, S. Goldfeder, and A. Narayanan. Threshold-optimal DSA/ECDSA signatures and an application to bitcoin wallet security. In _Applied Cryptography and Network Security - 14th International Conference, ACNS 2016, Guildford, UK, June 19-22, 2016. Proceedings_, pages 156-174, 2016.

[34] S. Goldberg, L. Reyzin, O. Sagga, and F. Baldimtsi. Efficient noninteractive certification of RSA moduli and beyond. In _Advances in Cryptology - ASIACRYPT 2019 - 25th International Conference on the Theory and Application of Cryptology and Information Security, Kobe, Japan, December 8-12, 2019, Proceedings, Part III_, pages 700-727, 2019.

[35] O. Goldreich, S. Micali, and A. Wigderson. How to play any mental game or A completeness theorem for protocols with honest majority. In _Proceedings of the 19th Annual ACM Symposium on Theory of Computing, 1987, New York, New York, USA_, pages 218-229, 1987.

[36] S. Goldwasser and Y. Lindell. Secure multi-party computation without agreement. _J. Cryptology_, 18(3):247-287, 2005. doi: 10.1007/s00145-005-0319-z. URL https://doi.org/10.1007/s00145-005-0319-z.

[37] A. Gagol and D. Straszak. Threshold ecdsa for decentralized asset custody. Cryptology ePrint Archive, Report 2020/498, 2020. https://eprint.iacr.org/2020/498.

[38] A. Herzberg, S. Jarecki, H. Krawczyk, and M. Yung. Proactive secret sharing or: How to cope with perpetual leakage. In _Advances in Cryptology - CRYPTO '95, 15th Annual International Cryptology Conference, Santa Barbara, California, USA, August 27-31, 1995, Proceedings_, pages 339-352, 1995.

[39] S. Jarecki and J. Olsen. Proactive RSA with non-interactive signing. In _Financial Cryptography and Data Security, 12th International Conference, FC 2008, Cozumel, Mexico, January 28-31, 2008, Revised Selected Papers_, pages 215-230, 2008.

[40] Y. Kondi, B. Magri, C. Orlandi, and O. Shlomovits. Refresh when you wake up: Proactive threshold wallets with offline devices. _IACR Cryptology ePrint Archive_, 2019:1328, 2019. URL https://eprint.iacr.org/2019/1328.

[41] D. Kravitz. Digital signature algorithm. US Patent 5231668A, 1993.

[42] Y. Lindell. Fast secure two-party ECDSA signing. In _Advances in Cryptology - CRYPTO 2017 - 37th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 20-24, 2017, Proceedings, Part II_, pages 613-644, 2017. doi: 10.1007/978-3-319-63715-0_21. URL https://doi.org/10.1007/978-3-319-63715-0_21.

[43] Y. Lindell and G. Pe'er. Multiparty computation for approving digital transaction by utilizing groups of key shares. US Patent 20200084048A1, 2020.

[44] Y. Lindell and G. Pe'er. Multiparty computation of a digital signature of a transaction with advanced approval system. US Patent 20200084049A1, 2020.

[45] Y. Lindell, A. Nof, and S. Ranellucci. Fast secure multiparty ECDSA with practical distributed key generation and applications to cryptocurrency custody. _IACR Cryptology ePrint Archive_, 2018:987, 2018. URL https://eprint.iacr.org/2018/987.


[46] P. D. MacKenzie and M. K. Reiter. Two-party generation of DSA signatures. _Int. J. Inf. Sec._, 2(3-4):218-239, 2004. doi: 10.1007/s10207-004-0041-0. URL https://doi.org/10.1007/s10207-004-0041-0.

[47] National Institute of Standards and Technology. Digital signature standard (dss). Federal Information Processing Publication 186-4, 2013. URL https://doi.org/10.6028/NIST.PIPS.186-4.

[48] R. Ostrovsky and M. Yung. How to withstand mobile virus attacks (extended abstract). In _Proceedings of the Tenth Annual ACM Symposium on Principles of Distributed Computing, Montreal, Quebec, Canada, August 19-21, 1991_, pages 51-59, 1991. doi: 10.1145/112600.112605. URL https://doi.org/10.1145/112600.112605.

[49] C. Schnorr. Efficient signature generation by smart cards. _J. Cryptology_, 4(3):161-174, 1991. doi: 10.1007/BF00196725. URL https://doi.org/10.1007/BF00196725.

[50] V. Shoup. Practical threshold signatures. In _Advances in Cryptology - EUROCRYPT 2000, International Conference on the Theory and Application of Cryptographic Techniques, Bruges, Belgium, May 14-18, 2000, Proceeding_, pages 207-220, 2000.

[51] V. Shoup and R. Gennaro. Securing threshold cryptosystems against chosen ciphertext attack. _J. Cryptology_, 15(2):75-96, 2002. doi: 10.1007/s00145-001-0020-9. URL https://doi.org/10.1007/s00145-001-0020-9.

[52] J. van de Graaf and R. Peralta. A simple and secure way to show the validity of your public key. In _Advances in Cryptology - CRYPTO '87, A Conference on the Theory and Applications of Cryptographic Techniques, Santa Barbara, California, USA, August 16-20, 1987, Proceedings_, pages 128-134, 1987.


## A UC 模型概述

我们简要概述通用可组合（UC）安全框架 [12]；完整细节请参见那里。[^19] 在本节其余部分，我们提供框架的快速回顾。

[^19]: 具体来说，[12, 2020 年版本的第 2 节] 提出了框架简化变体的自包含说明。这个变体完全足以表示和分析本工作中的协议。

回忆一下，UC 框架内的安全性定义由两个主要组成部分组成：首先，需要指定**真实模型**，即表示实际执行环境、执行协议的实体的能力以及所考虑攻击者能力的计算模型。接下来，需要指定**理想功能**，即系统的预期行为，作为提供给系统的各种输入（合法和敌对的）以及对手收集的信息的函数。至关重要的是，“预期行为”既涉及关于所需输出的正确性属性，也涉及关于不应从外部观察的内部值的保密性属性。

UC 框架还提供了一个用于表示通信计算元素系统的基本形式模型，以及一种表达协议或分布式程序的方式。它还形式化了协议 $\pi$ **UC 实现**理想功能 $\mathcal{F}$ 的一般概念，其解释是从任何外部实体的角度来看，与协议 $\pi$ 交互并不比与理想功能 $\mathbb{F}$ 交互更差。该框架还允许一个通用的安全保持组合定理，该定理基本上保证任何使用 $\mathcal{F}$ 作为理想化组件设计的复合协议 $\rho$，即使在 $\mathcal{F}$ 的（可能许多）实例被 $\pi$ 的实例替换时，也将继续保留其所有安全属性。

**执行 $n$ 方协议 $\pi$ 的模型**。为了模拟本工作中的协议，我们考虑一个由以下 $n+2$ 个**机器**组成的系统，其中每个机器是一个具有指定程序和身份的计算元素（例如，交互式图灵机）。首先，我们有 $n$ 个具有程序 $\pi$ 和身份 $\mathcal{P}_{1},\ldots,\mathcal{P}_{n}$ 的机器。接下来，我们有一个表示对手的机器 $\mathcal{A}$ 和一个表示环境的机器 $\mathcal{Z}$。所有机器都在安全参数 $\kappa$ 上初始化，并且是 $\kappa$ 中的多项式。环境 $\mathcal{Z}$ 首先被激活，带有外部输入 $z$。$\mathcal{Z}$ 激活参与方，选择他们的输入并读取他们的输出。$\mathcal{A}$ 可以腐化参与方并指示他们向 $\mathcal{A}$ 泄露信息并执行任意指令。$\mathcal{Z}$ 和 $\mathcal{A}$ 在整个计算过程中自由通信。当环境终止时，真实过程终止。让 $\text{REAL}_{\pi,\mathcal{A},\mathcal{Z}}(1^{\kappa},z)$ 表示上述过程中环境的输出。

机器之间通过网络通信通过表示所考虑实际通信网络行为的子程序机器来建模。在这项工作中，为简单起见，我们假设参与方通过经过认证但有损的广播信道连接。这建模如下：参与方 $\mathcal{P}_{1},\ldots,\mathcal{P}_{n}$ 都有一个信道机器 $\mathcal{C}$ 作为子程序。当参与方 $\mathcal{P}_{i}$ 将消息 $m$ 输入到 $\mathcal{C}$ 时，$\mathcal{C}$ 记录 $(\mathcal{P}_{i},m)$，并向 $\mathcal{A}$ 报告 $(\mathcal{P}_{i},m)$。当某个其他参与方 $\mathcal{P}_{j}$ 查询 $\mathcal{C}$ 获取新消息时，$\mathcal{C}$ 通知 $\mathcal{A}$ 该查询，等待 $\mathcal{A}$ 确定所有到目前为止发送但尚未传递给 $\mathcal{P}_{j}$ 的消息的子集 $s$，并将此子集返回给 $\mathcal{P}_{j}$。

**理想过程**。理想过程与真实过程相同，除了现在机器 $\mathcal{P}_{1},\ldots,\mathcal{P}_{n}$ 不运行 $\pi$。相反，它们都将所有输入转发给一个子程序机器，称为**理想功能** $\mathcal{F}$。然后功能 $\mathcal{F}$ 在本地处理所有输入并将输出返回给 $\mathcal{P}_{1},\ldots,\mathcal{P}_{n}$。让 $\text{IDEAL}_{\mathcal{F},\mathcal{S},\mathcal{Z}}(1^{\kappa},z)$ 表示上述过程中环境的输出。

**定义 A.1**。我们说 $\pi$ UC 实现 $\mathcal{F}$ 如果对于每个真实对手 $\mathcal{A}$，存在一个理想对手 $\mathcal{S}$ 使得对于每个环境 $\mathcal{Z}$ 成立
$$\{\text{REAL}_{\pi,\mathcal{A},\mathcal{Z}}(1^{\kappa},z)\}_{z\in\{0,1\}^{*},\kappa\in\mathbb{N}}\stackrel{{ c}}{=}\{\text{IDEAL}_{\mathcal{F},\mathcal{S},\mathcal{Z}}(1^{\kappa},z)\}_{z\in\{0,1\}^{*},\kappa\in\mathbb{N}}.$$

**对手模型**。对手可以在整个计算过程中自适应地腐化参与方。一旦被腐化，参与方向对手报告其所有内部状态，并且从现在开始遵循对手的指令。我们还允许对手**离开**或**去腐化**参与方。去腐化的参与方恢复

执行原始协议，并且不再向对手报告其状态。尽管如此，对手知道去腐化参与方在去腐化时刻的完整内部状态。

我们注意到这种对手模型比“静态”变体更现实，在静态变体中腐化参与方的身份是预先确定的并且从不改变。

**处理全局功能**。如上所述，执行某个协议 $\pi$ 的基本模型仅涉及 $\pi$ 的单个实例的参与方，此外还有 $\mathcal{Z}$ 和 $\mathcal{A}$。这种限制大大简化了分析，但有时能够形式化协议 $\pi$ UC 实现理想功能 $\mathcal{F}$**在存在 $\mathcal{G}$ 的情况下**的概念很重要，其中 $\mathcal{G}$ 是某个独立于 $\pi$ 或 $\mathcal{F}$ 存在的全局构造。（例如，$\mathcal{G}$ 可以是一个参考字符串或一个 PKI。在我们的设置中，我们将密码哈希函数建模为**全局**随机预言机 $H$。这样，我们可以保证分析甚至捕捉到相同哈希函数不仅用于分析协议还用于系统其他部分的情况。）为此，我们稍微扩充计算模型，在理想和真实模型中包括 $\mathcal{G}$。

在 [17] 中展示了如何扩充通用 UC 框架的协议执行模型以纳入全局功能。然而在我们的情况下，即对于 [12, 第 2 节] 的基本模型，可以在普通 UC 框架内捕捉具有全局功能的 UC。具体来说，让 $\pi$ UC 实现理想功能 $\mathcal{F}$ 在存在全局功能 $\mathcal{G}$ 的情况下表示为让协议 $[\pi,\mathcal{G}]$ UC 实现协议 $[\mathcal{F},\mathcal{G}]$ 在普通 UC 框架内。这里 $[\pi,\mathcal{G}]$ 是 $n+1$ 方协议，其中机器 $\mathcal{P}_{1},\ldots,\mathcal{P}_{n}$ 运行 $\pi$，剩余机器运行 $\mathcal{G}$。协议 $[\mathcal{F},\mathcal{G}]$ 类似定义，即它是 $n+2$ 方协议，其中前 $n+1$ 个机器执行 $\mathcal{F}$ 的理想协议，剩余机器运行 $\mathcal{G}$。

## B 更多 Sigma 协议

### B.1 Schnorr 知识证明 ($\Pi^{\text{sch}}$)

图 15 是关系 $R_{\text{sch}}$ 中 $(X;x)$ 的 $\Sigma$-协议。

**图 15**（Schnorr 知识证明 - $\Pi^{\text{sch}}$）

*   **输入**：公共输入是 $(\mathbb{G},q,g,X)$，其中 $q=|\mathbb{G}|$ 且 $g$ 是 $\mathbb{G}$ 的生成元。证明者有秘密输入 $x$ 使得 $g^{x}=X$。

1.  证明者采样 $\alpha\gets\mathbb{F}_{q}$ 并将 $A=g^{\alpha}$ 发送给验证者。
2.  验证者回复 $e\gets\mathbb{F}_{q}$
3.  证明者将 $z=\alpha+ex\mod q$ 发送给验证者。

*   **验证**：验证者检查 $g^{z}=A\cdot X^{e}$。

### B.2 群元素与 Paillier 加密范围 ZK ($\Pi^{\text{log}}$)

图 16 是关系 $R_{\text{log}}$ 的 $\Sigma$-协议。

**图 16**（指数知识与 Paillier 加密 - $\Pi^{\text{log}}$）

*   **设置**：辅助安全双素数 $\hat{N}$ 和 Ring-Pedersen 参数 $s,t\in\mathbb{Z}^{*}_{\hat{N}}$。
*   **输入**：公共输入是 $(\mathbb{G},q,N_{0},C,X,g)$。证明者有秘密输入 $(x,\rho)$ 使得 $x\in \pm 2^{\ell}$，且 $C=(1+N_{0})^{x}\cdot \rho^{N_{0}}\mod N_{0}^{2}$ 且 $X=g^{x}\in\mathbb{G}$。

1.  证明者采样
    $$\alpha\gets \pm 2^{\ell+\varepsilon}\text{ 和 }\begin{cases}\mu\gets \pm 2^{\ell}\cdot \hat{N}\\ r\gets\mathbb{Z}^{*}_{\hat{N}}\\ \gamma\gets \pm 2^{\ell+\varepsilon}\cdot \hat{N}\end{cases} \text{，并计算 }\begin{cases}S=s^{x}t^{\mu}\mod \hat{N}\\ A=(1+N_{0})^{\alpha}\cdot R_{N_{0}}\mod N_{0}^{2}\\ Y=g^{\alpha}\in\mathbb{G}\\ D=s^{\alpha}t^{\gamma}\mod \hat{N}\end{cases} \text{，}$$
    并将 $(S,A,Y,D)$ 发送给验证者。
2.  验证者回复 $e\gets \pm q$
3.  证明者将 $(z_{1},z_{2},z_{3})$ 发送给验证者，其中
    $$\begin{cases}z_{1}&=\alpha+ex\\ z_{2}&=r\cdot \rho^{e}\mod N_{0}\\ z_{3}&=\gamma+e\mu\end{cases}.$$

*   **等式检查**：
    $$\begin{cases}(1+N_{0})^{z_{1}}\cdot z_{2}^{N_{0}}=A\cdot C^{e}\mod N_{0}^{2}\\ g^{z_{1}}=Y\cdot X^{e}\in\mathbb{G}\\ s^{z_{1}}t^{z_{3}}=D\cdot S^{e}\mod \hat{N}\end{cases}$$

*   **范围检查**：
    $$z_{1}\in \pm 2^{\ell+\varepsilon}$$
    证明保证 $x\in \pm 2^{\ell+\varepsilon}$。

**图 16**：指数知识与 Paillier 加密 – $\Pi^{\text{log}}$

### B.3 具有 Paillier 承诺的 Paillier 操作 ZK ($\Pi^{\mathsf{aff-p}}$)

图 17 是关系 $R_{\mathsf{aff-p}}$ 的 $\Sigma$-协议。

**图 17**（具有 Paillier 承诺的 Paillier 仿射操作 ZK 证明 - $\Pi^{\mathsf{aff-p}}$）

*   **设置**：辅助安全双素数 $\hat{N}$ 和 Ring-Pedersen 参数 $s,t\in\mathbb{Z}_{N}^{*}$。
*   **输入**：公共输入是 $(N_{0},N_{1},D,C,X,Y)$，其中 $q=|\mathbb{G}|$ 且 $g$ 是生成元 $\mathbb{G}$。证明者有秘密输入 $(x,y,\rho,\rho_{x},\rho_{y})$ 使得 $x\in \pm 2^{\ell}$, $y\in \pm 2^{\ell^{\prime}}$, $(1+N_{1})^{x}\rho_{x}^{N_{1}}=X$ 且 $(1+N_{1})^{y}\rho_{y}^{N_{1}}=Y$ 且 $D=C^{x}(1+N_{0})^{y}\cdot \rho^{N_{0}}\mod N_{0}^{2}$。

1.  证明者采样 $\alpha\gets \pm 2^{\ell+\epsilon}$ 和 $\beta\gets \pm 2^{\ell^{\prime}+\varepsilon}$ 和
    $$\begin{cases}r\gets\mathbb{Z}_{N_{0}}^{*},\\ r_{x},r_{y}\gets\mathbb{Z}_{N_{1}}^{*},\\ \gamma\gets \pm 2^{\ell+\varepsilon}\cdot \hat{N},\, m\gets \pm 2^{\ell}\cdot \hat{N}\quad\text{ 并计算}\\ \delta\gets \pm 2^{\ell+\varepsilon}\cdot \hat{N},\, \mu\gets \pm 2^{\ell}\cdot \hat{N}\end{cases}$$
    并将 $(A,B_{x},B_{y},E,S,F,T)$ 发送给验证者。
2.  验证者回复 $e\gets \pm q$。
3.  证明者将 $(z_{1},z_{2},z_{3},z_{4},w,w_{x},w_{y})$ 发送给验证者，其中
    $$\begin{cases}z_{1}=\alpha+ex\\ z_{2}=\beta+ey\\ z_{3}=\gamma+em\\ z_{4}=\delta+e\mu\\ w=r\cdot \rho^{\varepsilon}\mod N_{0}\\ w_{x}=r_{x}\cdot \rho_{x}^{\varepsilon}\mod N_{1}\\ w_{y}=r_{y}\cdot \rho_{y}^{\varepsilon}\mod N_{1}\end{cases}$$

*   **等式检查**：
    $$\begin{cases}C^{z_{1}}(1+N_{0})^{z_{2}}w^{N_{0}}=A\cdot D^{\varepsilon}\mod N_{0}^{2}\\ (1+N_{1})^{z_{1}}w_{x}^{N_{1}}=B_{x}\cdot X^{\varepsilon}\mod N_{1}^{2}\\ (1+N_{1})^{z_{2}}w_{y}^{N_{1}}=B_{y}\cdot Y^{\varepsilon}\mod N_{1}^{2}\\ s^{z_{1}}t^{z_{3}}=E\cdot S^{e}\mod \hat{N}\\ s^{z_{2}}t^{z_{4}}=F\cdot T^{e}\mod \hat{N}\end{cases}$$

*   **范围检查**：
    $$\begin{cases}z_{1}\in \pm 2^{\ell+\varepsilon}\\ z_{2}\in \pm 2^{\ell^{\prime}+\varepsilon}\end{cases}$$
    证明保证 $x\in \pm 2^{\ell+\varepsilon}$ 和 $y\in \pm 2^{\ell^{\prime}+\varepsilon}$。

**图 17**：具有 Paillier 承诺的 Paillier 仿射操作 ZK 证明 - $\Pi^{\mathsf{aff-p}}$

### B.4 无小因子证明 ($\Pi^{\sf fac}$)

图 18 是关系 $R_{\sf fac}$ 的 $\Sigma$-协议。

**图 18**（无小因子证明）

*   **设置**：辅助安全双素数 $\hat{N}$ 和 Ring-Pedersen 参数 $s,t\in\mathbb{Z}_{N}^{*}$。
*   **输入**：公共输入 RSA 模数 $N_{0}$。证明者有秘密输入 $(p,q)$ 使得 $p,q<\pm \sqrt{N_{0}}\cdot 2^{\ell}$。

1.  证明者采样
    $$\alpha,\beta\gets \pm 2^{\ell+\varepsilon}\cdot \sqrt{N_{0}}\text{ 和 }\begin{cases}\mu,\nu\gets \pm 2^{\ell}\cdot \hat{N}\\ \rho\gets \pm 2^{\ell}\cdot N_{0}\cdot \hat{N}\\ r\gets \pm 2^{\ell+\varepsilon}\cdot N_{0}\cdot \hat{N}\\ x,y\gets \pm 2^{\ell+\varepsilon}\cdot \hat{N}\end{cases} \text{，并计算 }\begin{cases}P=s^{p}t^{\mu},Q=s^{q}t^{\nu}\mod \hat{N}\\ A=s^{\alpha}t^{x}\mod \hat{N}\\ B=s^{\beta}t^{y}\mod \hat{N}\\ T=Q^{\alpha}t^{r}\mod \hat{N}\end{cases} \text{，}$$
    并将 $(P,Q,A,B,T,\rho)$ 发送给验证者。
2.  验证者回复 $e\gets \pm q$
3.  证明者设置 $\hat{\rho}=\rho-\nu p$ 并将 $(z,u,v)$ 发送给验证者，其中
    $$\begin{cases}z_{1}&=\alpha+ep\\ z_{2}&=\beta+eq\\ w_{1}&=x+e\mu\\ w_{2}&=y+e\nu\\ v&=r+e\hat{\rho}\end{cases}.$$

*   **等式检查**：验证者设置 $R=s^{N_{0}}t^{\rho}$ 并检查
    $$\begin{cases}s^{z_{1}}t^{w_{1}}=A\cdot P^{e}\mod \hat{N}\\ s^{z_{2}}t^{w_{2}}=B\cdot Q^{e}\mod \hat{N}\\ Q^{z_{1}}t^{v}=T\cdot R^{e}\mod \hat{N}\end{cases}$$

*   **范围检查**：
    $$z_{1},z_{2}\in \pm \sqrt{N_{0}}\cdot 2^{\ell+\varepsilon}$$
    证明保证每个 $p,q>2^{\ell}$（假设 $2^{2\ell+\varepsilon}\approx \sqrt{N_{0}}$）。

_特殊可靠性_。类似于先前的范围证明，提取器可以得到 $p,q,\mu,\nu,\hat{\rho}$ 来解承诺 $P$ 和 $Q$ 并且 $Q^{p}t^{\hat{\rho}}=s^{pq}t^{\nu p+\hat{\rho}}=s^{\hat{N}_{0}}t^{\rho}$。注意如果 $N_{0}\neq pq$，那么 Pedersen 的绑定属性被破坏，这反过来破坏了强 RSA。 $\square$

_HVZK_。采样 $P,Q\gets \langle t\rangle$。采样 $z_{1},z_{2}\gets \pm 2^{\ell+\varepsilon}\cdot \sqrt{N_{0}}$ 和 $w_{1},w_{2}\gets \pm 2^{\ell+\varepsilon}\cdot \hat{N}$ 和 $v\gets 2^{\ell+\varepsilon}\cdot N_{0}\cdot \hat{N}$ 和 $\rho\gets 2^{\ell}\cdot N_{0}\cdot \hat{N}$。最后，采样 $e$ 并相应地设置 $A,B$ 和 $T$。

## C 复杂度基准测试

我们在表 1 中提供我们协议组件的计算和通信成本分析，主要来自我们每个 NIZK 的成本分析，呈现在表 2 中。在表 3 和 4 中，我们显示预签名和辅助信息与密钥刷新的具体值，覆盖所有轮次（但不包括通信时间）对于比特币的 EC secp256k1（和相应参数）；我们的实现（用 C 编写）在具有 Intel Quad-Core i7-7600 CPU @ 2.80GHz 的 Ubuntu 桌面上运行 - 没有任何优化。

**表 1**：$n$ 个参与方中**每个**在所有轮次上的成本。$\mathbf{G},\mathbf{N},\mathbf{N}^{2}$ 表示在 EC 群 G 和环 $\mathbb{Z}_{N},\mathbb{Z}_{N^{2}}$ 中计算指数。通信对应于传输的 EC 元素量（$\mathbb{Z}_{N}$ 和 $\mathbb{Z}_{N^{2}}$ 元素分别计为 8,16 个 EC 元素以达到所需安全性）。哈希（随机预言机）调用微不足道，因此从计算成本中省略，但计为单个 EC 元素用于通信（这与实践一致）。

| 组件             | 轮次 | 计算                                   | 通信           |
| :--------------- | :--- | :------------------------------------- | :------------- |
| 密钥生成         | 3    | $(2+2n)\mathbf{G}$                     | 4              |
| 辅助信息与密钥刷新 | 2    | $(n+2n^{2})\mathbf{G}+(400+321n+3n^{2})\mathbf{N}+(n+2n^{2})\mathbf{N}^{2}$ | $3865+16n+55n^{2}$ |
| 预签名           | 3    | $(4+9n)\mathbf{G}+57n\mathbf{N}+(2+32n)\mathbf{N}^{2}$ | $35+444n$      |
| 签名             | 1    | 0                                      | 1              |

**表 2**：为确保 80 位统计安全性和 128 位计算安全性，我们在 $\Pi^{\text{mod}}$ 和 $\Pi^{\text{prm}}$ 中选择 $m=80$。在其余 ZK 范围证明中，$\ell,\ell^{\prime},\varepsilon$ 分别是椭圆曲线元素位长的 1, 5, 2 因子（例如对于比特币曲线 secp256k1，$\ell=256,\ell^{\prime}=1280,\varepsilon=512$）。

| ZK 证明    | 计算（证明者）        | 计算（验证者）        | 通信 |
| :--------- | :-------------------- | :-------------------- | :--- |
| $\Pi^{\text{sch}}$ | **1G**                | **2G**                | 2    |
| $\Pi^{\text{enc}}$ | $5\text{N}+\text{1N}^{2}$ | $3\text{N}+2\text{N}^{2}$ | 54   |
| $\Pi^{\text{log}}$ | $1\text{G}+5\text{N}+\text{1N}^{2}$ | $2\text{G}+3\text{N}+2\text{N}^{2}$ | 55   |
| $\Pi^{\text{aff-g}}$ | $1\text{G}+10\text{N}+3\text{N}^{2}$ | $2\text{G}+6\text{N}+5\text{N}^{2}$ | 112  |
| $\Pi^{\text{aff-p}}$ | $11\text{N}+4\text{N}^{2}$ | $6\text{N}+7\text{N}^{2}$ | 136  |
| $\Pi^{\text{mod}}$ | 160N                  | 80N                   | 1280 |
| $\Pi^{\text{prm}}$ | 80N                   | 160N                  | 1280 |

**表 3**：计算，以毫秒为单位

| $n$ | AI&KR | Pre-Signing |
| :-- | :---- | :---------- |
| 2   | 2228  | 801         |
| 3   | 3032  | 1183        |
| 4   | 3896  | 1566        |
| 5   | 4820  | 1949        |
| 6   | 5804  | 2332        |
| 7   | 6848  | 2715        |
| 8   | 7952  | 3098        |
| 9   | 9116  | 3864        |

**表 4**：通信，以千字节为单位

| $n$ | AI&KR | Pre-Signing |
| :-- | :---- | :---------- |
| 2   | 384   | 32          |
| 3   | 669   | 48          |
| 4   | 1030  | 64          |
| 5   | 1477  | 80          |
| 6   | 2010  | 96          |
| 7   | 2629  | 112         |
| 8   | 3334  | 128         |
| 9   | 4125  | 160         |


## D 数论与概率事实

**事实 D.1**。_假设 $\lambda^{N}=x^{k}\mod M$ 使得 $x\in\mathbb{Z}_{M}^{\ast}$。那么 $\lambda\in\mathbb{Z}_{M}^{\ast}$。_

证明。存在 $y\in\mathbb{Z}_{M}^{\ast}$ 使得 $xy=1\mod M$。因此 $\lambda\cdot(\lambda^{N-1}\cdot y^{k})=\lambda^{N}\cdot y^{k}=x^{k}y^{k}=1\mod M$。 $\square$

**事实 D.2**。_假设 $\lambda^{N}=x^{k}\mod M$，其中 $k$ 和 $N$ 互质且 $x\in\mathbb{Z}_{M}^{\ast}$。那么，存在 $y\in\mathbb{Z}_{M}^{\ast}$ 使得 $y^{k}=\lambda\mod M$。_

证明。因为 $k$ 和 $N$ 互质，存在 $u,v\in\mathbb{Z}$ 使得 $ku+Nv=1$。因此 $\lambda^{ku+Nv}=\lambda$，并且因此 $(\lambda^{u}\cdot x^{v})^{k}=\lambda^{ku}\cdot(\lambda^{N})^{v}=\lambda\mod M.$ 对于倒数第二个等式，我们应用事实 D.1 并且我们注意到 $\lambda^{u}$ 和 $x^{v}$ 在 $\mathbb{Z}_{M}^{\ast}$ 中是良定义的。 $\square$

**备注 D.3**。我们强调计算 $\lambda$ 在 $\mathbb{Z}_{M}^{\ast}$ 中的 $k$ 次根可以通过重复应用 Euclid 扩展算法和模 $M$ 指数运算高效完成，即计算 Bezout 系数 $(u,v)$，以及 $\lambda^{u}\mod M$ 和 $x^{v}\mod M$。

**事实 D.4**。_让 $a,c\in\mathbb{Z}$ 使得 $c\nmid a$。存在一个素数幂 $p^{d}$ 使得 $p^{d-1} \mid a$, $p^{d}\nmid a$ 且 $p^{d} \mid c$。_

证明。任何整除 $c$ 但不整除 $a$ 的素因子都可以（取 $d=1$）。如果不存在这样的 $p$，即如果 $c$ 的每个素因子都整除 $a$，让 $p_{1},\ldots,p_{n}$ 表示 $a$ 的素因子，并写 $a=\prod_{j=1}^{n}p_{i}^{d_{i}}$ 和 $c=\prod_{j=1}^{n}p_{j}^{d_{j}^{\prime}}$（可能某些 $d_{j}^{\prime}=0$）。如果 $d_{i}^{\prime}\leq d_{i}$，对于每个 $i$，那么 $c \mid a$。因此，存在 $i$ 使得 $d_{i}^{\prime}>d_{i}$，因此 $(p,d)=(p_{i},d_{i}+1)$ 可以。 $\square$

**事实 D.5**。_让 $N=pq$ 是两个奇素数的乘积并让 $x$, $y$ 和 $z\in\mathbb{Z}_{N}^{\ast}$ 使得 $x^{2}=y^{2}=z\mod N$ 且 $x\neq y,-y\mod N$。那么 $\gcd(x-y,N)\in\{p,q\}$。_

证明。让 $u$, $v$ 表示扩展 Euclid 算法的 Bezout 系数使得 $up+vq=1$ 并注意 $\gcd(p,v)=\gcd(q,u)=1$。通过中国剩余定理，因为 $x\neq y,-y\mod n$，得出 $x-y=2cuq\mod N$ 或 $x+y=2cvp\mod N$ 对于唯一元素 $c\in\mathbb{Z}_{p}^{\ast}$ 或 $c\in\mathbb{Z}_{q}^{\ast}$，分别。在任一情况下，主张成立。 $\square$

**事实 D.6**。_定义独立同分布的随机变量 $\boldsymbol{a},\boldsymbol{b}$ 从 $\pm R$ 中均匀随机选择，并让 $\delta\in \pm K$。成立 $\operatorname{SD}(\boldsymbol{a},\delta+\boldsymbol{b})\leq K/R$ 。 $\square$_

**事实 D.7**。_让 $N$ 是恰好两个任意素数 $p$ 和 $q$ 的乘积。让 $\boldsymbol{a}\gets\mathbb{Z}_{\ell\cdot N}$ 和 $\boldsymbol{b}\gets\mathbb{Z}_{\phi(N)}$。成立 $\operatorname{SD}(\boldsymbol{a}\mod \phi(N),\boldsymbol{b})\leq \frac{1}{\ell}$。_

证明。让 $Q=[\ell\cdot N/\phi(N)]$ 观察 $\operatorname{SD}(\boldsymbol{a}\mod \phi(N),\boldsymbol{b})\leq\Pr[\boldsymbol{a}\geq Q\cdot \phi(N)]$。因此，$\Pr[\boldsymbol{a}\geq Q\cdot \phi(N)]\leq\Pr[\boldsymbol{a}\geq \ell\cdot N-\phi(N)]=\phi(N)/(\ell\cdot N)\leq \frac{1}{\ell}$。 $\square$

## E 假设

**定义 E.1**（语义安全性）。我们说加密方案 $(\mathsf{gen},\mathsf{enc},\mathsf{dec})$ 是语义安全的，如果存在一个可忽略函数 $\nu(\cdot)$ 使得对于每个 $\mathcal{A}$ 成立 $\Pr[\mathsf{PaillierSec}(\mathcal{A},1^{\kappa})=1]\leq 1/2+\nu(\kappa)$。

**定义 E.2**（存在性不可伪造性）。我们说签名方案 $(\mathsf{gen},\mathsf{sign},\mathsf{vrfy})$ 是存在性不可伪造的，如果存在一个可忽略函数 $\nu(\cdot)$ 使得对于每个 $\mathcal{A}$ 和每个 $n\in\mathsf{poly}$ 成立 $\Pr[\mathsf{ExUnf}(\mathcal{A},n,1^{\kappa})=1]\leq \nu(\kappa)$。

**定义 E.3**（强 RSA）。我们说强 RSA 是困难的，如果存在一个可忽略函数 $\nu(\cdot)$ 使得对于每个 $\mathcal{A}$ 成立 $\Pr[\mathsf{sRSA}(\mathcal{A},1^{\kappa})=1]\leq \nu(\kappa)$。

### E.1 ECDSA 的增强存在性不可伪造性

#### E.1.1 $O(1)$-增强伪造

**引理 E.4**。_如果 ECDSA 是存在性不可伪造的，那么存在一个可忽略函数 $\nu$ 使得对于任何 PPTM $\mathcal{A}$，对于每个 $T\in\mathsf{poly}(\kappa)$ 和 $S\in O(1)$ 成立 $\Pr[\mathsf{EnhancedECDSA}(\mathcal{A},S,T,\kappa)=1]\in \nu(\kappa)$。_

**图 19**：语义安全实验 $\mathsf{PaillierSec}(\mathcal{A},1^{\kappa})$

**图 20**：存在性不可伪造性实验 $\mathsf{ExUnf}(\mathcal{A},\mathcal{H},n,1^{\kappa})$

**图 21**：强 RSA 实验 $\mathsf{sRSA}(\mathcal{A},1^{\kappa}))$

证明。让 $Q\in\mathsf{poly}$ 表示对手在每次签名查询之间进行的预言机查询次数。我们展示任何以显著概率 $p$ 赢得上述实验的对手产生一个高效对手，该对手在（普通）ECDSA 实验中以相同概率伪造签名，并且复杂度最多 $T\cdot Q^{S}\log(Q)\in\mathsf{poly}$ 查询。定义过程 $\mathcal{R}$ 具有对 $\mathcal{A}$ 的黑盒访问权限如下：均匀随机选择 $Q$ 个消息，表示为 $\{m^{\prime}_{i}\}_{i\in[Q]}$。然后均匀随机选择 $I^{*}\subset[Q]$ 大小为 $S$ 并为每个 $i^{*}\in I^{*}$ 调用（普通）ECDSA 预言机在 $m^{\prime}_{i^{*}}$ 上。写 $(R_{i^{*}},M_{i^{*}}=\mathcal{H}(m^{\prime}_{i^{*}}),\sigma_{i^{*}})$ 表示签名。接下来执行：

1.  将 $\{R_{i^{*}}\}_{i^{*}\in I^{*}}$ 交给 $\mathcal{A}$
2.  对于 $i=1\ldots Q$，每次 $\mathcal{A}$ 在 $m_{i}$ 上查询预言机时，交给 $(\texttt{answer},M_{i}=\mathcal{H}(m^{\prime}_{i}))$。
3.  当 $\mathcal{A}$ 在 $m_{j^{*}}$ 上查询 ECDSA 预言机时，执行
    *   如果 $j^{*}\neq i^{*}$ 回绕对手并重复。
    *   否则交给 $\sigma$。

观察 $\Pr[\forall i^{*},\ i^{*}=j^{*}]=\frac{1}{\binom{Q}{S}\cdot S!}\in O(1/Q^{S})$ 并且归约将在 $Q^{S}\cdot \log(Q)$ 次尝试后以接近 $1$ 的概率猜出每个 $j^{*}$。 $\square$

#### E.1.2 多重增强伪造：预备知识

**泛型群模型简要概述**。让 $(\mathbb{G},q,g)$ 表示一个群-阶-生成元元组并让 $\bm{G}\subset\{0,1\}^{*}$ 表示一个大小为 $q$ 的任意集合。泛型群模型通过一个随机双射映射 $\mu:\mathbb{G}\to\bm{G}$ 和一个群预言机 $\mathcal{O}:\bm{G}\times\bm{G}\to\bm{G}$ 定义，使得 $\mu(gh)=\mathcal{O}(\mu(g),\mu(h))$，对于每个 $g$, $h\in\mathbb{G}$。在群论术语中，$(\bm{G},\ast)$ 通过群同构 $\mu$ 同构于 $(\mathbb{G},\cdot)$，让 $\ast:\bm{G}\times\bm{G}\to\bm{G}$ 使得 $G\ast H=\mathcal{O}(G,H)$。

**EC 特定抽象**。我们进一步假设存在一个高效的 $2$-to-$1$ 映射 $\tau:\bm{G}\to\mathbb{F}_{q}$ 使得 $\tau(H)=\tau(H^{-1})$。我们进一步假设这个映射是高效可逆的 $\tau^{-1}:\mathbb{F}_{q}\to\{\{G,H\} \ \text{ s.t. } \ G,H\in\bm{G}\}\cup\{\bot\}$ 使得
$$\tau^{-1}:x\mapsto\begin{cases}\{H,H^{-1}\}&\text{如果 }\exists H \ \text{s.t. } \tau(H)=x\\ \bot&\text{否则}\end{cases}.$$

**图 22**：ECDSA 多重增强实验 EnhancedECDSA$(\mathcal{A},\mathcal{H},S,T,1^{\kappa})$

**符号 E.5**。定义 $\pi$ 使得 $\pi(X)=\emptyset$ 且 $\pi(X_{1},\ldots,X_{\ell})=(X_{1},X_{2},X_{1}X_{2}) \parallel \pi(X_{1}X_{2},X_{3}\ldots,X_{\ell})$，对于每个 $X,X_{1},\ldots X_{\ell}\in\boldsymbol{G}$。此外，对于 $X\in\boldsymbol{G}$ 和 $k\in\mathbb{F}_{q}$ 让 $(k_{i})_{i\leq q_{0}}$ 表示 $k$ 的二进制表示并定义
$$(X^{k})=\begin{cases}(X,X,X^{2},\ldots,X^{k/2},X^{k/2},X^{k})&\text{如果 }k\text{ 是 2 的幂}\\ (\operatorname{id}_{\boldsymbol{G}},X,X) \parallel (X^{k_{1}\cdot 2}) \parallel \ldots \parallel (X^{k_{q_{0}}\cdot 2^{q_{0}}}) \parallel \pi(X^{k_{0}},\ldots,X^{k_{q_{0}}2^{q_{0}}})&\text{否则}\end{cases},$$
其中 $q_{0}=\lfloor\log q\rfloor$。

让 $\mathcal{A}$ 表示一个算法，与 $\mathcal{O},\mathcal{S}^{\mathcal{O}}$ 在图 23 描述的实验中交互。考虑所有预言机调用的元组 $\boldsymbol{Q}=(Q_{1},\ldots,Q_{3t})=(X_{1},Y_{1},Z_{1},\ldots,X_{t},Y_{t},Z_{t})$，其中每对 $(X_{i},Y_{i})$ 表示 $\mathcal{O}$ 的输入，$Z_{i}$ 表示输出。

**定义 E.6**。我们说 $Q_{i}\in\{X_{j},Y_{j}\}$ 是**独立的**如果 $(Q_{i},\ldots)\notin \boldsymbol{S}$**并且** $Q_{i}\notin \{Q_{k},Q_{k}^{-1}\}$，对于每个 $k<i$。

**引理 E.7**（Brown [5, 6]）。_以下以压倒性概率成立对于每个与 $\mathcal{O}$ 交互的高效算法 $\mathcal{A}$。让 $B_{1}\ldots B_{\ell}$ 表示 $\boldsymbol{Q}$ 的独立元素并让 $Q\in \boldsymbol{Q}$。假设 $\mathcal{A}$ 输出两个序列 $(\alpha_{1},\ldots,\alpha_{\ell})$ 和 $(\alpha^{\prime}_{1},\ldots,\alpha^{\prime}_{\ell})$ 使得_
$$Q=\prod_{k\leq\ell}B_{k}^{\alpha_{k}}=\prod_{k\leq\ell}B_{k}^{\alpha^{\prime}_{k}}.$$
_那么，以概率 $1-1/\mathsf{poly}(q)$ 成立 $\alpha_{i}=\alpha^{\prime}_{i}\mod q$，对于每个 $i\in[\ell]$。此外，如果 $Q=Z_{j}$，那么 $\alpha_{1},\ldots,\alpha_{\ell}$ 从 $(X_{i},Y_{i},Z_{i})_{i<j}$，集合 $\boldsymbol{S}$，和随机预言机 $\mathcal{H}$ 高效可计算。_

#### E.1.3 多重增强伪造：证明

#### E.1.4 多重增强伪造：证明

**定理 E.8**。_让 $\mathcal{A}$ 是泛型群实验中具有增强签名预言机的算法，向随机预言机进行 $\ell$ 次查询。如果 $\mathcal{A}$ 以概率 $\alpha$ 输出伪造，那么存在 $\mathcal{B}$ 最多向随机预言机进行 $\ell$ 次查询使得_
$$\Pr_{e\gets F_{q}}[(x,y)\gets \mathcal{B}(e) \ \text{ s.t. } \ \mathcal{H}(x)/\mathcal{H}(y)=e]\geq \alpha/t^{2}-1/\mathsf{poly}(q),$$
_其中 $t$ 是向群和签名预言机查询总数的上限。_

**图 23**：具有增强签名预言机的泛型群中的 ECDSA 实验

上述定理通过直接平均论证从以下主张得出。

**主张 E.9**。_让 $\mathcal{A}$ 是泛型群实验中具有增强签名预言机的算法，向随机预言机进行 $\ell$ 次查询。如果 $\mathcal{A}$ 以概率 $\alpha$ 输出伪造，那么存在 $\mathcal{B}$ 最多向随机预言机进行 $\ell$ 次查询使得_
$$\Pr_{e_{1},\ldots,e_{t}\gets\mathbb{F}_{q}}[(x,y)\gets \mathcal{B}(e_{1},\ldots,e_{t}) \ :\ \exists i \ \text{ s.t. } \mathcal{H}(x)/\mathcal{H}(y)=e_{i}]\geq \alpha/t-1/\mathrm{poly}(q)$$
_其中 $t$ 是向群和签名预言机查询总数的上限。_

证明。使用上述符号，对于查询调用元组 $\boldsymbol{Q}=(Q_{1}\ldots)$ 和签名点 $\boldsymbol{S}$，让 $\phi:\boldsymbol{G}\rightarrow(\mathbb{F}_{q})^{*}$ 表示（高效）函数，该函数将群元素映射到它们关于 $\boldsymbol{Q}$ 的独立点的表示。即 $\phi(Q_{i})=\prod_{k}B_{k}^{\alpha_{k}}$ 由 $(Q_{j})_{j<i}$ 和 $\boldsymbol{S}$（唯一地，除了可忽略概率）确定。考虑图 24 中的归约并让 $\mathcal{A}$ 表示一个泛型伪造者。在实验结束时，假设 $\mathcal{A}$ 输出 $x\in\{0,1\}^{*}$ 和 $(F,\psi)$ 使得 $F=G^{\mathcal{H}(x)/\psi}\ast H^{\tau(F)/\psi}$ 且 $(\ldots,x,\ldots)\notin \boldsymbol{S}$。我们首先展示在以下情况（取决于 $F$）下，归约的转录本产生随机预言机中的“碰撞” $(x,y)$，形式为 $\mathcal{H}(x)/\mathcal{H}(y)=e$ 对于 $e\gets\mathbb{F}_{q}$。

**情况 1**。$F$ 在群操作模拟的项目 2 中返回给对手。使用图 24 中的符号，成立 $F=G^{\alpha}H^{\beta}=G^{\mathcal{H}(x)/\psi}H^{f/\psi}$ 对于 $f=\alpha^{-1}\mathcal{H}(y)e\beta$。因此 $f/\psi=\beta$ 且 $\mathcal{H}(x)/\psi=\alpha$ 并且我们推导出 $\mathcal{H}(x)/\mathcal{H}(y)=(\alpha\psi)\cdot(f^{-1}\alpha^{-1}e\beta)=e\cdot (\beta\psi f^{-1})=e$。

**情况 2**。$F$ 在群操作模拟的项目 3 中返回给对手，并且，对于 $(R,y,\sigma)\in \boldsymbol{S}$，成立 $F=G^{\alpha}H^{\beta}R^{\gamma}$ 且 $\alpha r-\beta m=0$。使用图 24 中的符号，成立 $F=G^{\alpha}H^{\beta}R^{\gamma}$ 对于 $\tau(F)=e\cdot r$ 且 $r=\tau(R)$。接下来，检索 $(R,y,\sigma)$ 从 $\boldsymbol{S}$ 使得 $R=G^{\mathcal{H}(y)/\sigma}H^{\tau(R)/\sigma}$ 并推导出 $F=G^{\alpha+\gamma m/\sigma}H^{\beta+\gamma r/\sigma}$。推导出 $\beta/r+\gamma/\sigma=f/\psi=\frac{er}{\psi}$，并且，因为 $\alpha=m\beta/r$，观察 $m(\beta/r+\gamma/\sigma)=\chi/\psi$ 这意味着 $e=\chi/m=\mathcal{H}(x)/\mathcal{H}(y)$。

**情况 3**。$F$ 由模拟器在签名操作模拟的项目 1 中选择。成立 $F=G^{\alpha}H^{\beta}R^{\gamma}=G^{\alpha+\gamma m/\sigma}H^{\beta+\gamma r/\sigma}=G^{\mathcal{H}(x)/\psi}H^{f/\psi}$ 对于 $\sigma$ 按照规定在签名操作模拟的项目 1 中设置即
$$\sigma=\gamma(wrf^{-1}-m)\cdot(\alpha-wf^{-1}\beta)^{-1}$$
因此，让 $\chi=\mathcal{H}(x)$，因为 $\chi/\psi=\alpha+\gamma m/\sigma$ 且 $f/\psi=\beta+\gamma r/\sigma$，得出
$$\begin{aligned}
\chi(\beta+\gamma r/\sigma)=f(\alpha+\gamma m/\sigma) &\Leftrightarrow\\
f\alpha-\chi\beta=\frac{\gamma}{\sigma}\cdot(\chi r-mf) &\Leftrightarrow\\
f\alpha-\chi\beta=\frac{\gamma}{\sigma}\cdot(\chi r-mf) &\Leftrightarrow\\
(f\alpha-\chi\beta)(\chi r-mf)^{-1}=(wrf^{-1}-m)^{-1}(\alpha-wf^{-1}\beta) &\Leftrightarrow\\
(w-\chi)(r\alpha-\beta m)=0
\end{aligned}$$
这意味着 $\mathcal{H}(x)/\mathcal{H}(y)=e$ 对于 $w=\mathcal{H}(y)e$ 因为 $r\alpha-\beta m\neq 0$。

**模拟不可区分性**。接下来我们展示如果对手在真实世界中伪造，那么对手在图 24 中输出伪造。足以论证（模拟的）点和签名满足与真实世界中相同的分布（当 $\mathcal{A}$ 与“真实”群和签名预言机交互时）。

注意，当模拟群预言机时，所有点只是 $\boldsymbol{G}$ 中的随机均匀元素（因为 $R\gets \tau^{-1}(r)$ 对于 $r\gets\mathbb{F}_{q}$）。非平凡部分是展示签名是良分布的。在真实世界中，$\sigma=k(\mathcal{H}(x)+rx)$ 对于随机 $k$，所以签名只是 $\mathbb{F}_{q}$ 中的均匀元素（因为在 GGM 中元素 $k$ 和 $r=\tau(R)$ 是独立的）。我们展示 sigmas 在图 24 中是（几乎）均匀元素通过展示映射 $w\mapsto \gamma(wr\zeta^{-1}-m)\cdot(\alpha-w\zeta^{-1}\beta)^{-1}$ 是单射当 $\gamma\zeta\neq 0$

且 $r\alpha-m\beta\neq 0$。所以，对于 $u,v\in\mathbb{F}_{q}$，如果
$$\begin{aligned}
\gamma(ur\zeta^{-1}-m)\cdot(\alpha-u\zeta^{-1}\beta)^{-1} &=\gamma(vr\zeta^{-1}-m)\cdot(\alpha-v\zeta^{-1}\beta)^{-1} \Leftrightarrow \quad (1)\\
(ur\zeta^{-1}-m)\cdot(\alpha-v\zeta^{-1}\beta) &=(vr\zeta^{-1}-m)\cdot(\alpha-u\zeta^{-1}\beta) \Leftrightarrow \quad (2)\\
ur\alpha+mv\beta &=vr\alpha+mu\beta \Leftrightarrow \quad (3)\\
(u-v)(r\alpha-m\beta) &=0 \quad (4)
\end{aligned}$$
因此，对于随机 $w$，（模拟的）签名在 $\mathbb{F}_{q}\setminus\{\alpha\zeta\beta^{-1}\}$ 上是均匀的。[^20] 由引理 E.7，我们得出结论，如果 $\mathcal{A}$ 在真实世界中输出伪造，那么 $\mathcal{A}$ 以概率 $1-1/\text{poly}(q)$ 在图 24 中输出伪造。

[^20]: $\alpha\zeta\beta^{-1}$ 对应函数未定义的点。

**总结一切**。我们通过计算转录本包含随机预言机中形式为 $\mathcal{H}(x)/\mathcal{H}(y)=e$ 的“碰撞”的概率来总结。让 $(F,x,\psi)$ 表示 $\mathcal{A}$ 的伪造。如果 $F$ 在群操作模拟的项目 2 中返回给 $\mathcal{A}$（情况 1），那么显然转录本产生合适的碰撞。其他两种情况稍微复杂，因为归约需要猜测尝试的伪造。例如，在群操作模拟的项目 3 中（情况 2），归约选择一个随机（预签名）点 $R$，希望 $(F,x,\psi)$ 与 $(R,\operatorname{msg},\sigma)\in \mathcal{S}$ 一起将导致“碰撞”。类似地，在签名操作模拟的项目 1 中（情况 3），归约选择一个随机 $Z$，希望 $F=Z$。

更详细地说，假设 $F$ 首先计算为形式 $G^{\alpha}H^{\beta}\prod_{i}R_{i}^{\gamma_{i}}$ 并推导出关于 $F=G^{\alpha^{\prime}}H^{\beta^{\prime}}R^{\gamma^{\prime}}$ 的以下内容，其中 $R$ 表示 $\{R_{i}\}_{i}$ 中最后签名的点 $m=\mathcal{H}(\operatorname{msg})$。如果 $\alpha^{\prime}r+\beta^{\prime}m=0$，那么 $R$ 由归约在群操作的项目 3 中以至少 $1/t$ 的概率选择（因为 $t$ 是群查询数的上限），或者，如果 $\alpha^{\prime}r+\beta^{\prime}m\neq 0$，那么 $F$ 由归约在签名操作的项目 1 中以至少 $1/t$ 的概率选择（因为 $t$ 是预签名查询数的上限）。

总之，成立转录本以概率 $\alpha/t-\frac{1}{\text{poly}(q)}$ 包含合适的碰撞。 $\square$

*   **输入**：$e_{1},\ldots,e_{t}\in\mathbb{Z}_{q}$ 和 $\lambda\in\mathbb{N}$ 和 PPTM $\mathcal{A}$。
    *   **初始化**：$\mathtt{ctr}=1$。

*   **群操作模拟**：
    *   在从 $\mathcal{A}$ 接收到群预言机的输入 $(X,Y)$ 时，执行：
        1.  如果 $\phi(Z)=\phi(X\ast Y)$ 对于某个 $Z\in \boldsymbol{Q}$，返回 $Z$。
        2.  否则如果 $\phi(X\ast Y)=G^{\alpha}H^{\beta}$ 对于 $\alpha,\beta\neq 0$ 执行：
            (a) 采样 $y\gets\mathbb{F}_{q}$ 并设置 $w=e_{\mathtt{ctr}}\cdot \mathcal{H}(y)$ 和 $Z\gets \tau^{-1}(\alpha^{-1}w\beta)$。如果 $\tau^{-1}(\alpha^{-1}w\beta)=$$\bot$，重复上述步骤。否则，递增 $\mathtt{ctr}$ 并继续。
            (b) 返回 $Z$。
        3.  否则如果 $\phi(X\ast Y)=G^{\alpha}H^{\beta}\prod_{i\leqslant\ell}R_{i}^{\gamma_{i}}$ 对于 $R_{i}\in \boldsymbol{R}$ 且 $\gamma_{i}\neq 0$ 执行：
            (a) 选择 $i\gets[\ell]$ 并设置 $Z\gets \tau^{-1}(e_{\mathtt{ctr}}\cdot r_{i})$，对于 $r_{i}=\tau(R_{i})$。如果 $\tau^{-1}(e_{\mathtt{ctr}}\cdot r_{i})=$$\bot$，重复上述步骤。否则，递增 $\mathtt{ctr}$ 并继续。
            (b) 返回 $Z$。
        4.  否则返回 $Z\gets \boldsymbol{G}$。设置 $\boldsymbol{Q}=\boldsymbol{Q} \parallel (X,Y,Z)$。

*   **签名操作模拟**：
    *   在从 $\mathcal{A}$ 接收到签名预言机的 $\mathtt{pubkey}$ 时，返回 $(G,H)\gets \boldsymbol{G}^{2}$。
    *   在从 $\mathcal{A}$ 接收到签名预言机的 $\mathtt{put-request}$ 时，返回 $R\gets \boldsymbol{G}$，并将 $R$ 添加到 $\boldsymbol{R}$。
    *   在从 $\mathcal{A}$ 接收到签名预言机的 $(\mathtt{sign},\mathtt{msg},R)$ 时，如果 $R\in \boldsymbol{R}$ 设置 $m=\mathcal{H}(\mathtt{msg})$ 和 $r=\tau(R)$，并执行：
        1.  选择 $Z\gets \boldsymbol{Q}$ 使得 $\phi(Z)=G^{\alpha}H^{\beta}R^{\gamma}$，对于 $\gamma\neq 0$ 且 $\beta m-r\alpha\neq 0$。
            (a) 采样 $y$ 并设置 $w=e_{\mathtt{ctr}}\cdot \mathcal{H}(y)$ 和 $\sigma=\gamma(wr\zeta^{-1}-m)\cdot(\alpha-w\zeta^{-1}\beta)^{-1}$，对于 $\zeta=\tau(Z)$。递增 $\mathtt{ctr}$。
            (b) 如果不存在这样的 $Z$ 设置 $\sigma\gets\mathbb{F}_{q}$。
        2.  返回 $\sigma$ 并从 $\boldsymbol{R}$ 中移除 $R$，并将 $(R,\mathtt{msg},\sigma)$ 添加到 $\boldsymbol{S}$。设置 $\boldsymbol{Q}=\boldsymbol{Q} \parallel (G^{m/\sigma}) \parallel (H^{r/\sigma}) \parallel (G^{m/\sigma},H^{r/\sigma},R)$。

**图 24**：具有增强签名预言机的泛型群中的归约