# 预备知识详解

本文档详细讲解论文第2章"预备知识"部分的内容。

---

## 一、符号约定

### 1.1 基本数学符号

```
G       - 素数阶 q 的群（椭圆曲线上的点集）
Fq      - 具有 q 个元素的有限域（整数模 q）
Z       - 整数集 {..., -2, -1, 0, 1, 2, ...}
N       - 自然数集 {0, 1, 2, 3, ...}

φ(N)    - 欧拉函数：小于 N 且与 N 互质的正整数个数
gcd(a,b) - a 和 b 的最大公约数
```

### 1.2 算法表示

```
无衬线字母：enc, dec, gen, sign, vrfy
  → 表示具体的算法/函数

书法体字母：S, A, P, V
  → 表示抽象的算法（如模拟器、攻击者、证明者、验证者）
```

### 1.3 公共值与秘密值

```
秘密值：小写字母
  p, q, x, k, ...（私钥、随机数等）

公共值：大写字母
  A, B, N, X, ...（公钥、模数等）

混合元组用分号分隔：
  (N; p, q)  而不是  (N, p, q)
   ↑          ↑
  公共       秘密

例子：
  RSA 模数 N = p·q
  (N; p, q) 表示 N 是公开的，p 和 q 是秘密的
```

### 1.4 特殊符号

```
⟨t⟩ = {t^k mod N : k ∈ Z}
    = 由 t 生成的乘法群
    = {1, t, t², t³, ..., t^(ord(t)-1)}

±ℓ = {-|ℓ|, ..., -1, 0, 1, ..., |ℓ|}
   = 从 -|ℓ| 到 |ℓ| 的整数区间

例子：±3 = {-3, -2, -1, 0, 1, 2, 3}

x ← X
  如果 X 是集合：从 X 中均匀随机采样 x
  如果 X 是分布：按分布 X 采样 x
```

---

## 二、核心定义

### 2.1 Paillier-Blum 整数

```
定义：N 是 Paillier-Blum 整数 当且仅当：

  1. N = p·q，其中 p, q 是素数
  2. p ≡ 3 (mod 4) 且 q ≡ 3 (mod 4)
  3. gcd(N, φ(N)) = 1

解释：

条件1：N 是两个素数的乘积（RSA 模数）

条件2：p 和 q 都是 4k+3 形式的素数
  例：p = 7 (7 = 4×1 + 3)
      q = 11 (11 = 4×2 + 3)
  
  为什么？这确保 -1 在 Z*_N 中是二次非剩余
         有助于某些零知识证明的构造

条件3：N 和 φ(N) 互质
  φ(N) = (p-1)(q-1)
  
  这确保 φ(N) 在 Z_N 中有逆元
  Paillier 解密需要计算 φ(N)^(-1) mod N
```

#### 示例：验证 Paillier-Blum 整数

```
取 p = 7, q = 11

检查条件1：N = 7 × 11 = 77 ✓（是两素数之积）

检查条件2：
  7 mod 4 = 3 ✓
  11 mod 4 = 3 ✓

检查条件3：
  φ(N) = (7-1)(11-1) = 6 × 10 = 60
  gcd(77, 60) = 1 ✓（互质）

∴ N = 77 是 Paillier-Blum 整数
```

### 2.2 Paillier 加密系统

```
三元组 (gen, enc, dec)：

┌─────────────────────────────────────────────────────────────┐
│ gen(1^κ) → (N; p, q)                                        │
│   生成两个 κ/2 比特的素数 p, q                                │
│   公钥 pk = N = p·q                                         │
│   私钥 sk = (p, q)                                          │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ enc_pk(m; ρ) = (1+N)^m · ρ^N mod N²                         │
│   m ∈ Z_N（明文）                                            │
│   ρ ← Z*_N（随机数，与 N 互质）                               │
│   输出密文 c ∈ Z_{N²}                                        │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ dec_sk(c) = ((c^φ(N) mod N² - 1) / N) · μ mod N             │
│   其中 μ = φ(N)^(-1) mod N                                   │
│   输出明文 m                                                 │
└─────────────────────────────────────────────────────────────┘
```

#### Paillier 加密计算示例

```
设定：p = 3, q = 11（满足 Paillier-Blum：3 ≡ 11 ≡ 3 mod 4）
      N = 33, N² = 1089

第一步：计算辅助值
  φ(N) = (3-1)(11-1) = 2 × 10 = 20
  μ = φ(N)^(-1) mod N = 20^(-1) mod 33

  找 20 的逆元：20 × x ≡ 1 (mod 33)
  20 × 5 = 100 = 3×33 + 1 ≡ 1 (mod 33)
  ∴ μ = 5

第二步：加密
  明文 m = 10
  随机数 ρ = 4（验证 gcd(4, 33) = 1 ✓）

  c = (1 + N)^m · ρ^N mod N²
    = 34^10 · 4^33 mod 1089

  计算 34^10 mod 1089（二进制快速幂）：
    34^1 = 34
    34^2 = 1156 mod 1089 = 1156 - 1089 = 67
    34^4 = 67^2 = 4489 mod 1089 = 4×1089 + 133 = 133
    34^8 = 133^2 = 17689 mod 1089 = 16×1089 + 265 = 265
    34^10 = 34^8 × 34^2 = 265 × 67 mod 1089
          = 17755 mod 1089 = 16×1089 + 331 = 331

  计算 4^33 mod 1089（二进制快速幂）：
    4^1 = 4
    4^2 = 16
    4^4 = 256
    4^8 = 65536 mod 1089 = 60×1089 + 196 = 196
    4^16 = 196^2 = 38416 mod 1089 = 35×1089 + 301 = 301
    4^32 = 301^2 = 90601 mod 1089 = 83×1089 + 214 = 214
    4^33 = 4^32 × 4^1 = 214 × 4 = 856

  c = 331 × 856 mod 1089
    = 283336 mod 1089
    = 260×1089 + 196
    = 196

  ∴ 密文 c = 196

第三步：解密
  c^φ(N) mod N² = 196^20 mod 1089

  计算 196^20 mod 1089（二进制快速幂）：
    196^1 = 196
    196^2 = 38416 mod 1089 = 35×1089 + 301 = 301
    196^4 = 301^2 = 90601 mod 1089 = 83×1089 + 214 = 214
    196^8 = 214^2 = 45796 mod 1089 = 42×1089 + 58 = 58
    196^16 = 58^2 = 3364 mod 1089 = 3×1089 + 97 = 97
    196^20 = 196^16 × 196^4 = 97 × 214 mod 1089
           = 20758 mod 1089 = 19×1089 + 67 = 67

  L(c^φ(N) mod N²) = (67 - 1) / N = 66 / 33 = 2

  m = L(...) × μ mod N = 2 × 5 mod 33 = 10

  ∴ 解密结果 m = 10 ✓（与原始明文一致！）
```

### 2.3 ECDSA 定义

```
参数：
  (G, g, q) - 群、生成元、阶
  H: M → Fq - 哈希函数（消息空间到有限域）

密钥生成 gen(G, q, g) → (X; x)：
  x ← Fq        （随机采样私钥）
  X = g^x       （计算公钥）

  公开：X
  秘密：x

签名 sign_x(msg; k) → (r, σ)：
  m = H(msg)                    （哈希消息）
  k ← Fq                        （随机采样 nonce）
  R = g^(k^(-1))                （计算椭圆曲线点）
  r = R|_{x-axis} mod q         （取 x 坐标）
  σ = k(m + rx) mod q           （计算签名值）

  输出：(r, σ)

验证 vrfy_X(msg, (r,σ)) → {0, 1}：
  m = H(msg)
  检验：r = (g^m · X^r)^(σ^(-1))|_{x-axis} mod q

  如果等式成立返回 1（接受），否则返回 0（拒绝）
```

#### ECDSA 正确性验证

```
为什么验证等式成立？

已知：σ = k(m + rx)

验证等式右边：
  (g^m · X^r)^(σ^(-1))
  = (g^m · g^(xr))^(σ^(-1))
  = g^((m + xr) · σ^(-1))
  = g^((m + xr) · (k(m + rx))^(-1))
  = g^((m + xr) / (k(m + xr)))
  = g^(1/k)
  = g^(k^(-1))
  = R

取 x 坐标：R|_{x-axis} = r ✓
```

---

## 三、NP 关系（零知识证明的对象）

### 3.1 什么是 NP 关系？

```
NP 关系 R 是一个集合，包含形如 (x, w) 的对：
  x = 公开陈述（statement）
  w = 秘密见证（witness）

零知识证明的目标：
  证明者知道 w 使得 (x, w) ∈ R
  但不透露 w 的任何信息
```

### 3.2 Schnorr 关系 R_sch

```
R_sch = {((G,g), X; x) | X = g^x}

公开：(G, g, X)  - 群、生成元、公钥
秘密：x          - 私钥

含义：证明"我知道 X 的离散对数"
```

### 3.3 Paillier 加密范围关系 R_enc

```
R_enc = {(N₀, I, C; x, ρ) | x ∈ I ∧ C = (1+N₀)^x · ρ^N₀ mod N₀²}

公开：N₀ - Paillier 公钥
      I  - 范围区间（如 ±2^256）
      C  - 密文

秘密：x  - 明文
      ρ  - 随机数

含义：证明"密文 C 的明文 x 在范围 I 内"
```

### 3.4 群元素与 Paillier 加密范围关系 R_log

```
R_log = {((G,N), I, C, X, g; x, ρ) |
         x ∈ I ∧
         C = (1+N)^x · ρ^N mod N² ∧
         X = g^x}

公开：G, N - 群、Paillier 模数
      I   - 范围区间
      C   - Paillier 密文
      X   - 群元素
      g   - 群生成元

秘密：x  - 明文/指数
      ρ  - 随机数

含义：证明"X 的指数 = C 的明文 = x，且 x 在范围 I 内"

用途：确保 Paillier 密文中的值与公开的群元素一致
```

### 3.5 Paillier 仿射操作范围关系 R_aff-g

```
R_aff-g = {((G,g,N₀,N₁), I, J, C, C₀, Y, X; ε, δ, r, ρ) |
           (ε, δ) ∈ I × J ∧
           C = C₀^ε · (1+N₀)^δ · r^N₀ mod N₀² ∧
           Y = (1+N₁)^δ · ρ^N₁ mod N₁² ∧
           X = g^ε}

解释：
  C₀ 是某个值 a 的密文
  C = C₀^ε · enc(δ) = enc(ε·a + δ)  ← 仿射变换！

  证明的内容：
    1. ε 在范围 I 内
    2. δ 在范围 J 内
    3. X = g^ε（ε 同时是 X 的指数）
    4. Y = enc(δ)（δ 同时被加密）
```

### 3.6 Paillier 仿射操作范围关系 R_aff-p

```
R_aff-p 与 R_aff-g 类似，但：
  X = (1+N₁)^ε · μ^N₁ mod N₁²

区别：
  R_aff-g: X 是群元素 g^ε
  R_aff-p: X 是 Paillier 密文 enc(ε)
```

---

## 四、辅助关系

### 4.1 Paillier-Blum 模数关系 R_mod

```
R_mod = {(N; p, q) |
         p, q 是素数 ∧
         p, q ≡ 3 (mod 4) ∧
         N = pq ∧
         gcd(N, φ(N)) = 1}

用途：证明"我知道 N 的因子分解，且 N 是合法的 Paillier 模数"
```

### 4.2 Ring-Pedersen 参数关系 R_prm

```
R_prm = {(N, s, t; λ) | s = t^λ mod N}

公开：N, s, t
秘密：λ

含义：证明"s 在由 t 生成的群中"
      即 s 是 t 的某个幂次

用途：确保 Ring-Pedersen 承诺参数是正确生成的
```

### 4.3 无小因子模数关系 R_fac

```
R_fac = {(ℓ, N; p, q) | N = pq ∧ p, q > 2^ℓ}

公开：ℓ, N
秘密：p, q

含义：证明"N 的两个因子都大于 2^ℓ"

用途：防止攻击者使用有小因子的模数
      小因子会导致某些攻击可行
```

---

## 五、Σ-协议（Sigma 协议）

### 5.1 什么是 Σ-协议？

```
Σ-协议是一种特殊的三轮交互式零知识证明协议。

为什么叫 Σ？
  消息流向像希腊字母 Σ：

  证明者 P                验证者 V
     │                       │
     │ ───── A（承诺）─────→ │  第1轮
     │                       │
     │ ←──── e（挑战）────── │  第2轮
     │                       │
     │ ───── z（响应）─────→ │  第3轮
     │                       │
                        接受/拒绝
```

### 5.2 Σ-协议的组成

```
Σ-协议 Π = (P₁, P₂, V₁, V₂)

P₁(κ, τ) → A
  输入：安全参数 κ = |x|，随机数 τ
  输出：承诺 A

V₁() → e
  输出：随机挑战 e

P₂(x, w, τ, e) → z
  输入：陈述 x，见证 w，随机数 τ，挑战 e
  输出：响应 z

V₂(x, A, e, z) → b ∈ {0, 1}
  输入：陈述、承诺、挑战、响应
  输出：接受(1) 或 拒绝(0)
```

### 5.3 安全性质

```
1. 完备性（Completeness）
   如果 (x, w) ∈ R，诚实执行协议一定被接受

   P[V₂(x, A, e, z) = 1 | (x,w) ∈ R] ≈ 1

2. 可靠性（Soundness）
   如果 x 不在关系中，作弊者成功概率可忽略

   P[V₂(x, A, e, z) = 1 | ∀w: (x,w) ∉ R] ≈ 0

3. 诚实验证者零知识（HVZK）
   存在模拟器 S，能在不知道 w 的情况下
   生成与真实协议不可区分的 (A, e, z)
```

### 5.4 特殊可靠性

```
定义：存在提取器 E，给定两个接受的转录本
      (A, e, z) 和 (A, e', z')（e ≠ e'）
      能够提取出见证 w'

形式化：
  如果 V₂(x, A, e, z) = V₂(x, A, e', z') = 1 且 e ≠ e'
  那么 w' ← E(x, A, e, e', z, z') 满足 (x, w') ∈ R

意义：
  这比普通可靠性更强
  保证了证明者确实"知道"见证
  （而不只是能通过协议）
```

### 5.5 设置参数

```
某些 Σ-协议需要设置参数 σ

例如范围证明需要：
  σ = (N, s, t)
  N = RSA 模数
  s, t = Ring-Pedersen 参数

带设置的协议：Π^σ = (S, P₁, P₂, V₁, V₂)
  S 是生成 σ 的设置算法

重要：在门限签名中，设置参数由验证者自己生成
     （不需要可信第三方）
```

### 5.6 本协议使用的 Σ-协议

```
┌─────────────────────────────────────────────────────────────┐
│  协议名称        │  证明的关系    │  是否需要设置          │
├─────────────────────────────────────────────────────────────┤
│  Π_sch          │  R_sch        │  否                    │
│  Π_mod          │  R_mod        │  否（A 为空）           │
│  Π_prm          │  R_prm        │  否                    │
│  Π^σ_enc        │  R_enc        │  是 (N, s, t)          │
│  Π^σ_log        │  R_log        │  是 (N, s, t)          │
│  Π^σ_aff-g      │  R_aff-g      │  是 (N, s, t)          │
│  Π^σ_aff-p      │  R_aff-p      │  是 (N, s, t)          │
└─────────────────────────────────────────────────────────────┘

符号约定：Π^j_* 表示使用 Pⱼ 的设置参数的协议
```

---

## 六、ZK 模块（Fiat-Shamir 变换）

### 6.1 从交互式到非交互式

```
问题：Σ-协议需要交互，不方便

解决：Fiat-Shamir 变换
     用哈希函数替代验证者的随机挑战

原理：
  交互式：e ← V₁()（验证者随机选择）

  非交互式：e = H(x, A)（证明者自己计算）
           其中 H 是哈希函数

  关键：哈希函数的输出"看起来像"随机的
       攻击者无法预测或操控
```

### 6.2 ZK 模块的三个操作

```
┌─────────────────────────────────────────────────────────────┐
│ commit(Π, x; τ) → A                                         │
│   使用随机数 τ 生成承诺 A                                     │
│   A ← P₁(|x|, τ)                                            │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ prove(Π, aux, x; w, τ) → π                                  │
│   生成完整的非交互式证明                                      │
│                                                             │
│   A ← P₁(|x|, τ)                                            │
│   e = H(aux, x, A)        ← 用哈希计算挑战                   │
│   z ← P₂(x, w, τ, e)                                        │
│   π = (A, z)              ← 证明是承诺和响应的对              │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ verify(Π, aux, x, π) → {0, 1}                               │
│   验证非交互式证明                                           │
│                                                             │
│   解析 π = (A, z)                                           │
│   e = H(aux, x, A)        ← 重新计算挑战                     │
│   返回 V₂(x, A, e, z)                                       │
└─────────────────────────────────────────────────────────────┘
```

### 6.3 为什么需要 commit 操作？

```
安全分析需要：

在 UC（通用可组合性）安全证明中，
需要能够"提取"证明者的见证

提取依赖于：证明者必须先承诺 A，然后才能看到挑战

如果没有 commit：
  证明者可能根据挑战反推承诺（作弊）

有了 commit：
  承诺被"锁定"，证明者无法根据挑战修改
```

### 6.4 aux 参数的作用

```
aux = auxiliary（辅助信息）

包含：
  - 会话标识符 (ssid)
  - 参与方标识
  - 协议阶段
  - 其他上下文信息

作用：
  1. 绑定证明到特定上下文
  2. 防止证明被重放（replay attack）
  3. 区分不同会话的证明
```

---

## 七、协议总览

### 7.1 四个阶段

```
┌─────────────────────────────────────────────────────────────┐
│                    门限 ECDSA 协议                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────┐    运行一次                                │
│  │ 密钥生成    │ ─────────────────────────────→ (X, xᵢ)    │
│  └─────────────┘                                            │
│        ↓                                                    │
│  ┌─────────────┐    定期运行（密钥刷新计划）                  │
│  │ 辅助信息    │ ─────────────────────────────→ (Nᵢ, sᵢ, tᵢ)│
│  │ + 密钥刷新  │                                            │
│  └─────────────┘                                            │
│        ↓                                                    │
│  ┌─────────────┐    每次签名前（消息未知）                    │
│  │ 预签名      │ ─────────────────────────────→ (R, kᵢ, χᵢ) │
│  └─────────────┘                                            │
│        ↓                                                    │
│  ┌─────────────┐    消息已知后                               │
│  │ 签名        │ ─────────────────────────────→ (r, σ)      │
│  └─────────────┘                                            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 7.2 两种变体

```
在线签名（Online）：
  每次签名请求：预签名 → 签名
  优点：简单
  缺点：签名时延迟较高

离线/非交互签名（Offline/Non-interactive）：
  提前运行：预签名（存储结果）
  签名请求：直接使用预存的数据
  优点：签名阶段只需一轮
  缺点：需要提前准备
```

### 7.3 哈希函数约定

```
备注：协议使用哈希函数 H

实际实现中可能需要多个不同的哈希函数：
  - H: M → Fq（消息哈希）
  - H: ... → {0,1}^ℓ（其他用途）

为简化符号，论文统一写成 H
实际应用时需要使用域分离（domain separation）
```

---

## 八、计算示例：Schnorr 协议

### 8.1 设定

```
群参数：使用 Z*_23（素数 23 的乘法群）
生成元：g = 5（5 是 Z*_23 的生成元）
群阶：q = 22（φ(23) = 22）

证明者的秘密：x = 7
公钥：X = g^x = 5^7 mod 23

计算 5^7 mod 23：
  5^1 = 5
  5^2 = 25 mod 23 = 2
  5^4 = 4
  5^7 = 5^4 × 5^2 × 5^1 = 4 × 2 × 5 = 40 mod 23 = 17

∴ X = 17
```

### 8.2 协议执行

```
第1步：证明者生成承诺
  选择随机数 r = 11
  计算 A = g^r = 5^11 mod 23

  5^8 = 5^4 × 5^4 = 4 × 4 = 16
  5^11 = 5^8 × 5^2 × 5^1 = 16 × 2 × 5 = 160 mod 23 = 160 - 6×23 = 22

  A = 22

  发送 A = 22 给验证者

第2步：验证者发送挑战
  e = 3（随机选择）

第3步：证明者计算响应
  z = r + e·x mod q
    = 11 + 3×7 mod 22
    = 11 + 21 mod 22
    = 32 mod 22
    = 10

  发送 z = 10 给验证者

第4步：验证者检查
  验证：g^z = A · X^e mod p

  左边 = g^z = 5^10 mod 23
       = 5^8 × 5^2 = 16 × 2 = 32 mod 23 = 9

  右边 = A · X^e = 22 × 17^3 mod 23
       = 22 × (17^2 × 17) mod 23
       = 22 × (289 × 17) mod 23
       = 22 × (289 mod 23 × 17) mod 23
       = 22 × (13 × 17) mod 23
       = 22 × 221 mod 23
       = 22 × (221 mod 23) mod 23
       = 22 × 14 mod 23
       = 308 mod 23
       = 308 - 13×23
       = 308 - 299
       = 9

  左边 = 9, 右边 = 9
  验证通过！✓
```

### 8.3 Fiat-Shamir 变换

```
非交互式版本：

证明者：
  r = 11, A = 22
  e = H(X, A) = H(17, 22) mod 22
  假设 H(17, 22) = 47，则 e = 47 mod 22 = 3
  z = 11 + 3×7 mod 22 = 10

  证明 π = (A, z) = (22, 10)

验证者：
  收到 π = (22, 10)
  重新计算 e = H(17, 22) mod 22 = 3
  验证 g^z = A · X^e
  （同上，验证通过）
```

---

## 总结

```
本章定义了门限 ECDSA 协议所需的所有数学工具：

1. 符号约定 - 公开值用大写，秘密值用小写
2. Paillier-Blum 整数 - 保证 Paillier 加密安全
3. Paillier 加密 - 支持同态操作的加密方案
4. ECDSA 定义 - 签名和验证的数学形式
5. NP 关系 - 零知识证明的目标
6. Σ-协议 - 三轮交互式零知识证明
7. ZK 模块 - 非交互式零知识证明
8. 协议结构 - 四阶段：密钥生成、辅助信息、预签名、签名
```

