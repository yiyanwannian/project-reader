# 协议详解

本文档详细讲解论文第3章"协议"部分的内容。

---

## 一、协议总览

### 1.1 四个阶段

```
门限 ECDSA 协议由四个阶段组成：

┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  阶段1: 密钥生成 (Key Generation) ─────────── 运行一次          │
│         图5                                                     │
│         生成：共享私钥 x = Σxᵢ，公钥 X = g^x                     │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  阶段2: 辅助信息 + 密钥刷新 (Aux-Info + Key Refresh)            │
│         图6                                     定期运行         │
│         生成：Paillier 密钥 (Nᵢ, pᵢ, qᵢ)                        │
│              Ring-Pedersen 参数 (sᵢ, tᵢ)                        │
│         刷新：私钥份额 xᵢ → xᵢ*                                  │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  阶段3: 预签名 (Pre-Signing) ───────────────── 每次签名前        │
│         图7                                                     │
│         生成：预签名数据 (R, kᵢ, χᵢ)                             │
│         可在消息未知时提前运行                                    │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  阶段4: 签名 (Signing) ─────────────────────── 消息已知后        │
│         图8                                                     │
│         生成：最终签名 (r, σ)                                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 1.2 阶段之间的依赖关系

```
                    ┌──────────────┐
                    │  密钥生成    │
                    │   (一次)     │
                    └──────┬───────┘
                           │
                           ▼
                    ┌──────────────┐
            ┌──────►│ 辅助信息 +   │◄─────┐
            │       │ 密钥刷新     │      │
            │       └──────┬───────┘      │
            │              │              │
            │              ▼              │
            │       ┌──────────────┐      │
            │       │   预签名     │      │
            │       │  (可提前)    │      │
            │       └──────┬───────┘      │
            │              │              │
            │              ▼              │
            │       ┌──────────────┐      │
            │       │    签名      │      │
            │       │ (消息已知)   │      │
            │       └──────┬───────┘      │
            │              │              │
            └──────────────┴──────────────┘
                     按需循环
```

### 1.3 输出总结

```
各阶段输出：

阶段1 - 密钥生成：
  公开：X = g^x（公钥）
       Xᵢ = g^(xᵢ)（公钥份额）
  秘密：xᵢ（私钥份额）

阶段2 - 辅助信息：
  公开：Nᵢ（Paillier 公钥）
       sᵢ, tᵢ（Ring-Pedersen 参数）
  秘密：pᵢ, qᵢ（Paillier 私钥）
       xᵢ*（刷新后的私钥份额）

阶段3 - 预签名：
  公开：R = g^(1/k)
  秘密：kᵢ（随机数份额）
       χᵢ（kx 的份额）

阶段4 - 签名：
  公开：(r, σ)（最终签名）
```

---

## 二、两种协议变体

### 2.1 在线签名（Online Signing）

```
特点：收到签名请求后，顺序执行预签名和签名

流程：
  收到 (sign, msg) 请求
       │
       ▼
  ┌─────────────┐
  │   预签名    │ ← 此时才开始
  └──────┬──────┘
         │
         ▼
  ┌─────────────┐
  │    签名     │
  └──────┬──────┘
         │
         ▼
  输出 (r, σ)

优点：简单，无需预存储
缺点：签名延迟 = 预签名时间 + 签名时间
```

### 2.2 非交互式签名（Non-Interactive Signing）

```
特点：预签名提前运行，签名时只需一轮

流程：
  提前：运行 L 次预签名
       │
       ▼
  存储 L 份预签名数据
  
  ......（等待签名请求）......
  
  收到 (sign, msg) 请求
       │
       ▼
  取出一份预签名数据
       │
       ▼
  ┌─────────────┐
  │ 签名 (1轮)  │ ← 非常快！
  └──────┬──────┘
         │
         ▼
  输出 (r, σ)

优点：签名延迟极低（只需一轮通信）
缺点：需要提前准备和存储预签名数据
     每份预签名数据只能用一次
```

### 2.3 两种变体的对比

```
┌─────────────────────────────────────────────────────────────────┐
│  特性              │  在线签名        │  非交互式签名           │
├─────────────────────────────────────────────────────────────────┤
│  预签名时机        │  签名时         │  提前                   │
│  签名延迟          │  较高           │  极低（1轮）            │
│  存储需求          │  无             │  需存储预签名数据        │
│  预签名复用        │  -              │  每份只能用一次          │
│  适用场景          │  低频签名       │  高频/实时签名           │
└─────────────────────────────────────────────────────────────────┘
```

---

## 三、在线签名协议详解（图3）

### 3.1 密钥生成操作

```
输入：(keygen, ssid, i)
  ssid = 子会话标识符
  i = 参与方编号

步骤1：运行图5的密钥生成
  输出：(srid, X⃗, xᵢ)
  
  srid = 子轮标识符（用于区分不同轮次）
  X⃗ = (X₁, ..., Xₙ) 所有公钥份额
  xᵢ = 自己的私钥份额

步骤2：运行图6的辅助信息阶段
  输入：(aux-info, ssid, srid, X⃗, i)
  输出：(X⃗, N⃗, s⃗, t⃗) 和 (xᵢ, pᵢ, qᵢ)

步骤3：设置会话标识符
  sid = (ssid, srid, X⃗, N⃗, s⃗, t⃗)

  sid 包含了所有公开参数，用于后续阶段
```

### 3.2 签名操作

```
输入：(sign, sid, ℓ, i, msg)
  sid = 会话标识符
  ℓ = 签名索引（第几个签名）
  i = 参与方编号
  msg = 待签名消息

步骤1：运行预签名（图7）
  输入：(pre-sign, sid, 0, i)
  输出：预签名数据 (R, kᵢ, χᵢ)

步骤2：计算消息哈希
  m = H(msg)

步骤3：运行签名（图8）
  输入：(sign, sid, 0, i, m)
  输出：最终签名 (r, σ)
```

### 3.3 密钥刷新操作

```
输入：(key-refresh, ssid, srid, X⃗, i)

步骤1：运行辅助信息阶段（图6）
  注意：这会同时刷新私钥份额！

步骤2：获得输出后
  擦除：所有旧的预签名数据和辅助信息
  重置：sid = (ssid, srid, X⃗, N⃗, s⃗, t⃗)

关键：旧的私钥份额 xᵢ 被替换为 xᵢ*
     但私钥 x = Σxᵢ = Σxᵢ* 保持不变
     公钥 X = g^x 也保持不变
```

---

## 四、非交互式签名协议详解（图4）

### 4.1 与在线签名的区别

```
相同部分：
  - 密钥生成：完全相同
  - 密钥刷新：完全相同

不同部分：
  - 预签名：提前批量运行
  - 签名：直接使用预存数据
```

### 4.2 预签名操作（提前执行）

```
输入：(pre-sign, sid, L, i)
  L = 预签名数量

步骤1：擦除旧的预签名数据

步骤2：并发运行 L 次预签名
  (pre-sign, sid, 1, i)
  (pre-sign, sid, 2, i)
  ...
  (pre-sign, sid, L, i)

结果：存储 L 份预签名数据
  预签名[1] = (R₁, k₁ᵢ, χ₁ᵢ)
  预签名[2] = (R₂, k₂ᵢ, χ₂ᵢ)
  ...
  预签名[L] = (Rₗ, kₗᵢ, χₗᵢ)
```

### 4.3 签名操作（使用预存数据）

```
输入：(sign, sid, ℓ, i, msg)
  ℓ = 使用第 ℓ 份预签名

步骤1：计算消息哈希
  m = H(msg)

步骤2：使用预签名[ℓ]运行签名阶段
  输入：(sign, sid, ℓ, i, m)
  输出：(r, σ)

注意：每份预签名只能用一次！
     用过后该预签名作废
```

---

## 五、密钥生成阶段详解（图5）

### 5.1 核心思想

```
目标：n 个参与方共同生成
  - 公钥 X = g^x
  - 每人持有私钥份额 xᵢ，满足 x = Σxᵢ

安全要求：
  1. 没有人知道完整私钥 x
  2. 任何人无法影响 x 的分布（x 应该是均匀随机的）
  3. 每个人必须证明自己知道 xᵢ（防止声称假的公钥份额）
```

### 5.2 协议流程

```
参与方 Pᵢ 的操作：

┌─────────────────────────────────────────────────────────────────┐
│ 第1轮：承诺                                                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 采样私钥份额：xᵢ ← Fq                                        │
│                                                                 │
│  2. 计算公钥份额：Xᵢ = g^(xᵢ)                                    │
│                                                                 │
│  3. 生成 Schnorr 证明的第一条消息：                               │
│     Aᵢ ← commit(Π_sch, Xᵢ)                                      │
│                                                                 │
│  4. 计算承诺：                                                   │
│     Vᵢ = H(ssid, i, (Xᵢ, Aᵢ))                                   │
│                                                                 │
│  5. 广播 Vᵢ                                                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 第2轮：解承诺                                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  6. 广播 (Xᵢ, Aᵢ)                                               │
│                                                                 │
│  7. 收到所有 Vⱼ, (Xⱼ, Aⱼ) 后验证：                               │
│     Vⱼ = H(ssid, j, (Xⱼ, Aⱼ)) 对所有 j                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 第3轮：Schnorr 证明                                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  8. 生成 Schnorr 证明：                                          │
│     πᵢ = prove(Π_sch, aux, Xᵢ; xᵢ)                              │
│                                                                 │
│     证明："我知道 xᵢ 使得 Xᵢ = g^(xᵢ)"                           │
│                                                                 │
│  9. 广播 πᵢ                                                     │
│                                                                 │
│  10. 验证所有收到的 πⱼ：                                         │
│      verify(Π_sch, aux, Xⱼ, πⱼ) = 1 对所有 j                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 计算最终公钥                                                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  11. 计算公钥：X = X₁ · X₂ · ... · Xₙ = g^(x₁+x₂+...+xₙ) = g^x  │
│                                                                 │
│  12. 存储：                                                      │
│      - 公钥份额向量 X⃗ = (X₁, ..., Xₙ)                           │
│      - 自己的私钥份额 xᵢ                                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.3 为什么需要承诺-解承诺？

```
攻击场景（没有承诺时）：

  P₁ 先公开 X₁
  恶意的 P₂ 看到后，可以选择特殊的 x₂ 使得：
    X = X₁ · X₂ = g^(x₁+x₂)
  变成 P₂ 想要的值（比如 P₂ 已知私钥的公钥）

有承诺机制：
  所有人先承诺 Vᵢ = H(Xᵢ, Aᵢ)
  再一起解承诺
  → P₂ 在选择 x₂ 时不知道 X₁ 的值
  → 无法影响最终公钥的分布
```

### 5.4 为什么 Schnorr 证明的 A 也要承诺？

```
关键：不只承诺 Xᵢ，还承诺 Aᵢ

原因：安全证明中需要从 Schnorr 证明中提取 xᵢ

提取原理（特殊可靠性）：
  给定两个接受的证明 (A, e, z) 和 (A, e', z')
  可以计算 xᵢ = (z - z') / (e - e')

如果 A 不承诺：
  恶意方可能根据挑战 e 重新选择 A
  导致提取失败

承诺 A 后：
  A 被"锁定"，恶意方无法更改
  保证提取成功
```

---

## 六、密钥刷新与辅助信息阶段详解（图6）

### 6.1 这个阶段做两件事

```
┌─────────────────────────────────────────────────────────────────┐
│  事情1：生成辅助信息                                             │
│                                                                 │
│    每个 Pᵢ 生成：                                                │
│      - Paillier 密钥：(Nᵢ; pᵢ, qᵢ)                              │
│      - Ring-Pedersen 参数：(sᵢ, tᵢ; λᵢ)                         │
│                                                                 │
│    这些用于后续预签名阶段的同态加密和零知识证明                     │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│  事情2：刷新私钥份额                                             │
│                                                                 │
│    目标：xᵢ → xᵢ*，但 Σxᵢ = Σxᵢ* = x（私钥不变）                 │
│                                                                 │
│    方法：每人生成 "0 的秘密共享"，加到原份额上                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 6.2 密钥刷新的核心方法

```
每个 Pᵢ 生成 0 的秘密共享：

  选择 (xᵢ¹, xᵢ², ..., xᵢⁿ)
  满足：xᵢ¹ + xᵢ² + ... + xᵢⁿ = 0 mod q

  Pᵢ 把 xᵢʲ 发给 Pⱼ（加密发送）

每个 Pⱼ 收集所有发给自己的份额：

  xⱼ* = xⱼ + x₁ʲ + x₂ʲ + ... + xₙʲ

验证：
  Σⱼ xⱼ* = Σⱼ xⱼ + Σⱼ Σᵢ xᵢʲ
         = x + Σᵢ (Σⱼ xᵢʲ)
         = x + Σᵢ 0
         = x ✓

结论：私钥 x 不变，但每个份额 xᵢ 都变了
```

### 6.3 协议流程

```
┌─────────────────────────────────────────────────────────────────┐
│ 第1轮：生成并广播公开参数                                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 生成 Paillier 密钥：                                         │
│     (Nᵢ; pᵢ, qᵢ) ← Paillier.gen(1^κ)                            │
│     Nᵢ = pᵢ · qᵢ                                                │
│                                                                 │
│  2. 生成 Ring-Pedersen 参数：                                    │
│     λᵢ ← Z*_{φ(Nᵢ)}                                             │
│     tᵢ ← 随机                                                   │
│     sᵢ = tᵢ^λᵢ mod Nᵢ                                           │
│                                                                 │
│  3. 生成 0 的秘密共享：                                           │
│     随机选择 xᵢ¹, ..., xᵢⁿ⁻¹ ← Fq                               │
│     xᵢⁿ = -(xᵢ¹ + ... + xᵢⁿ⁻¹) mod q                           │
│     → 保证 Σⱼ xᵢʲ = 0                                           │
│                                                                 │
│  4. 计算群元素：                                                  │
│     Xᵢʲ = g^(xᵢʲ) 对所有 j                                       │
│     Y⃗ᵢ = (Xᵢ¹, ..., Xᵢⁿ)                                        │
│                                                                 │
│  5. 广播：(Nᵢ, sᵢ, tᵢ, Y⃗ᵢ)                                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 第2轮：加密份额并发送 + ZK 证明                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  6. 对每个 k ∈ {1,...,n}，加密要发给 Pₖ 的份额：                  │
│     Cᵢᵏ = enc_{Nₖ}(xᵢᵏ)                                         │
│                                                                 │
│     注意：用 Pₖ 的公钥加密！只有 Pₖ 能解密                        │
│                                                                 │
│  7. 广播所有密文 {Cᵢᵏ}ₖ                                          │
│                                                                 │
│  8. 生成 ZK 证明：                                               │
│     (a) Π_mod：证明 Nᵢ 是合法的 Paillier-Blum 模数               │
│     (b) Π_prm：证明 sᵢ = tᵢ^λᵢ                                   │
│     (c) Π_fac：证明 Nᵢ 没有小因子                                 │
│     (d) Π_log：证明 Cᵢᵏ 的明文 = Xᵢᵏ 的离散对数                   │
│                                                                 │
│  9. 广播所有证明                                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 验证并更新                                                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  10. 验证所有收到的 ZK 证明                                       │
│                                                                 │
│  11. 验证每行之和为 0：                                           │
│      Xᵢ¹ · Xᵢ² · ... · Xᵢⁿ = g^0 = 1 对所有 i                   │
│                                                                 │
│  12. 解密收到的密文：                                             │
│      x₁ⁱ = dec_{pᵢ,qᵢ}(C₁ⁱ)                                     │
│      x₂ⁱ = dec_{pᵢ,qᵢ}(C₂ⁱ)                                     │
│      ...                                                        │
│      xₙⁱ = dec_{pᵢ,qᵢ}(Cₙⁱ)                                     │
│                                                                 │
│  13. 更新私钥份额：                                               │
│      xᵢ* = xᵢ + x₁ⁱ + x₂ⁱ + ... + xₙⁱ mod q                     │
│                                                                 │
│  14. 更新公钥份额：                                               │
│      Xⱼ* = Xⱼ · X₁ʲ · X₂ʲ · ... · Xₙʲ 对所有 j                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 6.4 ZK 证明的作用

```
┌─────────────────────────────────────────────────────────────────┐
│  证明              │  作用                                       │
├─────────────────────────────────────────────────────────────────┤
│  Π_mod            │  确保 Nᵢ 是安全的 Paillier 模数               │
│  (Paillier-Blum)  │  Nᵢ = pᵢqᵢ，p,q ≡ 3 mod 4                  │
│                   │  gcd(Nᵢ, φ(Nᵢ)) = 1                         │
├─────────────────────────────────────────────────────────────────┤
│  Π_prm            │  确保 Ring-Pedersen 参数正确                  │
│  (Ring-Pedersen)  │  sᵢ 确实在 ⟨tᵢ⟩ 中                           │
├─────────────────────────────────────────────────────────────────┤
│  Π_fac            │  防止使用有小因子的模数                       │
│  (无小因子)        │  pᵢ, qᵢ > 2^ℓ（足够大）                      │
├─────────────────────────────────────────────────────────────────┤
│  Π_log            │  确保加密的值与公开的群元素一致                │
│  (离散对数=明文)   │  dec(Cᵢᵏ) mod q = log_g(Xᵢᵏ)                │
└─────────────────────────────────────────────────────────────────┘

安全意义：
  - Π_mod：模拟器可以提取恶意方的 Paillier 私钥
  - Π_log：确保恶意方不能发送假的密文
  - 两者结合：模拟器可以解密所有密文，提取所有秘密
```

---

## 七、计算示例（n=3 的情况）

### 7.1 密钥生成示例

```
设定：
  素数 p = 23
  群 G = Z*₂₃ 的子群
  生成元 g = 5
  群阶 q = 22（因为 5 是 Z*₂₃ 的生成元，阶为 φ(23) = 22）

  注意：私钥运算在 mod q = 22 下进行
        群元素运算在 mod p = 23 下进行

第1轮：各方选择私钥份额

  P₁ 选择：x₁ = 3
           计算 X₁ = g^(x₁) = 5^3 mod 23
           5^3 = 125 = 5×23 + 10 = 10 mod 23
           ∴ X₁ = 10

  P₂ 选择：x₂ = 5
           计算 X₂ = g^(x₂) = 5^5 mod 23
           5^4 = 625 = 27×23 + 4 = 4 mod 23
           5^5 = 5^4 × 5 = 4 × 5 = 20 mod 23
           ∴ X₂ = 20

  P₃ 选择：x₃ = 8
           计算 X₃ = g^(x₃) = 5^8 mod 23
           5^8 = (5^4)^2 = 4^2 = 16 mod 23
           ∴ X₃ = 16

第2轮：广播公钥份额

  所有人收到：(X₁, X₂, X₃) = (10, 20, 16)

  每人计算承诺并广播，然后解承诺（防止作弊）

第3轮：Schnorr 证明

  P₁ 证明知道 x₁ 使得 X₁ = g^(x₁)，即 10 = 5^(x₁)
  P₂ 证明知道 x₂ 使得 X₂ = g^(x₂)，即 20 = 5^(x₂)
  P₃ 证明知道 x₃ 使得 X₃ = g^(x₃)，即 16 = 5^(x₃)

  （Schnorr 证明的具体计算见 paper2_preliminaries.md）

计算公钥：

  X = X₁ · X₂ · X₃ mod 23
    = 10 × 20 × 16 mod 23

    10 × 20 = 200 = 8×23 + 16 = 16 mod 23
    16 × 16 = 256 = 11×23 + 3 = 3 mod 23

  ∴ X = 3

验证：
  私钥 x = x₁ + x₂ + x₃ mod q
         = 3 + 5 + 8 mod 22
         = 16

  g^x = 5^16 mod 23
      = (5^8)^2 mod 23
      = 16^2 mod 23
      = 256 mod 23
      = 3 ✓

  X = g^x = 3 ✓
```

### 7.2 密钥刷新示例

```
设定：接上面的密钥生成示例
  q = 22（群阶）
  p = 23（素数）
  g = 5

刷新前（来自密钥生成）：
  x₁ = 3, x₂ = 5, x₃ = 8
  x = 3 + 5 + 8 = 16 (mod 22)
  X = g^x = 3

第1步：每人生成 0 的秘密共享

  P₁ 生成：
    随机选择 x₁¹ = 7, x₁² = 9
    计算 x₁³ = -(7 + 9) mod 22 = -16 mod 22 = 6
    验证：7 + 9 + 6 = 22 ≡ 0 (mod 22) ✓

    计算群元素：
    X₁¹ = g^7 mod 23 = 5^7 mod 23
        = 5^4 × 5^2 × 5 = 4 × 2 × 5 = 40 mod 23 = 17
    X₁² = g^9 mod 23 = 5^9 mod 23
        = 5^8 × 5 = 16 × 5 = 80 mod 23 = 11
    X₁³ = g^6 mod 23 = 5^6 mod 23
        = 5^4 × 5^2 = 4 × 2 = 8

  P₂ 生成：
    随机选择 x₂¹ = 4, x₂² = 12
    计算 x₂³ = -(4 + 12) mod 22 = -16 mod 22 = 6
    验证：4 + 12 + 6 = 22 ≡ 0 (mod 22) ✓

  P₃ 生成：
    随机选择 x₃¹ = 11, x₃² = 1
    计算 x₃³ = -(11 + 1) mod 22 = -12 mod 22 = 10
    验证：11 + 1 + 10 = 22 ≡ 0 (mod 22) ✓

刷新矩阵：
            发给P₁   发给P₂   发给P₃   行和
  P₁ 生成：   7        9        6      = 22 ≡ 0
  P₂ 生成：   4       12        6      = 22 ≡ 0
  P₃ 生成：  11        1       10      = 22 ≡ 0

刷新矩阵（每行之和 = 0 mod 22）：

            发给P₁   发给P₂   发给P₃   行和
  P₁ 生成：   5        8        9      = 22 ≡ 0 (mod 22) ✓
  P₂ 生成：   7       10        5      = 22 ≡ 0 (mod 22) ✓
  P₃ 生成：   2       15        5      = 22 ≡ 0 (mod 22) ✓
  ─────────────────────────────────────────
  列和：     14       33       19

第2步：分发份额（用各自的 Paillier 公钥加密）

  P₁ 加密 x₁¹=5 用 N₁，发给 P₁
  P₁ 加密 x₁²=8 用 N₂，发给 P₂
  P₁ 加密 x₁³=9 用 N₃，发给 P₃

  （P₂, P₃ 类似）

  每个 Pⱼ 收到并解密第 j 列：
    P₁ 解密得到：5, 7, 2（列1）
    P₂ 解密得到：8, 10, 15（列2）
    P₃ 解密得到：9, 5, 5（列3）

第3步：更新私钥份额

  x₁* = x₁ + (列1之和) mod 22
      = 3 + (5 + 7 + 2) mod 22
      = 3 + 14 mod 22
      = 17

  x₂* = x₂ + (列2之和) mod 22
      = 5 + (8 + 10 + 15) mod 22
      = 5 + 33 mod 22
      = 5 + 11 mod 22
      = 16

  x₃* = x₃ + (列3之和) mod 22
      = 8 + (9 + 5 + 5) mod 22
      = 8 + 19 mod 22
      = 27 mod 22
      = 5

验证私钥不变：
  x* = x₁* + x₂* + x₃*
     = 17 + 16 + 5
     = 38 mod 22
     = 16
     = x ✓

结论：
  刷新前：(x₁, x₂, x₃) = (3, 5, 8)，x = 16
  刷新后：(x₁*, x₂*, x₃*) = (17, 16, 5)，x* = 16
  私钥 x = 16 保持不变！
  公钥 X = g^16 = 3 也保持不变！

  但份额完全改变了：
    P₁: 3 → 17
    P₂: 5 → 16
    P₃: 8 → 5
```

---

## 八、备注解读

### 8.1 备注 3.1：哈希函数

```
问题：协议中用到多个哈希函数
  - 消息哈希：H: M → Fq
  - 承诺哈希：H: ... → {0,1}^ℓ
  - Fiat-Shamir 哈希：H: ... → 挑战空间

解决：统一写成 H

实际实现：
  使用域分离（domain separation）

  H₁(x) = H("message" || x)
  H₂(x) = H("commitment" || x)
  H₃(x) = H("fiat-shamir" || x)

  这样即使输入相同，输出也不同
```

### 8.2 备注 3.2：广播 vs 发送

```
区别：

"发送给所有人"：
  Pᵢ 分别发送消息给 P₁, P₂, ..., Pₙ
  每个人收到的可能不同（恶意方可以发不同的消息）

"广播"：
  Pᵢ 发送消息，所有人收到相同的内容
  需要一致性保证

实现广播（点对点网络）：
  使用"回声广播"（Echo Broadcast）

  1. Pᵢ 发送消息 m 给所有人
  2. 每个 Pⱼ 收到后，把 m 转发给所有人（回声）
  3. 每个人验证收到的回声都相同

  需要额外一轮通信
```

### 8.3 备注 3.3：更高效的密钥刷新

```
本协议的密钥刷新：2 轮

更高效的方案（Canetti 等人 [19]）：
  可以减少计算量
  但需要额外 1 轮通信

权衡：
  本协议：优化轮数
  [19] 协议：优化计算量
```

---

## 九、预签名阶段详解（图7）

### 9.1 回顾：ECDSA 签名结构

```
ECDSA 签名形式：(r, σ)

  r = g^(k⁻¹) |ₓ₋ₐₓᵢₛ      （随机点的 x 坐标）
  σ = k(m + rx) mod q      （签名值）

其中：
  k = 随机数（nonce）
  x = 私钥
  m = 消息哈希

门限化目标：
  每个 Pᵢ 持有 xᵢ（私钥份额），满足 x = Σxᵢ
  需要共同计算：
    1. R = g^(k⁻¹)
    2. kᵢ（k 的加法份额）
    3. χᵢ（kx 的加法份额）
```

### 9.2 核心思想：通过掩码计算 k⁻¹

```
问题：如何在不暴露 k 的情况下计算 g^(k⁻¹)？

方案：引入掩码 γ

  1. 计算 δ = k · γ（两个秘密的乘积）
  2. 计算 Γ = g^γ
  3. 计算 R = Γ^(δ⁻¹) = g^(γ · δ⁻¹) = g^(γ · (kγ)⁻¹) = g^(k⁻¹)

妙处：
  - 公开 δ 不会泄露 k（因为 γ 是随机的）
  - 公开 Γ 不会泄露 γ（离散对数问题）
  - 最终得到 R = g^(k⁻¹)
```

### 9.3 如何分布式计算 δ = kγ？

```
每个 Pᵢ 有：kᵢ 和 γᵢ
目标：计算 δᵢ，使得 Σδᵢ = (Σkᵢ)(Σγᵢ) = kγ = δ

展开乘积：
  kγ = (k₁ + k₂ + k₃)(γ₁ + γ₂ + γ₃)
     = k₁γ₁ + k₁γ₂ + k₁γ₃
     + k₂γ₁ + k₂γ₂ + k₂γ₃
     + k₃γ₁ + k₃γ₂ + k₃γ₃

观察：
  - kᵢγᵢ 可以本地计算
  - kᵢγⱼ (i≠j) 需要交互计算

乘法转加法技巧（MtA）：
  Pᵢ 和 Pⱼ 想计算 kⱼγᵢ 的加法份额

  Pᵢ 有 γᵢ，Pⱼ 有 Kⱼ = enc(kⱼ)（Paillier 加密）

  Pᵢ 计算：
    D = γᵢ ⊙ Kⱼ ⊕ enc(-βᵢⱼ)
      = enc(γᵢ · kⱼ - βᵢⱼ)

  Pⱼ 解密得到：
    αⱼᵢ = dec(D) = γᵢ · kⱼ - βᵢⱼ

  结果：
    βᵢⱼ + αⱼᵢ = βᵢⱼ + (γᵢkⱼ - βᵢⱼ) = γᵢkⱼ ✓
```

### 9.4 协议流程

```
┌─────────────────────────────────────────────────────────────────┐
│ 第1轮：生成随机数并加密                                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 采样随机数：kᵢ, γᵢ ← Fq                                     │
│                                                                 │
│  2. Paillier 加密（用自己的公钥）：                               │
│     Kᵢ = enc_i(kᵢ; ρᵢ)                                         │
│     Gᵢ = enc_i(γᵢ; νᵢ)                                         │
│                                                                 │
│  3. 生成 ZK 证明 Π_enc：                                         │
│     证明 Kᵢ 的明文在范围 I_ε 内                                  │
│                                                                 │
│  4. 广播 (Kᵢ, Gᵢ)，发送证明给各方                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 第2轮：计算 MtA 份额                                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  验证收到的 Π_enc 证明                                           │
│                                                                 │
│  对每个 j ≠ i：                                                  │
│                                                                 │
│  5. 计算 kγ 的 MtA（使用 Kⱼ 和 γᵢ）：                            │
│     采样 βᵢⱼ ← J_ε（加法掩码）                                   │
│     Dⱼᵢ = γᵢ ⊙ Kⱼ ⊕ enc_j(-βᵢⱼ)                                │
│     Fⱼᵢ = enc_i(βᵢⱼ)（用于 ZK 证明）                            │
│                                                                 │
│  6. 计算 kx 的 MtA（使用 Kⱼ 和 xᵢ）：                            │
│     采样 β̂ᵢⱼ ← J_ε                                              │
│     D̂ⱼᵢ = xᵢ ⊙ Kⱼ ⊕ enc_j(-β̂ᵢⱼ)                               │
│     F̂ⱼᵢ = enc_i(β̂ᵢⱼ)                                           │
│                                                                 │
│  7. 计算群元素：Γᵢ = g^γᵢ                                        │
│                                                                 │
│  8. 生成 ZK 证明：                                               │
│     Π_aff-p：证明 Dⱼᵢ 正确（γᵢ 乘 Kⱼ 加掩码）                    │
│     Π_aff-g：证明 D̂ⱼᵢ 正确（xᵢ 乘 Kⱼ 加掩码）                   │
│     Π_log：证明 Γᵢ = g^γᵢ 且 γᵢ = dec(Gᵢ)                       │
│                                                                 │
│  9. 发送 (Γᵢ, Dⱼᵢ, D̂ⱼᵢ, Fⱼᵢ, F̂ⱼᵢ, 证明) 给 Pⱼ                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 第3轮：解密并计算份额                                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  验证收到的 Π_aff-p, Π_aff-g, Π_log 证明                         │
│                                                                 │
│  10. 计算 Γ = ∏ⱼ Γⱼ = g^(Σγⱼ) = g^γ                             │
│                                                                 │
│  11. 解密 MtA 结果：                                             │
│      αᵢⱼ = dec_i(Dᵢⱼ) = γⱼkᵢ - βⱼᵢ                             │
│      α̃ᵢⱼ = dec_i(D̂ᵢⱼ) = xⱼkᵢ - β̂ⱼᵢ                            │
│                                                                 │
│  12. 计算 δᵢ（kγ 的份额）：                                      │
│      δᵢ = γᵢkᵢ + Σⱼ≠ᵢ(αᵢⱼ + βᵢⱼ) mod q                         │
│                                                                 │
│  13. 计算 χᵢ（kx 的份额）：                                      │
│      χᵢ = xᵢkᵢ + Σⱼ≠ᵢ(α̃ᵢⱼ + β̂ᵢⱼ) mod q                        │
│                                                                 │
│  14. 计算 Δᵢ = Γ^kᵢ（用于一致性验证）                            │
│                                                                 │
│  15. 生成 Π_log：证明 Δᵢ = Γ^kᵢ 且 kᵢ = dec(Kᵢ)                  │
│                                                                 │
│  16. 发送 (δᵢ, Δᵢ, 证明) 给所有人                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 输出：验证并计算 R                                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  验证收到的 Π_log 证明                                           │
│                                                                 │
│  17. 计算 δ = Σⱼ δⱼ mod q                                       │
│                                                                 │
│  18. 验证一致性：g^δ = ∏ⱼ Δⱼ                                    │
│      因为：g^δ = g^(Σδⱼ) = g^(kγ)                               │
│            ∏Δⱼ = ∏Γ^kⱼ = Γ^(Σkⱼ) = g^(γk)                       │
│                                                                 │
│  19. 计算 R = Γ^(δ⁻¹) = g^(γ·(kγ)⁻¹) = g^(k⁻¹)                  │
│                                                                 │
│  20. 输出 (R, kᵢ, χᵢ)                                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 9.5 ZK 证明的作用

```
┌────────────────────────────────────────────────────────────────────────┐
│  证明          │  证明什么                     │  防止什么攻击          │
├────────────────────────────────────────────────────────────────────────┤
│  Π_enc        │  Kᵢ 的明文在范围 I_ε 内        │  选择超大的 kᵢ         │
│               │                               │  泄露其他方的信息       │
├────────────────────────────────────────────────────────────────────────┤
│  Π_aff-p      │  Dⱼᵢ = γᵢ·Kⱼ + enc(-βᵢⱼ)     │  发送伪造的 MtA 结果    │
│               │  且 γᵢ = dec(Gᵢ), γᵢ ∈ I_ε   │  导致 δ 计算错误        │
├────────────────────────────────────────────────────────────────────────┤
│  Π_aff-g      │  D̂ⱼᵢ = xᵢ·Kⱼ + enc(-β̂ᵢⱼ)    │  发送伪造的 MtA 结果    │
│               │  且 xᵢ = log_g(Xᵢ), xᵢ ∈ I_ε │  导致 χ 计算错误        │
├────────────────────────────────────────────────────────────────────────┤
│  Π_log        │  Γᵢ = g^γᵢ 且 γᵢ = dec(Gᵢ)    │  发送假的 Γᵢ           │
│  (第2轮)      │                               │  导致 Γ 计算错误        │
├────────────────────────────────────────────────────────────────────────┤
│  Π_log        │  Δᵢ = Γ^kᵢ 且 kᵢ = dec(Kᵢ)    │  发送假的 Δᵢ           │
│  (第3轮)      │                               │  绕过一致性验证         │
└────────────────────────────────────────────────────────────────────────┘
```

### 9.6 为什么需要范围证明？

```
攻击场景（没有范围证明）：

  恶意的 P₁ 选择一个超大的 k₁（比如 k₁ = q + ε）

  MtA 过程中：
    P₂ 解密 D₂₁ = dec(γ₁·K₂ + enc(-β₁₂))
              = γ₁·k₂ - β₁₂ mod N₂  （注意是 mod N₂）

    如果 k₂ 很大，γ₁·k₂ 可能大于 N₂，导致模约简

  P₁ 可以通过分析 D₂₁ 的值获得 k₂ 的信息！

解决：范围证明
  要求 kᵢ ∈ I_ε = ±2^(ℓ+ε)
  确保乘积不会溢出 mod N
```

---

## 十、签名阶段详解（图8）

### 10.1 签名阶段的简单性

```
预签名完成后，每个 Pᵢ 存储：(R, kᵢ, χᵢ)

当消息 m 已知后，签名只需一轮！

步骤：
  1. 计算 r = R|ₓ₋ₐₓᵢₛ（R 的 x 坐标）
  2. 计算签名份额：σᵢ = kᵢm + rχᵢ mod q
  3. 发送 σᵢ 给所有人
  4. 聚合：σ = Σⱼ σⱼ mod q
  5. 输出签名 (r, σ)
```

### 10.2 正确性验证

```
σ = Σⱼ σⱼ
  = Σⱼ (kⱼm + rχⱼ) mod q
  = m·Σkⱼ + r·Σχⱼ mod q
  = mk + rχ mod q
  = mk + r(kx) mod q       （因为 χ = kx）
  = k(m + rx) mod q        （标准 ECDSA 签名值）✓
```

### 10.3 协议流程

```
┌─────────────────────────────────────────────────────────────────┐
│ 签名阶段（图8）                                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  输入：                                                          │
│    - (R, kᵢ, χᵢ)：预签名数据                                    │
│    - m：消息哈希                                                 │
│                                                                 │
│  第1步：计算 r                                                   │
│    r = R|ₓ₋ₐₓᵢₛ = R 的 x 坐标 mod q                             │
│                                                                 │
│  第2步：计算签名份额                                             │
│    σᵢ = kᵢ · m + r · χᵢ mod q                                  │
│                                                                 │
│  第3步：发送签名份额                                             │
│    发送 σᵢ 给所有参与方                                          │
│                                                                 │
│  第4步：聚合签名                                                 │
│    σ = Σⱼ σⱼ mod q                                              │
│                                                                 │
│  第5步：验证签名（可选）                                         │
│    使用标准 ECDSA 验证 (r, σ) 对 (m, X)                          │
│                                                                 │
│  输出：(r, σ)                                                    │
│                                                                 │
│  擦除：预签名数据 (R, kᵢ, χᵢ)                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 10.4 安全性说明

```
为什么签名阶段不需要 ZK 证明？

  1. 预签名阶段已经确保了所有值的正确性
     - kᵢ 在范围内
     - χᵢ 正确计算
     - R 一致

  2. 签名份额 σᵢ 是线性组合
     - 如果有人发送错误的 σᵢ
     - 最终签名 (r, σ) 将无效
     - 可以通过标准 ECDSA 验证检测

  3. 恶意方无法学到诚实方的秘密
     - 即使恶意方发送假的 σᵢ
     - 看到其他人的 σⱼ 也无法推断 kⱼ 或 χⱼ
     - 因为有 n-1 个未知数，只有 n-1 个方程
```

---

## 十一、预签名计算示例（n=3 的情况）

### 11.1 设定

```
群参数（与密钥生成示例一致）：
  p = 23（素数）
  g = 5（生成元）
  q = 22（群阶）

来自密钥生成：
  x₁ = 3, x₂ = 5, x₃ = 8
  x = 16
  X = g^x = 3

Paillier 参数（简化）：
  N₁ = N₂ = N₃ = 1000（实际应该是 4096 位）

采样随机数（确保 k ≠ 0 mod q）：
  k₁ = 7,  k₂ = 9,  k₃ = 4   → k = 7+9+4 = 20 (mod 22)
  γ₁ = 5,  γ₂ = 8,  γ₃ = 3   → γ = 5+8+3 = 16 (mod 22)
```

### 11.2 第1轮：生成并加密随机数

```
P₁: K₁ = enc(k₁) = enc(7)
    G₁ = enc(γ₁) = enc(5)

P₂: K₂ = enc(k₂) = enc(9)
    G₂ = enc(γ₂) = enc(8)

P₃: K₃ = enc(k₃) = enc(4)
    G₃ = enc(γ₃) = enc(3)

广播 (Kᵢ, Gᵢ)
```

### 11.3 第2轮：计算 MtA 份额

```
计算 kγ 的 MtA（以 P₁ 为例）：

P₁ 对 P₂：
  需要计算 γ₁k₂ = 5×9 = 45 的加法份额
  采样 β₁₂ = 17
  D₂₁ = enc(γ₁·k₂ - β₁₂) = enc(5×9 - 17) = enc(28)

  P₂ 解密：α₂₁ = 28
  份额：β₁₂ + α₂₁ = 17 + 28 = 45 = γ₁k₂ ✓

P₁ 对 P₃：
  需要计算 γ₁k₃ = 5×4 = 20
  采样 β₁₃ = 11
  D₃₁ = enc(5×4 - 11) = enc(9)

  P₃ 解密：α₃₁ = 9
  份额：β₁₃ + α₃₁ = 11 + 9 = 20 = γ₁k₃ ✓

类似地，所有参与方计算所有 MtA...

完整的 kγ MtA 矩阵：
┌─────────────────────────────────────────────────────┐
│  乘积     │  值   │  βᵢⱼ  │  αⱼᵢ  │  份额和        │
├─────────────────────────────────────────────────────┤
│  γ₁k₂    │  45   │  17   │  28   │  17+28=45 ✓    │
│  γ₁k₃    │  20   │  11   │   9   │  11+9=20 ✓     │
│  γ₂k₁    │  56   │  23   │  33   │  23+33=56 ✓    │
│  γ₂k₃    │  32   │  14   │  18   │  14+18=32 ✓    │
│  γ₃k₁    │  21   │   8   │  13   │  8+13=21 ✓     │
│  γ₃k₂    │  27   │  19   │   8   │  19+8=27 ✓     │
└─────────────────────────────────────────────────────┘

计算群元素：
  Γ₁ = g^γ₁ = 5^5 mod 23 = 20
  Γ₂ = g^γ₂ = 5^8 mod 23 = 16
  Γ₃ = g^γ₃ = 5^3 mod 23 = 10
```

### 11.4 第3轮：计算份额并验证

```
计算 Γ = Γ₁ · Γ₂ · Γ₃:
  Γ = 20 × 16 × 10 mod 23
    = 320 × 10 mod 23
    = (320 mod 23) × 10 mod 23
    = 21 × 10 mod 23
    = 210 mod 23
    = 3

验证：Γ = g^γ = 5^16 mod 23
  5^16 = (5^8)^2 = 16^2 = 256 mod 23 = 3 ✓

计算 δᵢ（kγ 的份额）：

  δ₁ = γ₁k₁ + (α₁₂ + β₁₂) + (α₁₃ + β₁₃) mod 22
     = 5×7 + (33 + 23) + (13 + 8) mod 22
     = 35 + 56 + 21 mod 22
     = 112 mod 22
     = 2

  δ₂ = γ₂k₂ + (α₂₁ + β₂₁) + (α₂₃ + β₂₃) mod 22
     = 8×9 + (28 + 17) + (8 + 19) mod 22
     = 72 + 45 + 27 mod 22
     = 144 mod 22
     = 12

  δ₃ = γ₃k₃ + (α₃₁ + β₃₁) + (α₃₂ + β₃₂) mod 22
     = 3×4 + (9 + 11) + (18 + 14) mod 22
     = 12 + 20 + 32 mod 22
     = 64 mod 22
     = 20

验证：δ = δ₁ + δ₂ + δ₃ mod 22
     = 2 + 12 + 20 mod 22
     = 34 mod 22
     = 12

理论值：δ = k × γ = 20 × 16 mod 22 = 320 mod 22 = 12 ✓

计算 Δᵢ = Γ^kᵢ:
  Δ₁ = 3^7 mod 23 = 2187 mod 23 = 95×23 + 2 = 2
  Δ₂ = 3^9 mod 23 = 3^8 × 3 = (3^4)^2 × 3 = 81^2 × 3 mod 23
     = (81 mod 23)^2 × 3 = 12^2 × 3 = 144 × 3 mod 23
     = 6 × 3 = 18
  Δ₃ = 3^4 mod 23 = 81 mod 23 = 12

一致性验证：g^δ = ∏Δⱼ
  左边：g^δ = 5^12 mod 23
        5^12 = 5^8 × 5^4 = 16 × 4 = 64 mod 23 = 18

  右边：Δ₁ × Δ₂ × Δ₃ = 2 × 18 × 12 mod 23
        = 36 × 12 mod 23
        = (36 mod 23) × 12 mod 23
        = 13 × 12 mod 23
        = 156 mod 23
        = 18 ✓

计算 R = Γ^(δ⁻¹):
  首先求 δ⁻¹ mod 22：
    δ = 12
    gcd(12, 22) = 2 ≠ 1 → 没有逆元

  注意：这是因为 22 = 2 × 11 不是素数。
  在实际协议中 q 是大素数，δ 几乎一定与 q 互素。
  如果恰好 gcd(δ, q) ≠ 1，概率约为 1/q，极小。
```

### 11.5 使用正确参数的完整示例

```
选择参数使 δ 与 22 互素：

k₁ = 5,  k₂ = 7,  k₃ = 3   → k = 15
γ₁ = 4,  γ₂ = 9,  γ₃ = 6   → γ = 19

δ = k × γ = 15 × 19 mod 22 = 285 mod 22 = 21

验证：gcd(21, 22) = 1 ✓（可以求逆）

求 δ⁻¹ mod 22：
  21 × δ⁻¹ ≡ 1 (mod 22)
  δ⁻¹ = 21（因为 21 × 21 = 441 = 20×22 + 1 ≡ 1 mod 22）

Γ = g^γ = 5^19 mod 23
  5^19 = 5^16 × 5^2 × 5 = 3 × 2 × 5 = 30 mod 23 = 7

R = Γ^(δ⁻¹) = 7^21 mod 23
  7^22 = 7^φ(23) ≡ 1 (mod 23)（费马小定理）
  7^21 = 7^22 / 7 = 1/7 mod 23

  求 7 的逆元：7 × 10 = 70 = 3×23 + 1 ≡ 1 (mod 23)
  所以 7⁻¹ = 10

  R = 7^21 = 10 mod 23

验证：R = g^(k⁻¹)
  k = 15
  k⁻¹ mod 22：15 × k⁻¹ ≡ 1 (mod 22)
    15 × 3 = 45 = 2×22 + 1 ≡ 1 (mod 22)
    k⁻¹ = 3

  g^(k⁻¹) = 5^3 mod 23 = 125 mod 23 = 10 = R ✓
```

---

## 十二、签名计算示例（n=3 的情况）

### 12.1 从预签名继续

```
预签名输出（接上面的修正示例）：
  R = 10
  k₁ = 5, k₂ = 7, k₃ = 3  → k = 15

kx 的计算（类似 kγ 的 MtA）：
  χ₁ = x₁k₁ + MtA份额 = ...
  χ₂ = x₂k₂ + MtA份额 = ...
  χ₃ = x₃k₃ + MtA份额 = ...

  理论值：χ = kx = 15 × 16 mod 22 = 240 mod 22 = 20

简化：假设 χ₁ = 8, χ₂ = 6, χ₃ = 6
验证：χ₁ + χ₂ + χ₃ = 8 + 6 + 6 = 20 = kx ✓
```

### 12.2 签名阶段

```
消息：m = 11（假设是消息哈希值）

第1步：计算 r
  r = R|ₓ₋ₐₓᵢₛ = 10 mod 22 = 10

第2步：计算签名份额
  σ₁ = k₁ × m + r × χ₁ mod q
     = 5 × 11 + 10 × 8 mod 22
     = 55 + 80 mod 22
     = 135 mod 22
     = 3

  σ₂ = k₂ × m + r × χ₂ mod q
     = 7 × 11 + 10 × 6 mod 22
     = 77 + 60 mod 22
     = 137 mod 22
     = 5

  σ₃ = k₃ × m + r × χ₃ mod q
     = 3 × 11 + 10 × 6 mod 22
     = 33 + 60 mod 22
     = 93 mod 22
     = 5

第3步：聚合签名
  σ = σ₁ + σ₂ + σ₃ mod 22
    = 3 + 5 + 5 mod 22
    = 13

签名输出：(r, σ) = (10, 13)
```

### 12.3 验证签名

```
标准 ECDSA 验证：
  公钥 X = 3
  消息 m = 11
  签名 (r, σ) = (10, 13)

步骤1：计算 σ⁻¹ mod q
  13 × σ⁻¹ ≡ 1 (mod 22)
  13 × 17 = 221 = 10×22 + 1 ≡ 1 (mod 22)
  σ⁻¹ = 17

步骤2：计算 u₁ 和 u₂
  u₁ = m × σ⁻¹ mod q = 11 × 17 mod 22 = 187 mod 22 = 11
  u₂ = r × σ⁻¹ mod q = 10 × 17 mod 22 = 170 mod 22 = 16

步骤3：计算 R' = g^u₁ × X^u₂
  g^u₁ = 5^11 mod 23
       = 5^8 × 5^2 × 5 = 16 × 2 × 5 = 160 mod 23 = 22

  X^u₂ = 3^16 mod 23
       = (3^8)^2 = ((3^4)^2)^2 = (81 mod 23)^2 = 12^2 = 144 mod 23 = 6
       然后 6^2 = 36 mod 23 = 13

  R' = 22 × 13 mod 23 = 286 mod 23 = 10

步骤4：验证
  r' = R'|ₓ₋ₐₓᵢₛ = 10
  r' = r = 10 ✓

签名有效！
```

---

## 总结

---

## 十三、完整协议流程串联

本章将整个门限 ECDSA 协议从初始化到签名完成的全过程串联起来，
展示各阶段之间的数据流动和依赖关系。

### 13.1 协议生命周期总览

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        门限 ECDSA 协议生命周期                            │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  时间轴：────────────────────────────────────────────────────────→      │
│                                                                         │
│  ┌──────────┐     ┌──────────────┐     ┌────────┐     ┌──────┐         │
│  │ 密钥生成 │────→│ 辅助信息生成 │────→│ 预签名 │────→│ 签名 │         │
│  │  (一次)  │     │  (+密钥刷新) │     │(可预存)│     │(即时)│         │
│  └──────────┘     └──────────────┘     └────────┘     └──────┘         │
│       │                  │                  │             │             │
│       ▼                  ▼                  ▼             ▼             │
│   输出：X, xᵢ      输出：Nᵢ, sᵢ, tᵢ    输出：R,kᵢ,χᵢ  输出：(r,σ)     │
│   (公钥,份额)      (Paillier+RP)        (预签名数据)   (最终签名)       │
│                                                                         │
│  运行频率：                                                              │
│    密钥生成：系统初始化时运行一次                                         │
│    辅助信息：定期运行（如每周/每月）                                      │
│    预签名：每次签名前运行（或提前批量生成）                               │
│    签名：消息到达时立即运行                                              │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 13.2 数据流动图

```
┌─────────────────────────────────────────────────────────────────────────┐
│                            数据流动关系                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                        密钥生成阶段                              │   │
│  │  输入：安全参数 κ                                                │   │
│  │  输出：                                                          │   │
│  │    • 公钥 X = g^x（所有人共享）                                  │   │
│  │    • 私钥份额 xᵢ（Pᵢ 私有）                                      │   │
│  │    • 公钥份额 Xᵢ = g^xᵢ（所有人知道）                            │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                    │                                    │
│                                    ▼                                    │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    辅助信息 + 密钥刷新阶段                        │   │
│  │  输入：xᵢ, Xᵢ（来自密钥生成）                                    │   │
│  │  输出：                                                          │   │
│  │    • Paillier 密钥对 (Nᵢ; pᵢ, qᵢ)                                │   │
│  │    • Ring-Pedersen 参数 (Nᵢ, sᵢ, tᵢ)                             │   │
│  │    • 刷新后的份额 xᵢ' = xᵢ + Σⱼaⱼᵢ（私钥不变）                   │   │
│  │    • 刷新后的公钥份额 Xᵢ' = g^xᵢ'                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                    │                                    │
│                                    ▼                                    │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                         预签名阶段                               │   │
│  │  输入：                                                          │   │
│  │    • xᵢ（私钥份额）                                              │   │
│  │    • Nⱼ, sⱼ, tⱼ（其他方的 Paillier 和 RP 参数）                  │   │
│  │  输出：                                                          │   │
│  │    • R = g^(k⁻¹)（签名的 R 点）                                  │   │
│  │    • kᵢ（k 的加法份额）                                          │   │
│  │    • χᵢ（kx 的加法份额）                                         │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                    │                                    │
│                                    ▼                                    │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                          签名阶段                                │   │
│  │  输入：                                                          │   │
│  │    • R, kᵢ, χᵢ（来自预签名）                                     │   │
│  │    • m（消息哈希）                                               │   │
│  │  输出：                                                          │   │
│  │    • (r, σ)（ECDSA 签名）                                        │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 13.3 完整流程：端到端示例（n=3）

```
═══════════════════════════════════════════════════════════════════════════
                              系统初始化
═══════════════════════════════════════════════════════════════════════════

参与方：P₁, P₂, P₃（需要全部 3 方参与签名）
目标：为公钥 X 生成对消息 m 的签名 (r, σ)

═══════════════════════════════════════════════════════════════════════════
                          阶段 1：密钥生成（3轮）
═══════════════════════════════════════════════════════════════════════════

【第1轮】各方生成并承诺

  P₁: x₁ = 3,  X₁ = g^3,   生成 Schnorr 承诺 A₁ = g^a₁
      计算 V₁ = H(X₁, A₁)，广播 V₁

  P₂: x₂ = 5,  X₂ = g^5,   生成 Schnorr 承诺 A₂ = g^a₂
      计算 V₂ = H(X₂, A₂)，广播 V₂

  P₃: x₃ = 8,  X₃ = g^8,   生成 Schnorr 承诺 A₃ = g^a₃
      计算 V₃ = H(X₃, A₃)，广播 V₃

【第2轮】解承诺并发送证明

  所有人广播 (Xᵢ, Aᵢ)
  验证：H(Xᵢ, Aᵢ) = Vᵢ ✓

【第3轮】完成 Schnorr 证明

  计算公共挑战 e = H(所有 Aᵢ)
  各方发送 zᵢ = aᵢ + e·xᵢ
  验证 g^zᵢ = Aᵢ · Xᵢ^e ✓

【输出】
  公钥：X = X₁ · X₂ · X₃ = g^(3+5+8) = g^16
  私钥份额：x₁=3, x₂=5, x₃=8（各方私有）
  公钥份额：X₁, X₂, X₃（所有人知道）

═══════════════════════════════════════════════════════════════════════════
                     阶段 2：辅助信息 + 密钥刷新（2轮）
═══════════════════════════════════════════════════════════════════════════

【第1轮】生成 Paillier 密钥和刷新份额

  P₁: 生成 Paillier 密钥 (N₁; p₁, q₁)
      生成 Ring-Pedersen 参数 (N₁, s₁, t₁)
      为"0的秘密共享"采样：a₁₁=2, a₁₂=-3, a₁₃=1（和=0）
      广播 (N₁, s₁, t₁, Aᵢⱼ = g^aᵢⱼ)

  P₂, P₃: 类似操作...
      P₂ 采样：a₂₁=-1, a₂₂=4, a₂₃=-3（和=0）
      P₃ 采样：a₃₁=3, a₃₂=-2, a₃₃=-1（和=0）

【第2轮】验证并更新份额

  验证所有 ZK 证明 (Π_mod, Π_prm, Π_fac, Π_sch)

  P₁: x₁' = x₁ + a₁₁ + a₂₁ + a₃₁ = 3 + 2 + (-1) + 3 = 7
  P₂: x₂' = x₂ + a₁₂ + a₂₂ + a₃₂ = 5 + (-3) + 4 + (-2) = 4
  P₃: x₃' = x₃ + a₁₃ + a₂₃ + a₃₃ = 8 + 1 + (-3) + (-1) = 5

  验证：x₁' + x₂' + x₃' = 7 + 4 + 5 = 16 = x ✓

【输出】
  Paillier 公钥：N₁, N₂, N₃
  RP 参数：(N₁,s₁,t₁), (N₂,s₂,t₂), (N₃,s₃,t₃)
  刷新份额：x₁'=7, x₂'=4, x₃'=5

═══════════════════════════════════════════════════════════════════════════
                          阶段 3：预签名（4轮）
═══════════════════════════════════════════════════════════════════════════

【第1轮】生成随机数并加密

  P₁: k₁=5, γ₁=4
      K₁ = enc₁(k₁), G₁ = enc₁(γ₁)
      广播 (K₁, G₁) + Π_enc 证明

  P₂: k₂=7, γ₂=9
      K₂ = enc₂(k₂), G₂ = enc₂(γ₂)

  P₃: k₃=3, γ₃=6
      K₃ = enc₃(k₃), G₃ = enc₃(γ₃)

  汇总：k = 5+7+3 = 15,  γ = 4+9+6 = 19

【第2轮】执行 MtA 协议

  计算 kγ 的加法份额（6对 MtA）：

  P₁ 对 P₂: 计算 γ₁k₂ = 4×7 = 28 的份额
    β₁₂ = 10（P₁ 采样的掩码）
    D₂₁ = enc₂(28 - 10) = enc₂(18)
    P₂ 解密得 α₂₁ = 18
    验证：β₁₂ + α₂₁ = 10 + 18 = 28 ✓

  ... 类似计算其他 5 对 ...

  计算 kx 的加法份额（6对 MtA）：
  ... 类似过程 ...

  计算群元素：
    Γ₁ = g^γ₁ = g^4
    Γ₂ = g^γ₂ = g^9
    Γ₃ = g^γ₃ = g^6

【第3轮】计算份额并验证

  Γ = Γ₁ · Γ₂ · Γ₃ = g^(4+9+6) = g^19

  δ₁ = γ₁k₁ + Σⱼ≠₁(αᵢⱼ + βᵢⱼ) = ...（kγ 的第一个份额）
  δ₂ = ...
  δ₃ = ...

  δ = δ₁ + δ₂ + δ₃ = kγ = 15 × 19 = 285 mod q = 21 (mod 22)

  χ₁, χ₂, χ₃ = kx 的份额（类似计算）
  χ = kx = 15 × 16 = 240 mod 22 = 20

  Δᵢ = Γ^kᵢ（用于一致性验证）

【输出】

  R = Γ^(δ⁻¹) = g^(γ·(kγ)⁻¹) = g^(k⁻¹)

  计算 δ⁻¹ mod 22：21 × 21 = 441 = 20×22 + 1, 所以 δ⁻¹ = 21
  R = (g^19)^21 = g^(19×21) = g^(399 mod 22) = g^3

  验证：k⁻¹ mod 22 = 15⁻¹ mod 22 = 3（因为 15×3=45=2×22+1）
        g^(k⁻¹) = g^3 = R ✓

  各方存储：
    P₁: (R, k₁=5, χ₁=8)
    P₂: (R, k₂=7, χ₂=6)
    P₃: (R, k₃=3, χ₃=6)

═══════════════════════════════════════════════════════════════════════════
                          阶段 4：签名（1轮）
═══════════════════════════════════════════════════════════════════════════

【消息到达】m = 11（消息哈希）

【计算签名份额】

  r = R|ₓ = 10（R 点的 x 坐标，假设）

  σ₁ = k₁·m + r·χ₁ = 5×11 + 10×8 = 55 + 80 = 135 mod 22 = 3
  σ₂ = k₂·m + r·χ₂ = 7×11 + 10×6 = 77 + 60 = 137 mod 22 = 5
  σ₃ = k₃·m + r·χ₃ = 3×11 + 10×6 = 33 + 60 = 93 mod 22 = 5

【聚合签名】

  σ = σ₁ + σ₂ + σ₃ = 3 + 5 + 5 = 13 mod 22

【最终输出】

  签名：(r, σ) = (10, 13)

═══════════════════════════════════════════════════════════════════════════
                              验证签名
═══════════════════════════════════════════════════════════════════════════

任何人使用公钥 X 验证：

  σ⁻¹ = 13⁻¹ mod 22 = 17（因为 13×17 = 221 = 10×22+1）
  u₁ = m·σ⁻¹ = 11×17 mod 22 = 187 mod 22 = 11
  u₂ = r·σ⁻¹ = 10×17 mod 22 = 170 mod 22 = 16

  R' = g^u₁ · X^u₂ = g^11 · (g^16)^16 = g^(11 + 256) = g^(267 mod 22) = g^3

  r' = R'|ₓ = 10 = r ✓

  签名有效！

═══════════════════════════════════════════════════════════════════════════
```

### 13.4 各阶段之间的安全依赖

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         安全属性传递链                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  密钥生成                                                                │
│    ├─→ 承诺-解承诺 ─────→ 防止恶意方影响公钥分布                         │
│    └─→ Schnorr 证明 ────→ 确保各方确实知道自己声称的份额                  │
│                │                                                        │
│                ▼                                                        │
│  辅助信息生成                                                            │
│    ├─→ Π_mod 证明 ──────→ 确保 Nᵢ 是正确的 Paillier-Blum 模数           │
│    ├─→ Π_prm 证明 ──────→ 确保 Ring-Pedersen 参数正确生成                │
│    ├─→ Π_fac 证明 ──────→ 确保 Nᵢ 的因子足够大（防止分解攻击）           │
│    └─→ Π_sch 证明 ──────→ 证明刷新份额的正确性                           │
│                │                                                        │
│                ▼                                                        │
│  预签名                                                                  │
│    ├─→ Π_enc 证明 ──────→ 确保加密的 kᵢ 在安全范围内                     │
│    ├─→ Π_aff-g/p 证明 ──→ 确保 MtA 计算正确                             │
│    ├─→ Π_log 证明 ──────→ 确保 Γᵢ 和 Δᵢ 与加密值一致                    │
│    └─→ 一致性检查 ──────→ 确保 g^δ = ∏Δᵢ                                │
│                │                                                        │
│                ▼                                                        │
│  签名                                                                    │
│    └─→ 线性组合 ────────→ 无需额外证明，错误会导致签名无效               │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 13.5 状态管理

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          各方需要维护的状态                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  持久化存储（长期）：                                                     │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 公钥 X                                                        │   │
│  │  • 私钥份额 xᵢ                                                   │   │
│  │  • 所有方的公钥份额 {Xⱼ}                                          │   │
│  │  • Paillier 私钥 (pᵢ, qᵢ)                                        │   │
│  │  • Ring-Pedersen 秘密 λᵢ                                         │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  共享存储（所有方可见）：                                                 │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 所有方的 Paillier 公钥 {Nⱼ}                                    │   │
│  │  • 所有方的 Ring-Pedersen 参数 {(Nⱼ, sⱼ, tⱼ)}                    │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  临时存储（预签名后擦除）：                                               │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 预签名数据 (R, kᵢ, χᵢ)                                        │   │
│  │  • 签名完成后必须安全擦除！                                        │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  警告：如果预签名数据泄露，攻击者可以计算私钥！                            │
│        因为 χ = kx，若知道 k 和 χ，可以求出 x                            │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 13.6 协议执行时序

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           实际部署场景                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  场景 1：在线签名（低延迟要求）                                           │
│                                                                         │
│    时间 ──────────────────────────────────────────────────────→         │
│                                                                         │
│    ┌──────┐  ┌────────┐           ┌────────┐ ┌────┐                    │
│    │密钥  │  │辅助信息│           │ 预签名 │ │签名│                    │
│    │生成  │  │(+刷新) │  ← 空闲 → │ 4轮    │ │1轮 │                    │
│    └──────┘  └────────┘           └────────┘ └────┘                    │
│       ↑          ↑                     ↑         ↑                     │
│     初始化    定期刷新              消息到达   5轮后完成                   │
│                                                                         │
│    特点：消息到达后需要等待 5 轮才能得到签名                              │
│                                                                         │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  场景 2：离线/批量预签名（高吞吐量）                                       │
│                                                                         │
│    时间 ──────────────────────────────────────────────────────→         │
│                                                                         │
│    ┌──────┐  ┌────────┐  ┌────────┐  ┌────────┐  ┌────────┐           │
│    │密钥  │  │辅助信息│  │预签名₁ │  │预签名₂ │  │预签名₃ │ ...        │
│    │生成  │  │(+刷新) │  │ 4轮    │  │ 4轮    │  │ 4轮    │            │
│    └──────┘  └────────┘  └────────┘  └────────┘  └────────┘            │
│                               │           │           │                 │
│                               ▼           ▼           ▼                 │
│                          存储预签名数据到队列                             │
│                                                                         │
│    ← 后续消息到达 →                                                      │
│                                                                         │
│    消息 m₁ ──→ 取预签名₁ ──→ ┌────┐ ──→ 签名₁                           │
│    消息 m₂ ──→ 取预签名₂ ──→ │1轮 │ ──→ 签名₂                           │
│    消息 m₃ ──→ 取预签名₃ ──→ └────┘ ──→ 签名₃                           │
│                                                                         │
│    特点：消息到达后只需 1 轮即可完成签名                                  │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 13.7 错误处理与重试

```
┌─────────────────────────────────────────────────────────────────────────┐
│                            错误处理策略                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  阶段          │  可能的错误              │  处理方式                    │
│ ───────────────┼──────────────────────────┼────────────────────────────  │
│                │                          │                              │
│  密钥生成      │  承诺验证失败            │  中止，重新开始               │
│               │  Schnorr 证明无效         │  标记恶意方，排除后重试       │
│                │                          │                              │
│  辅助信息      │  Π_mod/Π_prm/Π_fac 失败  │  标记恶意方，可能需要         │
│               │                          │  重新进行密钥生成              │
│                │                          │                              │
│  预签名        │  Π_enc 证明失败          │  中止本次预签名，重试          │
│               │  MtA 证明失败            │  标记恶意方，排除后重试        │
│               │  一致性检查失败          │  有恶意方，使用识别协议        │
│               │  δ 与 q 不互素           │  极小概率，重新采样 k,γ       │
│                │                          │                              │
│  签名          │  签名验证失败            │  有恶意方发送错误份额         │
│               │                          │  使用识别协议定位恶意方        │
│                │                          │                              │
└─────────────────────────────────────────────────────────────────────────┘

识别协议：当检测到不一致时，可以通过公开中间值来定位恶意方。
         例如，在签名阶段，如果验证失败，各方可以公开 σᵢ 并验证
         每个份额是否正确。
```

---

## 总结

```
┌─────────────────────────────────────────────────────────────────┐
│                    协议结构总结                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  阶段        │  运行时机      │  输出           │  轮数          │
│ ─────────────┼────────────────┼─────────────────┼─────────────  │
│  密钥生成    │  一次          │  X, xᵢ         │  3            │
│  辅助信息    │  定期          │  Nᵢ, sᵢ, tᵢ   │  2            │
│  预签名      │  每次签名前    │  R, kᵢ, χᵢ    │  4            │
│  签名        │  消息已知后    │  (r, σ)        │  1            │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  关键技术：                                                      │
│    1. 承诺-解承诺：防止影响公钥分布                               │
│    2. Schnorr 证明：证明知道私钥份额                              │
│    3. 0 的秘密共享：刷新密钥而不改变私钥                          │
│    4. Paillier 加密：安全传输份额                                 │
│    5. 多种 ZK 证明：确保恶意方无法作弊                            │
│    6. MtA 协议：将乘法转换为加法份额                              │
│    7. 掩码技术：计算 g^(k⁻¹) 而不暴露 k                          │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  预签名阶段的核心：                                              │
│    输入：kᵢ, γᵢ（随机数），xᵢ（私钥份额）                        │
│    输出：R = g^(k⁻¹), kᵢ, χᵢ = (kx)ᵢ                            │
│    技术：δ = kγ 用于掩码，MtA 用于乘法转加法                      │
│                                                                 │
│  签名阶段的核心：                                                │
│    输入：预签名数据 + 消息哈希 m                                  │
│    σᵢ = kᵢm + rχᵢ                                               │
│    σ = Σσᵢ = km + rkx = k(m + rx)                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

