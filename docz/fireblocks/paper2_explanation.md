# ECDSA 与门限 ECDSA 详细讲解

本文档是对 paper2.md 中 ECDSA 相关段落的讲解。

---

## 一、普通（非门限）ECDSA

### 1.1 签名的形式

ECDSA签名是一个**二元组**：

```
签名 = (ρ, σ)

其中：
  σ = k · (m + ρ·x)
```

各符号含义：

| 符号 | 类型 | 含义 |
|------|------|------|
| x | 私钥 | 属于有限域 Fq，只有签名者知道 |
| m | 消息哈希 | m = H(msg)，把消息映射到域元素 |
| k | 随机数 | 从 Fq 中均匀随机选取，每次签名都不同 |
| ρ | 签名的第一部分 | 是椭圆曲线上某点的 x 坐标 |

### 1.2 什么是"x投影"？

椭圆曲线上的点是二维坐标 (x坐标, y坐标)。

**"x投影"就是取点的 x 坐标。**

```
椭圆曲线上的点 R = g^(k的逆)

R 在平面上是一个点 (x_R, y_R)

ρ = x_R mod q   ← 这就是"x投影"
```

### 1.3 验证签名

已知：公钥 X = g^x，消息 msg，签名 (ρ, σ)

验证步骤：
```
1. 计算 m = H(msg)

2. 计算椭圆曲线上的点：
   R' = g^(m/σ) · X^(ρ/σ)
   
   注：这里的除法是模q的除法，即乘以逆元

3. 检查：R' 的 x 坐标 是否等于 ρ？
   - 相等 → 签名有效
   - 不等 → 签名无效
```

**为什么验证能成功？**

```
R' = g^(m/σ) · X^(ρ/σ)
   = g^(m/σ) · g^(x·ρ/σ)      因为 X = g^x
   = g^((m + ρx)/σ)           合并指数
   = g^((m + ρx)/(k(m + ρx))) 代入 σ = k(m + ρx)
   = g^(1/k)
   = 原来的 R

所以 R' 的 x 坐标确实等于 ρ
```

---

## 二、门限 ECDSA 概述（Gennaro 和 Goldfeder）

### 2.1 设定

- n 个参与方：P₁, P₂, ..., Pₙ
- 安全门限 t = n-1（需要所有人参与才能签名）
- 假设：诚实但好奇（每个人都按协议执行，但想偷窥别人的秘密）

### 2.2 密钥的分布式生成

**每个人的操作：**
```
Pᵢ 随机选择自己的私钥份额 xᵢ ∈ Fq
Pᵢ 计算并公开 Xᵢ = g^(xᵢ)
```

**整体的密钥：**
```
私钥（虚拟的）: x = x₁ + x₂ + ... + xₙ   
               → 没有任何人知道这个 x！

公钥（公开的）: X = X₁ · X₂ · ... · Xₙ
               = g^(x₁) · g^(x₂) · ... · g^(xₙ)
               = g^(x₁ + x₂ + ... + xₙ)
               = g^x
```

### 2.3 Paillier 加密系统

每个 Pᵢ 都有一套 Paillier 加密系统：
- 公钥：所有人都知道
- 私钥：只有 Pᵢ 自己知道

记号：
```
encᵢ(m) = 用 Pᵢ 的公钥加密 m
decᵢ(c) = 用 Pᵢ 的私钥解密 c
```

**Paillier 的同态性质**（这是关键！）：

```
符号约定：
  ⊕ 表示密文的"同态加法"运算
  ⊙ 表示密文的"同态标量乘法"运算

性质：
  encᵢ(a) ⊕ encᵢ(b) = encᵢ(a + b)    加密后相乘 = 加密(明文之和)
  c ⊙ encᵢ(a)       = encᵢ(c · a)    常数乘密文 = 加密(常数乘明文)
```

### 2.4 签名过程需要计算什么？

ECDSA 签名需要：σ = k(m + ρx)

展开：σ = k·m + k·ρ·x

分布式计算的挑战：
```
- k = k₁ + k₂ + ... + kₙ  （每人贡献一份）
- x = x₁ + x₂ + ... + xₙ  （已经分片了）
- 但 k·x 怎么算？？？ ← 这是核心难题
```

### 2.5 引入掩码 γ

为了安全地计算 g^(1/k)，引入一个"掩码"：

```
γ = γ₁ + γ₂ + ... + γₙ    每个人随机选 γᵢ
```

**技巧：**
```
g^(1/k) = (g^γ)^(1/(γk))

       = (g^γ₁ · g^γ₂ · ... · g^γₙ)^(1/(γk))
         ↑                           ↑
         每个人公开 g^γᵢ            需要计算 γk
```

### 2.6 份额计算阶段（核心技术）

**目标：** Pᵢ 和 Pⱼ 想共同获得 γⱼ·kᵢ 的份额

**结果要满足：**
```
αᵢ,ⱼ + βⱼ,ᵢ = γⱼ · kᵢ

其中：
  αᵢ,ⱼ 只有 Pᵢ 知道
  βⱼ,ᵢ 只有 Pⱼ 知道
  γⱼ·kᵢ 谁都不知道！
```

**实现步骤：**

```
第1步：Pᵢ 加密自己的 kᵢ
        Kᵢ = encᵢ(kᵢ)
        Pᵢ 把 Kᵢ 发送给 Pⱼ

第2步：Pⱼ 做同态运算
        ① 计算 γⱼ ⊙ Kᵢ = encᵢ(γⱼ · kᵢ)
        ② 随机选择 βⱼ,ᵢ
        ③ 计算 Dᵢ,ⱼ = (γⱼ ⊙ Kᵢ) ⊕ encᵢ(-βⱼ,ᵢ)
                   = encᵢ(γⱼ · kᵢ - βⱼ,ᵢ)
        Pⱼ 把 Dᵢ,ⱼ 发送给 Pᵢ

第3步：Pᵢ 解密
        αᵢ,ⱼ = decᵢ(Dᵢ,ⱼ) = γⱼ · kᵢ - βⱼ,ᵢ

验证：αᵢ,ⱼ + βⱼ,ᵢ = (γⱼ · kᵢ - βⱼ,ᵢ) + βⱼ,ᵢ = γⱼ · kᵢ  ✓
```

**同样的方法**用于计算 xⱼ·kᵢ 的份额 (α̂ᵢ,ⱼ 和 β̂ⱼ,ᵢ)。

### 2.7 计算 δᵢ（γk 的份额）

每个 Pᵢ 计算：
```
δᵢ = γᵢ·kᵢ + Σⱼ≠ᵢ (αᵢ,ⱼ + βᵢ,ⱼ)
```

验证所有 δᵢ 之和等于 γk：
```
δ₁ + δ₂ + ... + δₙ = γ·k  ✓
```

### 2.8 计算 g^(1/k)

每个 Pᵢ 公开两个值：
```
Γᵢ = g^γᵢ    （γᵢ 的"群承诺"）
δᵢ           （γk 的份额）
```

然后计算：
```
g^(1/k) = (∏ᵢ Γᵢ)^((Σⱼ δⱼ)⁻¹)
        = (g^γ)^(1/(γk))
        = g^(1/k)
```

### 2.9 计算签名份额

每个 Pᵢ 计算自己的签名份额：
```
σᵢ = kᵢ·m + ρ·(xᵢ·kᵢ + Σⱼ≠ᵢ (α̂ᵢ,ⱼ + β̂ᵢ,ⱼ))
       ↑         ↑
    消息部分   私钥部分（kx的份额）
```

最终签名：
```
σ = σ₁ + σ₂ + ... + σₙ = k(m + ρx)
```

### 2.10 计算示例（n=3 的情况）

为了更直观地理解协议，我们用一个**三方（n=3）**的具体数值例子来演示。

**注意：** 为了简化，我们使用小数字。实际中这些数字都是256位以上的大整数。

#### 设定

```
假设有限域 Fq，其中 q = 23（一个小素数，仅用于演示）
所有运算都是 mod 23

参与方：P₁, P₂, P₃
```

#### 第一步：密钥生成

```
P₁ 随机选择私钥份额：x₁ = 5
P₂ 随机选择私钥份额：x₂ = 7
P₃ 随机选择私钥份额：x₃ = 4

完整私钥（没有人知道）：x = x₁ + x₂ + x₃ = 5 + 7 + 4 = 16
公钥：X = g^16（椭圆曲线上的点）
```

#### 第二步：签名准备——生成随机数份额

```
P₁ 随机选择：k₁ = 3,  γ₁ = 4
P₂ 随机选择：k₂ = 6,  γ₂ = 2
P₃ 随机选择：k₃ = 2,  γ₃ = 5

完整随机数（没有人知道）：
  k = k₁ + k₂ + k₃ = 3 + 6 + 2 = 11
  γ = γ₁ + γ₂ + γ₃ = 4 + 2 + 5 = 11
```

#### 第三步：份额计算——计算 γⱼ·kᵢ 的份额

每对参与方之间都要进行份额计算。以 P₁ 为例，需要和 P₂、P₃ 分别计算。

**P₁ 与 P₂ 的交互：计算 γ₂·k₁ = 2×3 = 6 的份额**

```
P₁ 操作：
  加密 K₁ = enc₁(k₁) = enc₁(3)
  发送 K₁ 给 P₂

P₂ 操作：
  随机选择 β₂,₁ = 10
  同态计算 D₁,₂ = γ₂ ⊙ K₁ ⊕ enc₁(-β₂,₁)
                = enc₁(2×3 - 10)
                = enc₁(-4) = enc₁(19)  [因为 -4 ≡ 19 (mod 23)]
  发送 D₁,₂ 给 P₁

P₁ 操作：
  解密 α₁,₂ = dec₁(D₁,₂) = 19

验证：α₁,₂ + β₂,₁ = 19 + 10 = 29 ≡ 6 (mod 23) = γ₂·k₁ ✓
```

**P₁ 与 P₃ 的交互：计算 γ₃·k₁ = 5×3 = 15 的份额**

```
P₁ 操作：
  发送 K₁ = enc₁(3) 给 P₃

P₃ 操作：
  随机选择 β₃,₁ = 7
  同态计算 D₁,₃ = γ₃ ⊙ K₁ ⊕ enc₁(-β₃,₁)
                = enc₁(5×3 - 7)
                = enc₁(8)
  发送 D₁,₃ 给 P₁

P₁ 操作：
  解密 α₁,₃ = dec₁(D₁,₃) = 8

验证：α₁,₃ + β₃,₁ = 8 + 7 = 15 = γ₃·k₁ ✓
```

**类似地，完成所有配对的份额计算：**

```
P₂ 与 P₁：γ₁·k₂ = 4×6 = 24 ≡ 1 (mod 23)
  β₁,₂ = 8,  α₂,₁ = 1 - 8 + 23 = 16
  验证：16 + 8 = 24 ≡ 1 (mod 23) ✓

P₂ 与 P₃：γ₃·k₂ = 5×6 = 30 ≡ 7 (mod 23)
  β₃,₂ = 12,  α₂,₃ = 7 - 12 + 23 = 18
  验证：18 + 12 = 30 ≡ 7 (mod 23) ✓

P₃ 与 P₁：γ₁·k₃ = 4×2 = 8
  β₁,₃ = 3,  α₃,₁ = 8 - 3 = 5
  验证：5 + 3 = 8 ✓

P₃ 与 P₂：γ₂·k₃ = 2×2 = 4
  β₂,₃ = 6,  α₃,₂ = 4 - 6 + 23 = 21
  验证：21 + 6 = 27 ≡ 4 (mod 23) ✓
```

#### 第四步：计算 δᵢ（γk 的份额）

```
P₁ 计算：
  δ₁ = γ₁·k₁ + (α₁,₂ + β₁,₂) + (α₁,₃ + β₁,₃)
     = 4×3 + (19 + 8) + (8 + 3)
     = 12 + 27 + 11
     = 50 ≡ 4 (mod 23)

P₂ 计算：
  δ₂ = γ₂·k₂ + (α₂,₁ + β₂,₁) + (α₂,₃ + β₂,₃)
     = 2×6 + (16 + 10) + (18 + 6)
     = 12 + 26 + 24
     = 62 ≡ 16 (mod 23)

P₃ 计算：
  δ₃ = γ₃·k₃ + (α₃,₁ + β₃,₁) + (α₃,₂ + β₃,₂)
     = 5×2 + (5 + 7) + (21 + 12)
     = 10 + 12 + 33
     = 55 ≡ 9 (mod 23)

验证：δ₁ + δ₂ + δ₃ = 4 + 16 + 9 = 29 ≡ 6 (mod 23)

而 γ·k = 11×11 = 121 ≡ 121 - 5×23 = 121 - 115 = 6 (mod 23) ✓
```

#### 第五步：计算 g^(1/k)

```
各方公开：
  Γ₁ = g^γ₁ = g^4
  Γ₂ = g^γ₂ = g^2
  Γ₃ = g^γ₃ = g^5
  δ₁ = 4,  δ₂ = 16,  δ₃ = 9

计算：
  Γ = Γ₁ · Γ₂ · Γ₃ = g^4 · g^2 · g^5 = g^11 = g^γ
  δ = δ₁ + δ₂ + δ₃ = 29 ≡ 6 (mod 23) = γk

  g^(1/k) = Γ^(1/δ) = (g^11)^(1/6)

  计算 1/6 mod 23（即 6 的逆元）：
  6 × 4 = 24 ≡ 1 (mod 23)，所以 6⁻¹ = 4

  计算 g^(1/k)：
  g^(1/k) = (g^γ)^(1/(γk)) = (g^11)^4 = g^44

  验证：1/k mod 23
  k = 11，需要找 11⁻¹ mod 23
  11 × 21 = 231 = 10×23 + 1 ≡ 1 (mod 23)
  所以 11⁻¹ = 21

  g^44 mod 群阶 = g^(44 mod 23) = g^21 = g^(1/k) ✓
```

#### 第六步：计算 kx 的份额（χᵢ）

用同样的份额计算方法，计算 xⱼ·kᵢ 的份额。目标：k·x = 11×16 = 176 ≡ 15 (mod 23)

```
定义：α̂ᵢ,ⱼ + β̂ⱼ,ᵢ = xⱼ · kᵢ

完整计算每对份额：

P₁ 与 P₂：x₂·k₁ = 7×3 = 21
  β̂₂,₁ = 9,  α̂₁,₂ = 21 - 9 = 12
  验证：12 + 9 = 21 ✓

P₁ 与 P₃：x₃·k₁ = 4×3 = 12
  β̂₃,₁ = 5,  α̂₁,₃ = 12 - 5 = 7
  验证：7 + 5 = 12 ✓

P₂ 与 P₁：x₁·k₂ = 5×6 = 30 ≡ 7 (mod 23)
  β̂₁,₂ = 4,  α̂₂,₁ = 7 - 4 = 3
  验证：3 + 4 = 7 ✓

P₂ 与 P₃：x₃·k₂ = 4×6 = 24 ≡ 1 (mod 23)
  β̂₃,₂ = 8,  α̂₂,₃ = 1 - 8 + 23 = 16
  验证：16 + 8 = 24 ≡ 1 (mod 23) ✓

P₃ 与 P₁：x₁·k₃ = 5×2 = 10
  β̂₁,₃ = 6,  α̂₃,₁ = 10 - 6 = 4
  验证：4 + 6 = 10 ✓

P₃ 与 P₂：x₂·k₃ = 7×2 = 14
  β̂₂,₃ = 11,  α̂₃,₂ = 14 - 11 = 3
  验证：3 + 11 = 14 ✓
```

计算 χᵢ（kx 的份额）：

```
χ₁ = x₁·k₁ + (α̂₁,₂ + β̂₁,₂) + (α̂₁,₃ + β̂₁,₃)
   = 5×3 + (12 + 4) + (7 + 6)
   = 15 + 16 + 13
   = 44 ≡ 21 (mod 23)

χ₂ = x₂·k₂ + (α̂₂,₁ + β̂₂,₁) + (α̂₂,₃ + β̂₂,₃)
   = 7×6 + (3 + 9) + (16 + 11)
   = 42 + 12 + 27
   = 81 ≡ 12 (mod 23)

χ₃ = x₃·k₃ + (α̂₃,₁ + β̂₃,₁) + (α̂₃,₂ + β̂₃,₂)
   = 4×2 + (4 + 5) + (3 + 8)
   = 8 + 9 + 11
   = 28 ≡ 5 (mod 23)

验证：χ₁ + χ₂ + χ₃ = 21 + 12 + 5 = 38 ≡ 15 (mod 23)
      k·x = 11×16 = 176 ≡ 15 (mod 23) ✓
```

#### 第七步：计算签名

```
消息哈希：m = 11
ρ = g^(1/k) 的 x 坐标 = 15（假设椭圆曲线点的 x 坐标）

签名份额：
  σ₁ = k₁·m + ρ·χ₁ = 3×11 + 15×21 = 33 + 315 = 348 ≡ 3 (mod 23)
  σ₂ = k₂·m + ρ·χ₂ = 6×11 + 15×12 = 66 + 180 = 246 ≡ 16 (mod 23)
  σ₃ = k₃·m + ρ·χ₃ = 2×11 + 15×5 = 22 + 75 = 97 ≡ 5 (mod 23)

最终签名：
  σ = σ₁ + σ₂ + σ₃ = 3 + 16 + 5 = 24 ≡ 1 (mod 23)

签名输出：(ρ, σ) = (15, 1)

验证：σ 应该等于 k(m + ρx) mod q
  k(m + ρx) = 11×(11 + 15×16)
            = 11×(11 + 240)
            = 11×251
            = 11×(251 mod 23)
            = 11×21
            = 231 ≡ 1 (mod 23) ✓
```

#### 关键观察

```
整个过程中：
✓ P₁ 不知道：x₂=7, x₃=4, k₂=6, k₃=2, γ₂=2, γ₃=5
✓ P₂ 不知道：x₁=5, x₃=4, k₁=3, k₃=2, γ₁=4, γ₃=5
✓ P₃ 不知道：x₁=5, x₂=7, k₁=3, k₂=6, γ₁=4, γ₂=2
✓ 没有人知道完整的：x=16, k=11, γ=11
✓ 但三人合作成功产生了有效签名！

安全性保证：
  - 任意两方联合也无法恢复第三方的秘密
  - 需要所有三方参与才能生成有效签名
```

---

## 三、协议总结

### 四轮通信

```
第1轮：Pᵢ 采样 kᵢ, γᵢ，发送 Kᵢ = encᵢ(kᵢ) 给所有人

第2轮：Pᵢ 收到所有 Kⱼ 后，计算并发送 (Dⱼ,ᵢ, D̂ⱼ,ᵢ) 给每个 Pⱼ

第3轮：Pᵢ 收到所有 (Dᵢ,ⱼ, D̂ᵢ,ⱼ) 后，发送 (Γᵢ = g^γᵢ, δᵢ) 给所有人

第4轮：Pᵢ 收到所有 (Γⱼ, δⱼ) 后，发送 σᵢ 给所有人

输出：签名 (ρ, σ)，其中 ρ 来自 g^(1/k)，σ = Σσᵢ
```

### 安全性

**诚实但好奇情况下：**
- 最多 n-1 个参与方联合，也无法获得私钥 x 的任何信息
- 直到发布 σᵢ 那一刻

**恶意情况下的问题：**
- 如果有人发送错误的值，诚实方的 σᵢ 可能泄露私钥信息
- Gennaro 和 Goldfeder 的解决方案需要额外 5 轮来验证正确性
- 本论文的改进：在不增加轮数的情况下保证安全

---

## 四、本论文协议概述

这是**本论文提出的改进协议**，与 Gennaro & Goldfeder 协议有重要区别。

### 4.1 基本设定

```
参与方集合：P = {P₁, P₂, ..., Pₙ}

每个参与方 Pᵢ 都有：
  - Paillier 加密算法 encᵢ（公钥，所有人知道）
  - Paillier 解密算法 decᵢ（私钥，只有 Pᵢ 知道）

"广播" = 把消息发送给所有其他参与方
```

### 4.2 密钥生成阶段

```
第1步：每个 Pᵢ 随机选择私钥份额
        xᵢ ← Fq（从有限域中随机采样）

第2步：计算公钥份额
        Xᵢ = g^(xᵢ)

第3步：承诺-解承诺（防止作弊）
        先承诺 Xᵢ 的值（不公开具体值）
        再解承诺（公开具体值）

        为什么要这样？→ 防止后来的人根据前面的人选择自己的值

第4步：广播 Schnorr NIZK 证明
        证明"我确实知道 Xᵢ 对应的私钥 xᵢ"
```

**什么是 Schnorr NIZK？**

```
NIZK = Non-Interactive Zero-Knowledge（非交互式零知识证明）

Schnorr 证明的作用：
  - Pᵢ 向所有人证明：我知道 xᵢ 使得 Xᵢ = g^(xᵢ)
  - 但不透露 xᵢ 的值
  - 非交互式：证明者生成一个证明字符串，验证者自己检查，无需来回通信
```

### 4.3 辅助信息与密钥刷新阶段

这是本协议的**核心创新之一**，支持主动安全。

#### 第一部分：生成 Paillier 密钥

```
每个 Pᵢ 做：
  1. 本地生成 Paillier 密钥 Nᵢ = pᵢ × qᵢ（两个大素数的乘积）
  2. 把 Nᵢ 发送给所有人
  3. 附带 NIZK 证明：Nᵢ 是"构造良好的"
     即证明 Nᵢ = p × q，其中 p, q 是合适的素数
```

#### 第二部分：密钥刷新（核心！）

**目标：** 更新私钥份额，使旧的份额作废

```
关键思想：让每个人的份额加上一个"0的份额"

每个 Pᵢ 做：
  1. 选择一组随机数 xᵢ¹, xᵢ², ..., xᵢⁿ，满足：
     xᵢ¹ + xᵢ² + ... + xᵢⁿ = 0

     这叫做"0的秘密共享"

  2. 计算并广播：
     - Xᵢʲ = g^(xᵢʲ)     对于每个 j（群元素）
     - Cᵢʲ = encⱼ(xᵢʲ)   对于每个 j（用 Pⱼ 的公钥加密）

  3. 附带 NIZK 证明：
     Cᵢʲ 的明文 mod q = Xᵢʲ 的指数
     （即加密的值和群元素对应）
```

#### 验证与更新

```
验证步骤：
  对于每个 j，检查：
    X₁ʲ · X₂ʲ · ... · Xₙʲ = id_G（群的单位元）

  即：g^(x₁ʲ) · g^(x₂ʲ) · ... · g^(xₙʲ) = g^0 = 1

  这验证了：x₁ʲ + x₂ʲ + ... + xₙʲ = 0

更新份额：
  xᵢ* = xᵢ + Σⱼ decᵢ(Cⱼⁱ) mod q
      = xᵢ + (x₁ⁱ + x₂ⁱ + ... + xₙⁱ)
```

#### 为什么这样能刷新密钥？

```
刷新前：
  私钥 x = x₁ + x₂ + ... + xₙ

刷新后：
  x₁* = x₁ + (x₁¹ + x₂¹ + ... + xₙ¹)   第1列之和
  x₂* = x₂ + (x₁² + x₂² + ... + xₙ²)   第2列之和
  ...

新的私钥：
  x* = x₁* + x₂* + ... + xₙ*
     = (x₁ + x₂ + ... + xₙ) + (所有 xᵢʲ 之和)
     = x + 0     （因为每行之和都是0）
     = x

结论：
  ✓ 私钥 x 没变（公钥也没变）
  ✓ 但每个人的份额都变了
  ✓ 攻击者之前偷到的旧份额现在没用了！
```

### 4.4 预签名阶段

这是本协议的**另一个核心创新**——使用 Paillier 作为承诺方案。

#### 与 G&G 协议的区别

```
G&G 协议：
  Kᵢ = encᵢ(kᵢ) 加密后发给别人做同态运算

本协议（创新）：
  Kᵢ = encᵢ(kᵢ) 不仅用于同态运算
                还作为对 kᵢ 的"承诺"
  Gᵢ = encᵢ(γᵢ) 同样是对 γᵢ 的"承诺"
```

#### 什么是"承诺方案"？

```
承诺方案有两个性质：

1. 绑定性（Binding）：
   一旦承诺了某个值，就不能改变
   即：给定 C = enc(m)，不能找到 m' ≠ m 使得 C 也是 m' 的加密

   Paillier 提供"完美绑定"：数学上不可能作弊

2. 隐藏性（Hiding）：
   承诺不透露具体值
   即：看到 C = enc(m)，无法知道 m 是什么

   Paillier 提供"计算隐藏"：破解需要破解加密
```

#### 预签名的步骤

```
第1步：承诺
  每个 Pᵢ 广播：
    Gᵢ = encᵢ(γᵢ)    γᵢ 的承诺
    Kᵢ = encᵢ(kᵢ)    kᵢ 的承诺

第2步：份额计算（与 G&G 类似）
  计算 xⱼkᵢ 和 γⱼkᵢ 的份额

  同时附带 ZK 证明：
    "我在份额计算中用的值，和我承诺的 Gᵢ, Kᵢ, Xᵢ 是一致的"

第3步：揭示
  交换额外消息，计算 R = g^(1/k)

  同时 ZK 证明消息与承诺一致

最终存储：
  每个 Pᵢ 存储元组 (kᵢ, χᵢ, R)
  其中：
    kᵢ = k 的份额（Σkᵢ = k）
    χᵢ = kx 的份额（Σχᵢ = kx）
    R = g^(1/k) = 签名的 nonce
```

### 4.5 签名阶段

这是最简单的阶段——只需要**一轮**通信！

```
输入：
  - 预签名数据 (R, kᵢ, χᵢ)
  - 待签名消息 msg

每个 Pᵢ 做：
  1. 计算消息哈希：m = H(msg)
  2. 计算 ρ = R 的 x 坐标（mod q）
  3. 计算签名份额：σᵢ = kᵢ·m + ρ·χᵢ mod q
  4. 把 σᵢ 发送给所有人

汇总：
  σ = σ₁ + σ₂ + ... + σₙ

输出签名：(ρ, σ)
```

### 4.6 协议总结对比

```
┌─────────────────────────────────────────────────────────────┐
│                    本协议 vs G&G 协议                        │
├─────────────────────────────────────────────────────────────┤
│ 特性              │ G&G 协议        │ 本协议               │
├─────────────────────────────────────────────────────────────┤
│ 签名轮数          │ 8 轮            │ 4 轮                 │
│ 预签名后          │ 还需交互        │ 非交互式（1轮）       │
│ 密钥刷新          │ 不支持          │ 支持                 │
│ 验证份额正确性    │ 额外 5 轮       │ 无需额外轮次          │
│ 承诺方式          │ 普通承诺        │ Paillier 承诺        │
│ ZK 证明效率       │ 一般            │ 更高效               │
│ UC 安全           │ 部分            │ 完整                 │
└─────────────────────────────────────────────────────────────┘
```

### 4.7 计算示例：密钥刷新（n=3 的情况）

为了理解密钥刷新的工作原理，我们用一个**三方（n=3）**的具体数值例子来演示。

#### 设定

```
有限域 Fq，其中 q = 17（小素数，仅用于演示）
参与方：P₁, P₂, P₃
```

#### 刷新前的状态

```
各方的私钥份额：
  P₁ 持有：x₁ = 5
  P₂ 持有：x₂ = 8
  P₃ 持有：x₃ = 3

完整私钥：x = x₁ + x₂ + x₃ = 5 + 8 + 3 = 16 mod 17
公钥：X = g^16
```

#### 第一步：每个人生成"0的秘密共享"

```
P₁ 选择满足 x₁¹ + x₁² + x₁³ = 0 的随机数：
  x₁¹ = 7,  x₁² = 4,  x₁³ = 6
  验证：7 + 4 + 6 = 17 ≡ 0 (mod 17) ✓

P₂ 选择满足 x₂¹ + x₂² + x₂³ = 0 的随机数：
  x₂¹ = 3,  x₂² = 11,  x₂³ = 3
  验证：3 + 11 + 3 = 17 ≡ 0 (mod 17) ✓

P₃ 选择满足 x₃¹ + x₃² + x₃³ = 0 的随机数：
  x₃¹ = 9,  x₃² = 2,  x₃³ = 6
  验证：9 + 2 + 6 = 17 ≡ 0 (mod 17) ✓
```

#### 第二步：构建刷新矩阵

```
            发给P₁   发给P₂   发给P₃   行和
P₁ 生成：    x₁¹=7    x₁²=4    x₁³=6    = 17 ≡ 0 (mod 17)
P₂ 生成：    x₂¹=3    x₂²=11   x₂³=3    = 17 ≡ 0 (mod 17)
P₃ 生成：    x₃¹=9    x₃²=2    x₃³=6    = 17 ≡ 0 (mod 17)

列和：       19       17       15
```

#### 第三步：广播并验证

```
每个 Pᵢ 广播：
  - 群元素 Xᵢʲ = g^(xᵢʲ) 给所有人（用于验证行和为0）
  - 密文 Cᵢʲ = encⱼ(xᵢʲ) 给 Pⱼ（用于更新份额）

验证每行之和为0：
  对于 P₁ 的行：X₁¹ · X₁² · X₁³ = g^7 · g^4 · g^6 = g^17 = g^0 = 1 ✓
  对于 P₂ 的行：X₂¹ · X₂² · X₂³ = g^3 · g^11 · g^3 = g^17 = g^0 = 1 ✓
  对于 P₃ 的行：X₃¹ · X₃² · X₃³ = g^9 · g^2 · g^6 = g^17 = g^0 = 1 ✓

这验证了每个人生成的份额之和确实为0。
```

#### 第四步：各方解密并更新份额

```
P₁ 解密收到的密文（第1列）：
  dec₁(C₁¹) = x₁¹ = 7  （来自 P₁ 自己）
  dec₁(C₂¹) = x₂¹ = 3  （来自 P₂）
  dec₁(C₃¹) = x₃¹ = 9  （来自 P₃）

P₁ 的新份额：
  x₁* = x₁ + x₁¹ + x₂¹ + x₃¹
      = 5 + 7 + 3 + 9
      = 24 ≡ 7 (mod 17)

P₂ 解密收到的密文（第2列）：
  x₂* = x₂ + x₁² + x₂² + x₃²
      = 8 + 4 + 11 + 2
      = 25 ≡ 8 (mod 17)

P₃ 解密收到的密文（第3列）：
  x₃* = x₃ + x₁³ + x₂³ + x₃³
      = 3 + 6 + 3 + 6
      = 18 ≡ 1 (mod 17)
```

#### 第四步：验证私钥不变

```
刷新后的私钥：
  x* = x₁* + x₂* + x₃*
     = 7 + 8 + 1
     = 16 mod 17
     = x  ✓

私钥不变，但份额全部改变了！

刷新前：(5, 8, 3)
刷新后：(7, 8, 1)
```

#### 安全性意义

```
假设攻击者在第一个纪元偷走了 x₁ = 5

密钥刷新后：
  - x₁ 变成了 x₁* = 7
  - 攻击者持有的 x₁ = 5 已经没用了
  - 即使攻击者在第二个纪元偷走 x₂* = 8
  - 攻击者有 (x₁=5, x₂*=8)，但这不是同一纪元的份额
  - 无法恢复私钥！
```

---

## 五、非交互式零知识证明（NIZK）

### 5.1 什么是零知识证明？

**直观理解：**

```
场景：Alice 想向 Bob 证明她知道某个秘密，但不透露秘密本身

例子：
  Alice 声称知道保险箱密码

  普通证明：告诉 Bob 密码 → Bob 打开保险箱验证
             问题：Bob 现在也知道密码了！

  零知识证明：Alice 当着 Bob 的面打开保险箱
             Bob 相信 Alice 知道密码
             但 Bob 仍然不知道密码是什么
```

**三个性质：**

```
1. 完备性（Completeness）
   如果证明者诚实，验证者一定会接受

2. 可靠性（Soundness）
   如果证明者在撒谎，验证者几乎一定会拒绝

3. 零知识性（Zero-Knowledge）
   验证者除了"陈述是真的"之外，学不到任何信息
```

### 5.2 Σ-协议与 Fiat-Shamir 变换

**Σ-协议** 是一种**三轮交互式**零知识证明：

```
证明者 (Prover)                    验证者 (Verifier)
     │                                   │
     │ ────── 承诺 (Commitment) ──────→  │  第1轮
     │                                   │
     │ ←────── 挑战 (Challenge) ────────  │  第2轮
     │                                   │
     │ ────── 响应 (Response) ────────→  │  第3轮
     │                                   │
                                    验证并接受/拒绝
```

**Fiat-Shamir 变换：** 用哈希函数代替验证者！

```
原来（交互式）：
  证明者 → 承诺 A → 验证者
  证明者 ← 挑战 e ← 验证者（随机选择）
  证明者 → 响应 z → 验证者

Fiat-Shamir（非交互式）：
  证明者自己计算：e = H(A, 其他公开信息)
  证明者发送：(A, z) 给验证者
  验证者自己算 e = H(A, ...) 并验证
```

### 5.3 Paillier 加密与强 RSA 假设

**Paillier 密文形式：**

```
C = (1+N)^x · r^N mod N²

其中：
  N = 公钥（两个大素数的乘积）
  x = 明文（要加密的值）
  r = 随机数（来自 Z*_N，即与 N 互素的数）
```

**强 RSA 假设：**

```
RSA 假设：
  给定 N 和 y = x^e mod N（其中 e 已知）
  很难找到 x

强 RSA 假设（更强的版本）：
  给定 N 和随机的 y
  很难找到任何 (x, e) 使得 x^e = y mod N（其中 e > 1）

  注意：攻击者可以自己选择 e！这比 RSA 假设更强
```

### 5.4 Ring-Pedersen 承诺

**定义：**

```
公共参数：(N, s, t)
  - N 是 RSA 模数
  - s, t 是 Z*_N 中的非平凡二次剩余

承诺计算：
  C = s^m · t^ρ mod N

其中：
  m = 要承诺的值
  ρ = 随机数（用于隐藏）
```

**性质：**

```
绑定性：给定 C，很难找到两个不同的 (m, ρ) 和 (m', ρ') 使得
        s^m · t^ρ = s^m' · t^ρ' mod N

隐藏性：给定 C，无法得知 m 的值（因为 ρ 是随机的）
```

### 5.5 ZK 范围证明

**要证明的关系 R：**

```
公开信息：C₀, N₀, C₁, N₁, s, t
秘密信息：α, β, r

要证明的陈述：
  1. C₀ = (1+N₀)^α · r^(N₀) mod N₀²   ← C₀ 是 α 的 Paillier 加密
  2. C₁ = s^α · t^β mod N₁            ← C₁ 是 α 的 Ring-Pedersen 承诺
  3. α ∈ ±2^ℓ                         ← α 在范围 [-2^ℓ, +2^ℓ] 内

翻译成人话：
  "我知道一个秘密 α，它被加密在 C₀ 里，也被承诺在 C₁ 里，
   而且 α 的绝对值不超过 2^ℓ"
```

**为什么需要范围证明？**

```
Paillier 工作在 Z_N（很大的数，比如 2048 位）
ECDSA 工作在 F_q（椭圆曲线的阶，比如 256 位）

如果攻击者选择 α 是一个超大的数（接近 N），
通过同态运算后的结果可能"溢出"，
攻击者可以通过观察结果推断诚实方的秘密

解决方案：强制证明 α 在合理范围内
```

### 5.6 范围证明协议的四个步骤

**设定：**
- 证明者知道 (α, β, r)
- 验证者只知道 (C₀, N₀, C₁, N₁, s, t)
- ε 是"松弛参数"

```
┌─────────────────────────────────────────────────────────────────┐
│ 第1步：证明者发送承诺                                            │
├─────────────────────────────────────────────────────────────────┤
│   证明者随机选择：                                               │
│     γ ← ±2^(ℓ+ε)        （比 α 的范围稍大）                      │
│     δ ← ±N₁ · 2^ε                                               │
│     ρ ← Z*_{N₀}                                                 │
│                                                                 │
│   计算：                                                        │
│     D₀ = (1+N₀)^γ · ρ^(N₀) mod N₀²   （γ 的 Paillier "承诺"）    │
│     D₁ = s^γ · t^δ mod N₁            （γ 的 Ring-Pedersen 承诺） │
│                                                                 │
│   发送 (D₀, D₁) 给验证者                                         │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ 第2步：验证者发送挑战                                            │
├─────────────────────────────────────────────────────────────────┤
│   验证者随机选择：e ← ±2^ℓ                                       │
│   发送 e 给证明者                                                │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ 第3步：证明者发送响应                                            │
├─────────────────────────────────────────────────────────────────┤
│   证明者计算：                                                   │
│     z₁ = γ + e·α        （"掩盖"后的 α）                         │
│     z₂ = δ + e·β        （"掩盖"后的 β）                         │
│     w  = ρ · r^e mod N₀ （"掩盖"后的 r）                         │
│                                                                 │
│   发送 (z₁, z₂, w) 给验证者                                      │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ 第4步：验证者检查                                                │
├─────────────────────────────────────────────────────────────────┤
│   检查1：z₁ ∈ ±2^(ℓ+ε)   （范围检查）                            │
│                                                                 │
│   检查2：(1+N₀)^(z₁) · w^(N₀) = C₀^e · D₀ mod N₀²                │
│          （Paillier 等式检查）                                   │
│                                                                 │
│   检查3：s^(z₁) · t^(z₂) = C₁^e · D₁ mod N₁                      │
│          （Ring-Pedersen 等式检查）                              │
│                                                                 │
│   全部通过 → 接受；任一失败 → 拒绝                               │
└─────────────────────────────────────────────────────────────────┘
```

### 5.7 协议正确性分析

**完备性（诚实证明者一定能通过）：**

```
检查2 的验证：
  左边 = (1+N₀)^(z₁) · w^(N₀)
       = (1+N₀)^(γ+eα) · (ρ·r^e)^(N₀)
       = (1+N₀)^γ · ρ^(N₀) · (1+N₀)^(eα) · r^(eN₀)
       = D₀ · [(1+N₀)^α · r^(N₀)]^e
       = D₀ · C₀^e
  右边 = C₀^e · D₀

  左边 = 右边 ✓

检查3 类似可验证 ✓
```

**零知识性（验证者学不到秘密）：**

```
关键观察：z₁ = γ + e·α

由于 γ 是从 ±2^(ℓ+ε) 中随机选的（比 e·α 的范围大得多）
z₁ 看起来就是随机的，不透露 α 的信息

类似地，z₂ 和 w 也不透露 β 和 r
```

### 5.8 可靠性证明思路

**特殊可靠性（Special Soundness）：**

```
假设攻击者能对同一个承诺 (D₀, D₁) 回答两个不同的挑战 e ≠ e'

那么我们有两组响应：
  (z₁, z₂, w)   对应挑战 e
  (z₁', z₂', w') 对应挑战 e'

定义差值：
  Δe = e - e'
  Δz₁ = z₁ - z₁'
  Δz₂ = z₂ - z₂'

关键观察：
  z₁ = γ + e·α
  z₁' = γ + e'·α

  所以 Δz₁ = (e - e')·α = Δe · α

  如果 Δe 整除 Δz₁，我们可以提取：
    α = Δz₁ / Δe
```

**强 RSA 归约：**

```
如果 Δe 不整除 Δz（某个组合值）：

  可以利用扩展欧几里得算法
  计算出 t 的某个非平凡根

  这就破解了强 RSA！

结论：
  如果攻击者能欺骗验证者 → 可以破解强 RSA
  强 RSA 是困难的 → 攻击者无法欺骗验证者
```

### 5.9 ZK 范围证明计算示例

为了直观理解，我们用简化的数字演示范围证明协议，**每一步都给出完整计算**。

#### 设定

```
为了演示，使用非常小的数字（实际中是几千位的大数）

Paillier 参数：
  N₀ = 15 = 3 × 5
  N₀² = 225

Ring-Pedersen 参数：
  N₁ = 35 = 5 × 7
  s = 4  （验证：gcd(4,35) = 1 ✓）
  t = 9  （验证：gcd(9,35) = 1 ✓）

范围参数：
  ℓ = 3（即范围是 ±2³ = ±8）
  ε = 2（松弛参数）
  2^(ℓ+ε) = 2^5 = 32
```

#### 证明者的秘密

```
证明者持有的秘密值：
  α = 5  （要证明 |α| ≤ 8，确实满足：|5| = 5 ≤ 8 ✓）
  β = 7  （Ring-Pedersen 承诺的随机数）
  r = 4  （Paillier 加密的随机数，验证 gcd(4,15) = 1 ✓）
```

#### 计算公开承诺 C₀ 和 C₁

**C₀ = Paillier 加密（α 的加密）：**

```
C₀ = (1 + N₀)^α · r^(N₀) mod N₀²
   = (1 + 15)^5 · 4^15 mod 225
   = 16^5 · 4^15 mod 225

分步计算 16^5 mod 225：
  16^1 = 16
  16^2 = 256 = 1×225 + 31 = 31 mod 225
  16^4 = 31^2 = 961 = 4×225 + 61 = 61 mod 225
  16^5 = 16^4 × 16 = 61 × 16 = 976 = 4×225 + 76 = 76 mod 225

分步计算 4^15 mod 225：
  4^1 = 4
  4^2 = 16
  4^4 = 256 = 31 mod 225
  4^8 = 31^2 = 961 = 61 mod 225
  4^15 = 4^8 × 4^4 × 4^2 × 4^1 = 61 × 31 × 16 × 4 mod 225
       = 61 × 31 = 1891 = 8×225 + 91 = 91 mod 225
       = 91 × 16 = 1456 = 6×225 + 106 = 106 mod 225
       = 106 × 4 = 424 = 1×225 + 199 = 199 mod 225

C₀ = 76 × 199 mod 225
   = 15124 = 67×225 + 49 = 49 mod 225

∴ C₀ = 49
```

**C₁ = Ring-Pedersen 承诺（α 的承诺）：**

```
C₁ = s^α · t^β mod N₁
   = 4^5 · 9^7 mod 35

分步计算 4^5 mod 35：
  4^1 = 4
  4^2 = 16
  4^4 = 256 = 7×35 + 11 = 11 mod 35
  4^5 = 4^4 × 4 = 11 × 4 = 44 = 1×35 + 9 = 9 mod 35

分步计算 9^7 mod 35：
  9^1 = 9
  9^2 = 81 = 2×35 + 11 = 11 mod 35
  9^4 = 11^2 = 121 = 3×35 + 16 = 16 mod 35
  9^7 = 9^4 × 9^2 × 9^1 = 16 × 11 × 9 mod 35
      = 16 × 11 = 176 = 5×35 + 1 = 1 mod 35
      = 1 × 9 = 9 mod 35

C₁ = 9 × 9 mod 35 = 81 mod 35 = 11

∴ C₁ = 11
```

#### 第1步：证明者生成承诺

```
证明者随机选择掩码值：
  γ = 12  （从 ±2^(ℓ+ε) = ±32 中选，|12| ≤ 32 ✓）
  δ = 50  （从 ±N₁·2^ε = ±35×4 = ±140 中选，|50| ≤ 140 ✓）
  ρ = 7   （从 Z*_{N₀} 中选，gcd(7,15) = 1 ✓）
```

**计算 D₀ = γ 的 Paillier "承诺"：**

```
D₀ = (1 + N₀)^γ · ρ^(N₀) mod N₀²
   = 16^12 · 7^15 mod 225

分步计算 16^12 mod 225：
  16^1 = 16
  16^2 = 31 mod 225（前面已算）
  16^4 = 61 mod 225
  16^8 = 61^2 = 3721 = 16×225 + 121 = 121 mod 225
  16^12 = 16^8 × 16^4 = 121 × 61 mod 225
        = 7381 = 32×225 + 181 = 181 mod 225

分步计算 7^15 mod 225：
  7^1 = 7
  7^2 = 49
  7^4 = 49^2 = 2401 = 10×225 + 151 = 151 mod 225
  7^8 = 151^2 = 22801 = 101×225 + 76 = 76 mod 225

  7^15 = 7^8 × 7^4 × 7^2 × 7^1 mod 225

  逐步计算：
    7^8 × 7^4 = 76 × 151 = 11476
    11476 ÷ 225 = 51.00..., 51×225 = 11475
    11476 - 11475 = 1 mod 225

    1 × 7^2 = 1 × 49 = 49 mod 225

    49 × 7^1 = 49 × 7 = 343 = 1×225 + 118 = 118 mod 225

  ∴ 7^15 = 118 mod 225

D₀ = 16^12 × 7^15 mod 225
   = 181 × 118 mod 225
   = 21358
   = 94×225 + 208 = 208 mod 225

∴ D₀ = 208
```

**计算 D₁ = γ 的 Ring-Pedersen 承诺：**

```
D₁ = s^γ · t^δ mod N₁
   = 4^12 · 9^50 mod 35

分步计算 4^12 mod 35：
  4^1 = 4
  4^2 = 16
  4^4 = 11 mod 35（前面已算）
  4^8 = 11^2 = 121 = 3×35 + 16 = 16 mod 35
  4^12 = 4^8 × 4^4 = 16 × 11 = 176 = 5×35 + 1 = 1 mod 35

分步计算 9^50 mod 35：
  先找 9 的阶：
  9^1 = 9
  9^2 = 11 mod 35
  9^4 = 16 mod 35
  9^6 = 9^4 × 9^2 = 16 × 11 = 176 = 1 mod 35

  所以 9 的阶是 6，即 9^6 ≡ 1 (mod 35)

  50 = 6×8 + 2，所以 9^50 = 9^(6×8+2) = (9^6)^8 × 9^2 = 1^8 × 11 = 11 mod 35

D₁ = 1 × 11 mod 35 = 11

∴ D₁ = 11

证明者发送 (D₀, D₁) = (208, 11) 给验证者
```

#### 第2步：验证者发送挑战

```
验证者随机选择：
  e = 3（从 ±2^ℓ = ±8 中选，|3| ≤ 8 ✓）

验证者发送 e = 3 给证明者
```

#### 第3步：证明者计算响应

```
z₁ = γ + e·α
   = 12 + 3×5
   = 12 + 15
   = 27

z₂ = δ + e·β
   = 50 + 3×7
   = 50 + 21
   = 71

w = ρ · r^e mod N₀
  = 7 · 4^3 mod 15
  = 7 · 64 mod 15

  64 mod 15 = 64 - 4×15 = 64 - 60 = 4

  = 7 × 4 mod 15
  = 28 mod 15
  = 28 - 15 = 13

∴ z₁ = 27, z₂ = 71, w = 13

证明者发送 (z₁, z₂, w) = (27, 71, 13) 给验证者
```

#### 第4步：验证者检查

**检查1：范围检查**

```
检查 z₁ ∈ ±2^(ℓ+ε) = ±32

z₁ = 27
|27| = 27 ≤ 32 ✓

范围检查通过！
```

**检查2：Paillier 等式验证**

```
验证：(1+N₀)^z₁ · w^N₀ ≡ C₀^e · D₀ (mod N₀²)

左边 = (1+15)^27 · 13^15 mod 225
     = 16^27 · 13^15 mod 225

计算 16^27 mod 225：
  16^1 = 16
  16^2 = 31
  16^4 = 61
  16^8 = 121
  16^16 = 121^2 = 14641 = 65×225 + 16 = 16 mod 225
  16^27 = 16^16 × 16^8 × 16^2 × 16^1 mod 225
        = 16 × 121 = 1936 = 8×225 + 136 = 136 mod 225
        = 136 × 31 = 4216 = 18×225 + 166 = 166 mod 225
        = 166 × 16 = 2656 = 11×225 + 181 = 181 mod 225

计算 13^15 mod 225：
  13^1 = 13
  13^2 = 169
  13^4 = 169^2 = 28561 = 126×225 + 211 = 211 mod 225
  13^8 = 211^2 = 44521 = 197×225 + 196 = 196 mod 225
  13^15 = 13^8 × 13^4 × 13^2 × 13^1 mod 225
        = 196 × 211 = 41356 = 183×225 + 181 = 181 mod 225
        = 181 × 169 = 30589 = 135×225 + 214 = 214 mod 225
        = 214 × 13 = 2782 = 12×225 + 82 = 82 mod 225

左边 = 181 × 82 mod 225 = 14842 = 65×225 + 217 = 217 mod 225

右边 = C₀^e · D₀ mod 225
     = 49^3 · 208 mod 225

计算 49^3 mod 225：
  49^1 = 49
  49^2 = 2401 = 10×225 + 151 = 151 mod 225
  49^3 = 151 × 49 = 7399 = 32×225 + 199 = 199 mod 225

右边 = 199 × 208 mod 225
     = 41392 = 183×225 + 217 = 217 mod 225

左边 = 217, 右边 = 217
左边 = 右边 ✓

Paillier 等式验证通过！
```

**检查3：Ring-Pedersen 等式验证**

```
验证：s^z₁ · t^z₂ ≡ C₁^e · D₁ (mod N₁)

左边 = 4^27 · 9^71 mod 35

计算 4^27 mod 35：
  先找 4 的阶：
  4^1 = 4
  4^2 = 16
  4^3 = 64 = 29 mod 35
  4^4 = 11
  4^5 = 44 = 9 mod 35
  4^6 = 36 = 1 mod 35

  所以 4 的阶是 6
  27 = 6×4 + 3，所以 4^27 = (4^6)^4 × 4^3 = 1 × 29 = 29 mod 35

计算 9^71 mod 35：
  9 的阶是 6（前面已算）
  71 = 6×11 + 5，所以 9^71 = 9^5 mod 35
  9^5 = 9^4 × 9 = 16 × 9 = 144 = 4×35 + 4 = 4 mod 35

左边 = 29 × 4 mod 35 = 116 = 3×35 + 11 = 11 mod 35

右边 = C₁^e · D₁ mod 35
     = 11^3 · 11 mod 35

计算 11^3 mod 35：
  11^1 = 11
  11^2 = 121 = 3×35 + 16 = 16 mod 35
  11^3 = 16 × 11 = 176 = 5×35 + 1 = 1 mod 35

右边 = 1 × 11 mod 35 = 11

左边 = 11, 右边 = 11
左边 = 右边 ✓

Ring-Pedersen 等式验证通过！
```

**最终结论**

```
所有检查通过：
  ✓ 检查1：z₁ = 27 ∈ ±32（范围检查）
  ✓ 检查2：Paillier 等式（217 = 217）
  ✓ 检查3：Ring-Pedersen 等式（11 = 11）

验证者接受证明！
```

#### 关键观察

```
通过这个协议：

1. 验证者确信 α ∈ ±2^(ℓ+ε) = ±32
   （有个 2^ε = 4 倍的松弛，原始范围是 ±8）

2. 验证者不知道 α 的具体值（5）
   因为 z₁ = 27 = γ + e·α = 12 + 3×5
   验证者只知道 z₁ = 27，但不知道 γ = 12

3. 如果证明者试图作弊（比如声称 α = 100）：
   - 要么范围检查失败（z₁ 会超出范围）
   - 要么等式检查失败（除非能破解强RSA）

4. 为什么等式能验证通过？
   左边：使用 z₁, z₂, w（掩盖后的值）直接计算
   右边：使用 C₀, C₁, D₀, D₁（承诺值）和 e 计算

   因为 z₁ = γ + e·α，代数上可以证明等式成立
```

### 5.10 无条件提取的替代方案

**问题：** 上述证明依赖强 RSA 假设

**解决方案：二进制挑战**

```
修改协议：
  - 去掉 Ring-Pedersen 承诺（D₁ 和 z₂）
  - 挑战 e 只从 {0, 1} 中选择（而不是 ±2^ℓ）

为什么这样就不需要强 RSA？

  Δe ∈ {-1, 0, 1}
  由于 e ≠ e'，所以 Δe ∈ {-1, 1}

  ±1 可以整除任何整数！

  所以 Δe | Δz₁ 无条件成立，不需要任何假设
```

**代价：**

```
缺点：可靠性只有 1/2

  攻击者有 50% 的概率猜对挑战并作弊

解决方案：重复协议多次

  重复 λ 次 → 作弊概率降到 2^(-λ)

  但这会导致证明大小增加 λ 倍
  由于 Paillier 密文很大（几千比特），这代价很高
```

### 5.11 NIZK 总结

```
┌────────────────────────────────────────────────────────────────┐
│                    ZK 范围证明总结                              │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  目的：证明 Paillier 密文的明文在某个范围内                      │
│                                                                │
│  技术路线：                                                    │
│    1. Σ-协议（三轮交互）                                       │
│    2. Fiat-Shamir 变换 → 非交互式                              │
│    3. Ring-Pedersen 承诺 + 强 RSA → 高效可靠性                  │
│                                                                │
│  安全性依赖：                                                  │
│    - Paillier 语义安全（零知识性）                              │
│    - 强 RSA 假设（可靠性）                                      │
│                                                                │
│  在门限签名中的应用：                                          │
│    防止恶意方选择超大的 k 或 γ 来探测诚实方的秘密                │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

