# 底层 Σ-协议详解

本文档详细讲解论文第4章的 Σ-协议（Sigma 协议）。这些协议是门限 ECDSA 中实现安全性的核心零知识证明组件。

---

## 一、Σ-协议总览

### 1.1 什么是 Σ-协议？

Σ-协议是一种特殊的三轮交互式证明协议：

```
证明者 P                                验证者 V
   │                                       │
   │  ① 承诺 A = g^α                       │
   │ ─────────────────────────────────────→│
   │                                       │
   │  ② 挑战 e ←$ 𝔽_q                       │
   │ ←─────────────────────────────────────│
   │                                       │
   │  ③ 响应 z = α + e·x                   │
   │ ─────────────────────────────────────→│
   │                                       │
   │                    验证: g^z = A·X^e  │
```

### 1.2 本协议使用的 Σ-协议

| 协议 | 关系 | 用途 | 设置参数 |
|------|------|------|----------|
| Π^sch | R_sch | 证明知道 X=g^x 的离散对数 x | 无 |
| Π^enc | R_enc | 证明 Paillier 密文加密的值在范围内 | (N̂, s, t) |
| Π^log | R_log | 证明群元素和 Paillier 密文对应同一值 | (N̂, s, t) |
| Π^aff-g | R_aff-g | 证明 Paillier 仿射操作正确（群承诺） | (N̂, s, t) |
| Π^aff-p | R_aff-p | 证明 Paillier 仿射操作正确（Paillier承诺） | (N̂, s, t) |
| Π^mod | R_mod | 证明 N 是 Paillier-Blum 模数 | 无 |
| Π^prm | R_prm | 证明 Ring-Pedersen 参数有效 | 无 |
| Π^fac | R_fac | 证明 N 的因子足够大 | (N̂, s, t) |

### 1.3 设置参数的作用

范围证明需要设置参数 σ = (N̂, s, t)：
- **N̂**：辅助 RSA 模数（安全双素数乘积）
- **s, t**：Ring-Pedersen 承诺参数，满足 s ∈ ⟨t⟩

**关键点**：设置参数由**验证者**生成，不需要可信第三方。

---

## 二、Paillier 加密范围证明 (Π^enc)

### 2.1 证明目标

证明者证明：我知道 k ∈ ±2^ℓ，使得密文 C = enc(k) 是对 k 的正确加密。

**NP 关系**：
```
R_enc = {(𝒥 = ±2^ℓ, C; k, ρ) : k ∈ 𝒥 ∧ C = (1+N₀)^k · ρ^N₀ mod N₀²}
```

### 2.2 协议流程

**公共输入**：(N₀, K)
**证明者秘密**：(k, ρ)，满足 k ∈ ±2^ℓ，K = enc(k; ρ)
**设置参数**：(N̂, s, t)

```
┌────────────────────────────────────────────────────────────────────────┐
│ 第1步：证明者生成承诺                                                   │
├────────────────────────────────────────────────────────────────────────┤
│                                                                        │
│   采样：α ←$ ±2^(ℓ+ε)                                                  │
│         μ ←$ ±2^ℓ · N̂                                                  │
│         r ←$ ℤ*_N₀                                                     │
│         γ ←$ ±2^(ℓ+ε) · N̂                                              │
│                                                                        │
│   计算：S = s^k · t^μ mod N̂           ← Ring-Pedersen 对 k 的承诺       │
│         A = (1+N₀)^α · r^N₀ mod N₀²   ← Paillier 对 α 的加密           │
│         C = s^α · t^γ mod N̂           ← Ring-Pedersen 对 α 的承诺       │
│                                                                        │
│   发送：(S, A, C) → 验证者                                              │
│                                                                        │
├────────────────────────────────────────────────────────────────────────┤
│ 第2步：验证者发送挑战                                                   │
├────────────────────────────────────────────────────────────────────────┤
│                                                                        │
│   采样：e ←$ ±q                                                        │
│                                                                        │
│   发送：e → 证明者                                                      │
│                                                                        │
├────────────────────────────────────────────────────────────────────────┤
│ 第3步：证明者计算响应                                                   │
├────────────────────────────────────────────────────────────────────────┤
│                                                                        │
│   计算：z₁ = α + e·k          ← 掩盖 k                                  │
│         z₂ = r · ρ^e mod N₀   ← 掩盖 ρ                                  │
│         z₃ = γ + e·μ          ← 掩盖 μ                                  │
│                                                                        │
│   发送：(z₁, z₂, z₃) → 验证者                                           │
│                                                                        │
├────────────────────────────────────────────────────────────────────────┤
│ 第4步：验证者检查                                                       │
├────────────────────────────────────────────────────────────────────────┤
│                                                                        │
│   等式检查：                                                            │
│     (1+N₀)^z₁ · z₂^N₀ = A · K^e mod N₀²   ✓                            │
│     s^z₁ · t^z₃ = C · S^e mod N̂           ✓                            │
│                                                                        │
│   范围检查：                                                            │
│     z₁ ∈ ±2^(ℓ+ε)                         ✓                            │
│                                                                        │
└────────────────────────────────────────────────────────────────────────┘
```

### 2.3 安全性分析

**完备性**：协议可能拒绝有效陈述的概率 ≤ q/2^ε

**零知识**：模拟器可以在不知道 k 的情况下生成统计接近的转录本

**可靠性**：基于强 RSA 假设，如果证明被接受，则可以提取出 k

### 2.4 为什么需要 Ring-Pedersen？

Paillier 加密本身无法证明范围，因为：
- Paillier 工作在 ℤ_N² 上，没有自然的"范围"概念
- 需要借助 Ring-Pedersen 承诺在 ℤ_N̂ 上进行范围约束

**技巧**：用 s^k·t^μ 承诺 k，然后证明承诺的值在范围内。

---

## 三、Paillier 仿射操作范围证明 (Π^aff-g)

### 3.1 证明目标

在 MtA 协议中，证明者需要证明：
- 我知道 x ∈ ±2^ℓ 和 y ∈ ±2^ℓ'
- 群元素 X = g^x
- 密文 D = C^x ⊕ enc(y) 是正确计算的

**NP 关系**：
```
R_aff-g = {(𝒥, 𝒥', C, D, Y, X; x, y, ρ, ρ_y) :
           x ∈ 𝒥 ∧ y ∈ 𝒥' ∧ X = g^x ∧
           Y = enc(y; ρ_y) ∧ D = C^x · enc(y; ρ)}
```

### 3.2 协议概览

```
┌────────────────────────────────────────────────────────────────────────┐
│ 公共输入：(𝔾, g, N₀, N₁, C, D, Y, X)                                   │
│ 证明者秘密：(x, y, ρ, ρ_y)                                              │
├────────────────────────────────────────────────────────────────────────┤
│                                                                        │
│ 证明者需要同时证明 5 个关系：                                           │
│                                                                        │
│   ① D = C^x · enc(y)           Paillier 仿射操作                       │
│   ② X = g^x                    群元素对应                              │
│   ③ Y = enc(y)                 y 的加密一致性                          │
│   ④ s^x · t^γ = 对 x 的承诺     x 的范围约束                            │
│   ⑤ s^y · t^δ = 对 y 的承诺     y 的范围约束                            │
│                                                                        │
├────────────────────────────────────────────────────────────────────────┤
│                                                                        │
│ 响应值：                                                                │
│   z₁ = α + e·x        ← 掩盖 x                                         │
│   z₂ = β + e·y        ← 掩盖 y                                         │
│   z₃ = γ + e·m        ← x 的承诺随机数                                  │
│   z₄ = δ + e·μ        ← y 的承诺随机数                                  │
│   w = r · ρ^e         ← Paillier 随机数                                 │
│   w_y = r_y · ρ_y^e   ← Y 的随机数                                      │
│                                                                        │
├────────────────────────────────────────────────────────────────────────┤
│                                                                        │
│ 验证：                                                                  │
│   C^z₁ · (1+N₀)^z₂ · w^N₀ = A · D^e mod N₀²    ✓                       │
│   g^z₁ = B_x · X^e ∈ 𝔾                          ✓                       │
│   (1+N₁)^z₂ · w_y^N₁ = B_y · Y^e mod N₁²       ✓                       │
│   s^z₁ · t^z₃ = E · S^e mod N̂                   ✓                       │
│   s^z₂ · t^z₄ = F · T^e mod N̂                   ✓                       │
│                                                                        │
│ 范围检查：z₁ ∈ ±2^(ℓ+ε), z₂ ∈ ±2^(ℓ'+ε)                                │
│                                                                        │
└────────────────────────────────────────────────────────────────────────┘
```

### 3.3 在 MtA 中的应用

在预签名阶段，当 P_i 对 P_j 的密文 K_j = enc(k_j) 执行仿射操作时：

```
D_{j,i} = K_j ⊙ γ_i ⊕ enc(-β_{i,j})
        = enc(k_j · γ_i - β_{i,j})
```

P_i 需要证明：
1. 确实用了自己的 γ_i（对应群元素 Γ_i = g^γ_i）
2. γ_i 在合法范围内
3. β_{i,j} 在合法范围内

---

## 四、Paillier-Blum 模数证明 (Π^mod)

### 4.1 证明目标

证明 N = p·q 是 Paillier-Blum 模数：
- gcd(N, φ(N)) = 1
- p ≡ q ≡ 3 (mod 4)

### 4.2 协议流程

```
┌────────────────────────────────────────────────────────────────────────┐
│ 公共输入：N                                                            │
│ 证明者秘密：(p, q)，满足 N = p·q                                        │
├────────────────────────────────────────────────────────────────────────┤
│                                                                        │
│ 第1步：证明者选择 w ∈ ℤ_N，雅可比符号 (w|N) = -1                         │
│        发送 w → 验证者                                                  │
│                                                                        │
│ 第2步：验证者发送随机挑战 {y_i ←$ ℤ_N}_{i∈[m]}                          │
│                                                                        │
│ 第3步：对每个 i，证明者计算：                                           │
│        • 找到 a_i, b_i ∈ {0,1} 使得 y'_i = (-1)^a_i · w^b_i · y_i       │
│          有四次根                                                       │
│        • x_i = ⁴√y'_i mod N                                            │
│        • z_i = y_i^(N^(-1) mod φ(N)) mod N                              │
│                                                                        │
│        发送 {(x_i, a_i, b_i), z_i}_{i∈[m]} → 验证者                     │
│                                                                        │
│ 验证：                                                                  │
│   • N 是奇合数                                                          │
│   • 对每个 i：z_i^N = y_i mod N                    ← 证明 gcd(N,φ(N))=1 │
│   • 对每个 i：x_i^4 = (-1)^a_i · w^b_i · y_i mod N ← 证明 p,q ≡ 3(mod4) │
│                                                                        │
└────────────────────────────────────────────────────────────────────────┘
```

### 4.3 关键性质：可提取性

这个协议**只有诚实验证者零知识**！

如果验证者知道 v_i 使得 v_i² = (-1)^a_i · w^b_i · y_i，那么从证明者的响应 x_i 可以：
- 得到 x_i² ≠ ±v_i（以压倒性概率）
- 使用 (x_i², v_i) 分解 N

**应用**：在模拟器中，可以通过编程随机预言机来提取 Paillier 密钥的因子分解。

---

## 五、Ring-Pedersen 参数证明 (Π^prm)

### 5.1 证明目标

证明 s ∈ ⟨t⟩，即 s = t^λ mod N 对于某个 λ。

### 5.2 协议流程

```
┌────────────────────────────────────────────────────────────────────────┐
│ 公共输入：(N, s, t)                                                     │
│ 证明者秘密：λ，满足 s = t^λ mod N                                       │
├────────────────────────────────────────────────────────────────────────┤
│                                                                        │
│ 第1步：证明者采样 {a_i ←$ ℤ_φ(N)}_{i∈[m]}                               │
│        计算 A_i = t^a_i mod N                                           │
│        发送 {A_i}_{i∈[m]} → 验证者                                      │
│                                                                        │
│ 第2步：验证者发送 {e_i ←$ {0,1}}_{i∈[m]}                                │
│                                                                        │
│ 第3步：证明者计算 z_i = a_i + e_i·λ mod φ(N)                            │
│        发送 {z_i}_{i∈[m]} → 验证者                                      │
│                                                                        │
│ 验证：对每个 i，t^z_i = A_i · s^e_i mod N                               │
│                                                                        │
└────────────────────────────────────────────────────────────────────────┘
```

这本质上是对 s = t^λ 的 m 个独立 Schnorr 证明。

---

## 六、无小因子证明 (Π^fac)

### 6.1 证明目标

证明 N = p·q 的因子 p, q 都足够大：p, q > 2^ℓ

**动机**：防止对手选择有小因子的 N，这会破坏安全性。

### 6.2 协议思路

1. 证明者承诺 p 和 q（使用 Ring-Pedersen）
2. 证明这两个承诺的乘积等于 N
3. 证明 p 和 q 都在范围 ±√N · 2^ℓ 内

---

## 七、Schnorr 知识证明 (Π^sch)

### 7.1 经典 Schnorr 协议

```
┌────────────────────────────────────────────────────────────────────────┐
│ 公共输入：(𝔾, q, g, X)                                                  │
│ 证明者秘密：x，满足 X = g^x                                             │
├────────────────────────────────────────────────────────────────────────┤
│                                                                        │
│ 第1步：证明者采样 α ←$ 𝔽_q，计算 A = g^α                                │
│        发送 A → 验证者                                                  │
│                                                                        │
│ 第2步：验证者采样 e ←$ 𝔽_q                                              │
│        发送 e → 证明者                                                  │
│                                                                        │
│ 第3步：证明者计算 z = α + e·x mod q                                     │
│        发送 z → 验证者                                                  │
│                                                                        │
│ 验证：g^z = A · X^e                                                     │
│                                                                        │
└────────────────────────────────────────────────────────────────────────┘
```

### 7.2 在协议中的应用

- **密钥生成**：证明知道公钥份额 X_i = g^x_i 的离散对数
- **密钥刷新**：证明刷新后的公钥份额仍然正确

---

## 八、群元素与 Paillier 加密一致性证明 (Π^log)

### 8.1 证明目标

证明群元素 X = g^x 和 Paillier 密文 C = enc(x) 对应**同一个值 x**。

### 8.2 协议结构

结合了 Π^sch 和 Π^enc：

```
需要同时验证：
  ① X = g^x              ← Schnorr 类型
  ② C = enc(x)           ← Paillier 范围类型
  ③ x ∈ ±2^ℓ             ← 范围约束
```

### 8.3 在预签名中的应用

当 P_i 广播 Δ_i = Γ^k_i 时，需要证明：
- K_i = enc(k_i) 中加密的值
- 与计算 Δ_i 时使用的指数相同

---

## 九、Fiat-Shamir 变换

### 9.1 从交互式到非交互式

所有 Σ-协议通过 Fiat-Shamir 变换转换为 NIZK：

```
交互式                          非交互式
─────────                       ─────────
P → V: A
V → P: e ←$ 挑战空间    ====>   e = H(stmt, A, aux)
P → V: z                        证明 = (A, z)
```

### 9.2 ZK 模块

论文定义了统一的 ZK 模块接口：

```
M(commit, Π, aux, x; τ)   → A        // 生成第一条消息
M(prove, Π, aux, x; w, τ) → (A, z)   // 生成完整证明
M(vrfy, Π, aux, x, ψ)     → 0/1      // 验证证明
```

**commit 操作的作用**：强制对手在知道挑战前承诺 A，用于安全性分析中的提取。

---

## 十、计算示例：Π^enc 证明

### 10.1 设定

使用小参数便于手动验证：
- **Paillier 参数**：p₀ = 3, q₀ = 5, N₀ = 15, N₀² = 225
- **Ring-Pedersen 参数**：N̂ = 35 (= 5×7), t = 4, s = 16 = 4² mod 35（λ = 2）
- **秘密值**：k = 3（要证明的秘密）
- **Paillier 随机数**：ρ = 2（满足 gcd(2, 15) = 1）

### 10.2 第一步：计算 Paillier 密文 K = enc(k)

```
K = (1 + N₀)^k · ρ^N₀ mod N₀²
  = 16^3 · 2^15 mod 225

计算 16^3：
  16^1 = 16
  16^2 = 256
  16^3 = 16 × 256 = 4096

计算 2^15：
  2^1 = 2
  2^2 = 4
  2^4 = 16
  2^8 = 256
  2^15 = 2^8 × 2^4 × 2^2 × 2^1 = 256 × 16 × 4 × 2 = 32768

K = 4096 × 32768 mod 225
  = 134217728 mod 225
  = 134217728 - 596523 × 225
  = 134217728 - 134217675
  = 53

∴ 密文 K = 53
```

### 10.3 第二步：证明者生成承诺

采样随机数：
- α = 7（掩码 k 的随机数）
- μ = 4（Ring-Pedersen 承诺 k 的随机数）
- r = 4（Paillier 承诺 α 的随机数，gcd(4, 15) = 1 ✓）
- γ = 11（Ring-Pedersen 承诺 α 的随机数）

```
计算 S = s^k · t^μ mod N̂（对 k 的 Ring-Pedersen 承诺）：
  s^k = 16^3 mod 35
      = 4096 mod 35
      = 4096 - 117 × 35 = 4096 - 4095 = 1

  t^μ = 4^4 mod 35
      = 256 mod 35
      = 256 - 7 × 35 = 256 - 245 = 11

  S = 1 × 11 mod 35 = 11

计算 A = (1+N₀)^α · r^N₀ mod N₀²（对 α 的 Paillier 加密）：
  (1+N₀)^α = 16^7 mod 225

  16^1 = 16
  16^2 = 256 mod 225 = 31
  16^4 = 31^2 mod 225 = 961 mod 225 = 961 - 4×225 = 961 - 900 = 61
  16^7 = 16^4 × 16^2 × 16^1 mod 225
       = 61 × 31 × 16 mod 225
       = 61 × 31 = 1891 mod 225 = 1891 - 8×225 = 1891 - 1800 = 91
       = 91 × 16 = 1456 mod 225 = 1456 - 6×225 = 1456 - 1350 = 106

  r^N₀ = 4^15 mod 225

  4^1 = 4
  4^2 = 16
  4^4 = 256 mod 225 = 31
  4^8 = 31^2 mod 225 = 961 mod 225 = 61
  4^15 = 4^8 × 4^4 × 4^2 × 4^1 mod 225
       = 61 × 31 × 16 × 4 mod 225
       = 61 × 31 = 1891 mod 225 = 91
       = 91 × 16 = 1456 mod 225 = 106
       = 106 × 4 = 424 mod 225 = 424 - 225 = 199

  A = 106 × 199 mod 225
    = 21094 mod 225
    = 21094 - 93×225 = 21094 - 20925 = 169

计算 C = s^α · t^γ mod N̂（对 α 的 Ring-Pedersen 承诺）：
  s^α = 16^7 mod 35

  16^1 = 16
  16^2 = 256 mod 35 = 256 - 7×35 = 256 - 245 = 11
  16^4 = 11^2 mod 35 = 121 mod 35 = 121 - 3×35 = 121 - 105 = 16
  16^7 = 16^4 × 16^2 × 16^1 mod 35
       = 16 × 11 × 16 mod 35
       = 176 × 16 mod 35
       = 176 mod 35 = 176 - 5×35 = 1
       = 1 × 16 = 16

  t^γ = 4^11 mod 35

  4^1 = 4
  4^2 = 16
  4^4 = 256 mod 35 = 11
  4^8 = 11^2 mod 35 = 121 mod 35 = 16
  4^11 = 4^8 × 4^2 × 4^1 mod 35
       = 16 × 16 × 4 mod 35
       = 256 × 4 mod 35
       = 11 × 4 = 44 mod 35 = 9

  C = 16 × 9 mod 35 = 144 mod 35 = 144 - 4×35 = 4

∴ 承诺值：S = 11, A = 169, C = 4
```

### 10.4 第三步：挑战与响应

验证者发送挑战：e = 2

```
证明者计算响应：

z₁ = α + e·k = 7 + 2×3 = 13

z₂ = r · ρ^e mod N₀
   = 4 × 2^2 mod 15
   = 4 × 4 mod 15
   = 16 mod 15 = 1

z₃ = γ + e·μ = 11 + 2×4 = 19

∴ 响应值：z₁ = 13, z₂ = 1, z₃ = 19
```

### 10.5 第四步：验证者检查

```
检查 1：(1+N₀)^z₁ · z₂^N₀ = A · K^e mod N₀²

左边：
  (1+N₀)^z₁ = 16^13 mod 225

  16^1 = 16
  16^2 = 31 (已计算)
  16^4 = 61 (已计算)
  16^8 = 61^2 mod 225 = 3721 mod 225 = 3721 - 16×225 = 3721 - 3600 = 121
  16^13 = 16^8 × 16^4 × 16^1 mod 225
        = 121 × 61 × 16 mod 225
        = 121 × 61 = 7381 mod 225 = 7381 - 32×225 = 7381 - 7200 = 181
        = 181 × 16 = 2896 mod 225 = 2896 - 12×225 = 2896 - 2700 = 196

  z₂^N₀ = 1^15 = 1

  左边 = 196 × 1 = 196

右边：
  K^e = 53^2 mod 225 = 2809 mod 225 = 2809 - 12×225 = 2809 - 2700 = 109

  A · K^e = 169 × 109 mod 225
          = 18421 mod 225
          = 18421 - 81×225 = 18421 - 18225 = 196

  左边 = 右边 = 196 ✓

检查 2：s^z₁ · t^z₃ = C · S^e mod N̂

左边：
  s^z₁ = 16^13 mod 35

  16^1 = 16
  16^2 = 11 (已计算)
  16^4 = 16 (已计算)
  16^8 = 16^2 mod 35 = 256 mod 35 = 11
  16^13 = 16^8 × 16^4 × 16^1 mod 35
        = 11 × 16 × 16 mod 35
        = 176 × 16 mod 35
        = 1 × 16 = 16

  t^z₃ = 4^19 mod 35

  4^1 = 4
  4^2 = 16
  4^4 = 11 (已计算)
  4^8 = 16 (已计算)
  4^16 = 16^2 mod 35 = 11
  4^19 = 4^16 × 4^2 × 4^1 mod 35
       = 11 × 16 × 4 mod 35
       = 176 × 4 mod 35
       = 1 × 4 = 4

  左边 = 16 × 4 mod 35 = 64 mod 35 = 29

右边：
  S^e = 11^2 mod 35 = 121 mod 35 = 16

  C · S^e = 4 × 16 mod 35 = 64 mod 35 = 29

  左边 = 右边 = 29 ✓

范围检查：z₁ = 13 ∈ 合理范围 ✓
```

### 10.6 验证总结

```
┌─────────────────────────────────────────────────────────────────┐
│                    Π^enc 证明验证通过                           │
├─────────────────────────────────────────────────────────────────┤
│  公共输入：N₀ = 15, K = 53                                      │
│  设置参数：N̂ = 35, s = 16, t = 4                                │
│  承诺：S = 11, A = 169, C = 4                                   │
│  挑战：e = 2                                                    │
│  响应：z₁ = 13, z₂ = 1, z₃ = 19                                 │
├─────────────────────────────────────────────────────────────────┤
│  验证结果：                                                     │
│    ① Paillier 等式：196 = 196 ✓                                 │
│    ② Ring-Pedersen 等式：29 = 29 ✓                              │
│    ③ 范围检查：z₁ = 13 ∈ 范围 ✓                                 │
├─────────────────────────────────────────────────────────────────┤
│  结论：证明者确实知道 k ∈ 合法范围，使得 K = enc(k)              │
└─────────────────────────────────────────────────────────────────┘
```

---

## 十一、复杂度分析

### 11.1 各 Σ-协议的成本

| 协议 | 证明者计算 | 验证者计算 | 通信（EC元素） |
|------|-----------|-----------|--------------|
| Π^sch | 1 𝔾 | 2 𝔾 | 2 |
| Π^enc | 5 N + 1 N² | 3 N + 2 N² | 54 |
| Π^log | 1 𝔾 + 5 N + 1 N² | 2 𝔾 + 3 N + 2 N² | 55 |
| Π^aff-g | 1 𝔾 + 10 N + 3 N² | 2 𝔾 + 6 N + 5 N² | 112 |
| Π^aff-p | 11 N + 4 N² | 6 N + 7 N² | 136 |
| Π^mod | 160 N | 80 N | 1280 |
| Π^prm | 80 N | 160 N | 1280 |

其中：𝔾 = EC 群指数，N = ℤ_N 指数，N² = ℤ_N² 指数

### 11.2 参数选择

为达到 80 位统计安全性和 128 位计算安全性：
- Π^mod 和 Π^prm：m = 80 轮
- 范围证明：ℓ = 256, ℓ' = 1280, ε = 512（对于 secp256k1）

---

## 总结

| 协议 | 核心作用 | 使用阶段 |
|------|---------|---------|
| Π^sch | 证明知道离散对数 | 密钥生成、密钥刷新 |
| Π^enc | 证明 Paillier 密文在范围内 | 预签名第1轮 |
| Π^log | 证明群元素和密文一致 | 预签名第2、3轮 |
| Π^aff-g | 证明 MtA 仿射操作正确（群） | 预签名第2轮 |
| Π^aff-p | 证明 MtA 仿射操作正确（Paillier） | 预签名第2轮 |
| Π^mod | 证明 Paillier 模数良构 | 辅助信息阶段 |
| Π^prm | 证明 Ring-Pedersen 参数有效 | 辅助信息阶段 |
| Π^fac | 证明模数无小因子 | 辅助信息阶段 |

这些 Σ-协议共同保证了门限 ECDSA 协议的安全性，防止恶意参与方：
1. 使用超出范围的值（范围证明）
2. 使用不一致的值（一致性证明）
3. 使用恶意构造的密码学参数（参数良构证明）

