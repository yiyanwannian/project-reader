# Uniswap v3 核心机制完全解析

## 1. 论文核心内容概述

### 1.1 主要创新点
- **集中流动性**：允许流动性提供者在自定义价格区间内提供流动性
- **灵活费用等级**：支持多种交易费率（0.05%、0.30%、1%）
- **改进的价格预言机**：几何平均TWAP，更高效准确
- **流动性预言机**：支持精确的流动性挖矿奖励分配
- **非匀质化流动性**：取消原生ERC-20流动性代币

### 1.2 技术突破
- Tick系统实现价格离散化
- 三级状态管理（全局、Tick、头寸）
- 位图优化实现高效Tick查找
- 累加器模式精确跟踪费用

## 2. 集中流动性核心公式

### 2.1 虚拟储备公式
```
(x + L/√p_b)(y + L√p_a) = L²
```

**图解说明：**
```
传统 v2: 流动性均匀分布在 (0, ∞)
v3: 流动性集中在 [p_a, p_b] 区间

虚拟储备概念：
┌─────────────────────────────────────────┐
│         实际储备 (x_real, y_real)        │
│ 但行为像拥有更多储备 (x_virtual, y_virtual) │
└─────────────────────────────────────────┘

数学关系：
x_virtual = x_real + L/√p_b
y_virtual = y_real + L√p_a

在区间内保持恒定乘积：x_virtual · y_virtual = L²
```

### 2.2 流动性深度 L
```
L = √(x · y)
```

**流动性 L 的物理意义：**
```
┌─────────┬───────────────────────────────┐
│ 低流动性 │       价格容易大幅波动         │
├─────────┼───────────────────────────────┤
│ 高流动性 │       价格稳定，滑点小         │
└─────────┴───────────────────────────────┘

L 与储备的关系：
当 L 固定时，x 和 y 通过价格关联：
x = L/√P, y = L·√P
```

## 3. 价格与 Tick 系统

### 3.1 Tick 价格公式
```
P(i) = 1.0001^i
```

**Tick 系统图解：**
```
价格轴 (对数尺度)
┌─────┬─────┬─────┬─────┬─────┬─────┐
│ i-2 │ i-1 │  i  │ i+1 │ i+2 │ i+3 │
├─────┼─────┼─────┼─────┼─────┼─────┤
│P(i-2)│P(i-1)│ P(i) │P(i+1)│P(i+2)│P(i+3)│
└─────┴─────┴─────┴─────┴─────┴─────┘
  ↓     ↓     ↓     ↓     ↓     ↓
每个tick价格相差 0.01%
```

### 3.2 平方根价格空间
```
√P(i) = 1.0001^{i/2}
```

**为什么使用 √P 而不是 P？**
```
计算优势：
┌─────────────────┬──────────────────────┐
│     使用 P      │      使用 √P         │
├─────────────────┼──────────────────────┤
│ 交换计算复杂    │ 交换计算简单         │
│ 涉及除法运算    │ 线性关系：Δy = Δ√P × L│
│ 精度损失风险    │ 精度保持更好         │
└─────────────────┴──────────────────────┘
```

## 4. 交换机制公式

### 4.1 价格影响计算
```
Δ√P = ΔY / L
```

**交换过程图解：**
```
输入 ΔY 个 token1       输出 ΔX 个 token0
      ↓                           ↑
┌─────────────────────────────────────┐
│          流动性池状态                │
│  L: 当前流动性深度                  │
│  √P: 当前价格平方根                │
└─────────────────────────────────────┘

计算步骤：
1. Δ√P = ΔY / L        // 价格上升量
2. √P' = √P + Δ√P      // 新价格
3. ΔX = L × (1/√P - 1/√P') // 应输出token0
```

### 4.2 代币变化关系
```
ΔY = Δ√P × L    // token1 变化
ΔX = Δ(1/√P) × L // token0 变化
```

**几何解释：**
```
token1 (Y) 变化：
┌───────────┬─────────────────┐
│  投入 ΔY  │ 导致价格上升 Δ√P │
│  token1   │  = ΔY / L       │
└───────────┴─────────────────┘

token0 (X) 变化：
┌───────────┬───────────────────┐
│  输出 ΔX  │ 因为价格变化 Δ(1/√P)│
│  token0   │  = ΔX / L         │
└───────────┴───────────────────┘
```

## 5. 流动性提供公式

### 5.1 代币存入计算
```
情况1: 价格低于范围 (i_c < i_l)
ΔX = ΔL × (1/√P(i_l) - 1/√P(i_u)), ΔY = 0

情况2: 价格在范围内 (i_l ≤ i_c < i_u)  
ΔX = ΔL × (1/√P - 1/√P(i_u))
ΔY = ΔL × (√P - √P(i_l))

情况3: 价格高于范围 (i_c ≥ i_u)
ΔX = 0, ΔY = ΔL × (√P(i_u) - √P(i_l))
```

**三种情况的解释：**
```
情况1：价格低于范围
┌─────────────────────┐
│ 只存 token0 (X)     │
│ 当价格进入区间时    │
│ 自动卖出 X 买入 Y   │
└─────────────────────┘

情况2：价格在范围内
┌─────────────────────┐
│ 存两种代币          │
│ 立即开始做市        │
└─────────────────────┘

情况3：价格高于范围
┌─────────────────────┐
│ 只存 token1 (Y)     │
│ 当价格进入区间时    │
│ 自动卖出 Y 买入 X   │
└─────────────────────┘
```

### 5.2 流动性提供的几何意义
```
流动性提供 = 在价格曲线上"填充"特定区间

价格曲线：
┌────────────────────────────────────────┐
│                  ▲                     │
│                 / │                    │
│ 流动性空白     /  │  LP1 的流动性       │
│             /    │                    │
│ ──────────•─────•─────────•────────── │
│          i_l   √P       i_u          │
│         (下界) (当前)    (上界)        │
└────────────────────────────────────────┘

LP 的作用：在 [i_l, i_u] 区间内让曲线更"平坦"
```

## 6. 费用计算系统

### 6.1 外侧费用概念
```
f_a(i) = { f_g - f_o(i) if i_c ≥ i
         { f_o(i)       if i_c < i

f_b(i) = { f_o(i)       if i_c ≥ i  
         { f_g - f_o(i) if i_c < i
```

**"外侧"的动态定义图解：**
```
情况 A：当前价格在 tick i 上方 (i_c ≥ i)
┌───────────┬───────────────┐
│  外侧     │     内侧      │
│  (下方)   │    (上方)     │
│  f_b(i)   │    f_a(i)     │
└───────────┴───────────────┘
          i
          ↑
      当前价格在这里

情况 B：当前价格在 tick i 下方 (i_c < i)  
┌───────────┬───────────────┐
│  内侧     │     外侧      │
│  (下方)   │    (上方)     │
│  f_b(i)   │    f_a(i)     │
└───────────┴───────────────┘
          i
          ↑
      当前价格在这里
```

### 6.2 区间费用计算
```
f_r = f_g - f_b(i_l) - f_a(i_u)
```

**费用分配图解：**
```
全局费用池 f_g
┌─────────────────────────────────────┐
│            总费用：f_g              │
├─────────────────────────────────────┤
│ - f_b(i_l) : i_l 以下的费用         │
│ - f_a(i_u) : i_u 以上的费用         │
│ = f_r      : [i_l, i_u] 区间的费用  │
└─────────────────────────────────────┘

可视化：
价格轴：────[i_l]────[当前价格]────[i_u]────
费用：     f_b(i_l)     f_r      f_a(i_u)
```

### 6.3 跨越 Tick 的费用更新
```
f_o(i) := f_g - f_o(i)
```

**跨越过程图解：**
```
跨越前状态：
┌─────────────────┐
│ 当前价格在 i 下方 │
│ f_o(i) 记录上方费用│
└─────────────────┘
        i
        ↑ 准备向上跨越

跨越操作：f_o(i) = f_g - f_o(i)

跨越后状态：  
┌─────────────────┐
│ 当前价格在 i 上方 │
│ f_o(i) 记录下方费用│
└─────────────────┘
        i
        ↑ 已经跨越

效果：内外侧费用记录"翻转"
```

## 7. 预言机系统

### 7.1 几何平均价格预言机
```
a_t = ∑ log₁.₀₀₀₁(P_i)
P_{t₁,t₂} = 1.0001^{(a_{t₂} - a_{t₁})/(t₂ - t₁)}
```

**累加器工作原理：**
```
时间轴：t₁        t₂
        │         │
        ▼         ▼
┌───────┬─────────┬─────────┐
│ 价格P₁│ 价格P₂  │ 价格P₃  │ ...
└───────┴─────────┴─────────┘

累加器更新：
a_{t₁} = logP₁ + logP₂ + ... + logP_{t₁}
a_{t₂} = logP₁ + logP₂ + ... + logP_{t₂}

平均价格 = 1.0001^{(a_{t₂} - a_{t₁})/(t₂ - t₁)}
```

### 7.2 流动性预言机
```
奖励 = R × L × (s_pl(t₁) - s_pl(t₀))
```

**流动性时间累积图解：**
```
时间轴：t₀                 t₁
        │                  │
        ▼                  ▼
┌───────────┬──────────────────────────┐
│  已奖励   │        待奖励时间段       │
│  的时间   │    Δs = s_pl(t₁)-s_pl(t₀) │
└───────────┴──────────────────────────┘

物理意义：
s_pl(t) 表示到时间 t 为止，每单位流动性累积的"秒数"
差值 Δs 就是头寸在 [t₀, t₁] 期间的活跃时间
```

## 8. 位图系统

### 8.1 Tick 到位图的映射
```
wordPos = tick >> 8
bitPos = tick % 256
```

**位图组织结构：**
```
Tick 空间：[-887272, 887272]
分成 65536 个字，每个字 256 位

示例：tick = 120000
wordPos = 120000 / 256 = 468
bitPos = 120000 % 256 = 208

在位图中的位置：
word 468 的第 208 位
```

### 8.2 位图查找算法
**向右查找示例：**
```
当前状态：
word 468 的位：... 0000 1010 1000 ... (从右到左)
                     ↑    ↑    ↑
                 位210 位208 位206

当前 tick：120000 (位208)
查找方向：向右 (更大的tick)

查找步骤：
1. 创建掩码：清除位208左边的所有位
2. 应用掩码：得到 ... 0000 1010 0000 ...
3. 找最低有效位：位210
4. 计算：next = (2000 + 1 + (210-209)) × 60 = 120120
```

## 9. 完整数学公式汇总

### 9.1 核心定义公式
```
L = √(x · y)
√P = √(y/x)
x = L/√P
y = L · √P
P(i) = 1.0001^i
√P(i) = 1.0001^{i/2}
```

### 9.2 交换相关公式
```
Δ√P = ΔY/L
ΔY = Δ√P × L
Δ(1/√P) = ΔX/L
ΔX = Δ(1/√P) × L
Δf_g,₁ = y_in × γ × (1 - φ)
Δf_p,₁ = y_in × γ × φ
净投入 Δy = y_in × (1 - γ)
```

### 9.3 流动性提供公式
```
ΔY = { 0                                  if i_c < i_l
     { ΔL · [√P - √P(i_l)]              if i_l ≤ i_c < i_u
     { ΔL · [√P(i_u) - √P(i_l)]         if i_c ≥ i_u

ΔX = { ΔL · [1/√P(i_l) - 1/√P(i_u)]     if i_c < i_l
     { ΔL · [1/√P - 1/√P(i_u)]          if i_l ≤ i_c < i_u  
     { 0                                  if i_c ≥ i_u
```

### 9.4 费用分配公式
```
f_a(i) = { f_g - f_o(i) if i_c ≥ i
         { f_o(i)       if i_c < i

f_b(i) = { f_o(i)       if i_c ≥ i  
         { f_g - f_o(i) if i_c < i

f_r = f_g - f_b(i_l) - f_a(i_u)
f_u = l × [f_r(t₁) - f_r(t₀)]
f_o(i) := f_g - f_o(i)
```

### 9.5 预言机公式
```
a_t = ∑_{i=1}^t log₁.₀₀₀₁(P_i)
P_{t₁,t₂} = 1.0001^{(a_{t₂} - a_{t₁})/(t₂ - t₁)}
s_pl(t) = ∑ Δt/L
奖励 = R × L × (s_pl(t₁) - s_pl(t₀))
```

### 9.6 Tick计算公式
```
i_c = ⌊log_{√1.0001} √P⌋
wordPos = tick >> 8
bitPos = tick % 256
```

## 10. 系统设计总结

Uniswap v3 通过精妙的数学设计和工程实现，解决了DeFi领域的核心问题
