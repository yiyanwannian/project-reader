# Uniswap v3 核心

2021年3月

Hayden Adams
hayden@uniswap.org

Noah Zinsmeister
noah@uniswap.org

Moody Salem
moody@uniswap.org

River Keefer
river@uniswap.org

Dan Robinson
dan@paradigm.xyz

---

## 摘要
Uniswap v3 是一种为以太坊虚拟机实现的非托管自动化做市商。与早期版本的协议相比，Uniswap v3 为流动性提供者提供了更高的资本效率和精细的控制，改进了价格预言机的准确性和便利性，并具有更灵活的费用结构。

## 1 引言
自动化做市商（AMMs）是汇集流动性并根据算法将其提供给交易者的代理[5]。恒定函数做市商（CFMMs）是一类广泛的 AMM，Uniswap 是其中一员，在去中心化金融的背景下得到了广泛使用，它们通常被实现为在无许可区块链上交易代币的智能合约[2]。

目前实施的 CFMM 通常资本效率低下。在 Uniswap v1 和 v2 使用的恒定乘积做市商公式中，池中只有一小部分资产在给定价格下可用。这是低效的，特别是当资产预期始终在特定价格附近交易时。

先前解决此资本效率问题的尝试，例如 Curve [3] 和 YieldSpace [4]，涉及构建使用不同函数来描述储备金关系的资金池。这要求给定池中的所有流动性提供者遵守单一公式，并且如果流动性提供者希望在不同的价格范围内提供流动性，可能会导致流动性碎片化。

在本文中，我们介绍了 Uniswap v3，这是一种新颖的 AMM，它赋予流动性提供者对其资本使用的价格范围的更多控制，同时对流动性碎片化和 Gas 效率低下的影响有限。该设计不依赖于对代币价格行为的任何共享假设。Uniswap v3 基于与早期版本[1]相同的恒定乘积储备曲线，但提供了几个重要的新特性：

- **集中流动性**：流动性提供者（LPs）能够通过将其流动性"限定"在任意价格范围内来集中其流动性。这提高了资金池的资本效率，并允许 LPs 近似他们偏好的储备曲线，同时仍然可以与池的其余部分有效聚合。我们在第 2 节描述了此功能，并在第 6 节描述了其实现。
- **灵活费用**：交易费用不再锁定在 0.30%。相反，每个资金池（每个资产对可以有多个）的费用等级在初始化时设置（第 3.1 节）。初始支持的费用等级为 0.05%、0.30% 和 1%。UNI 治理能够向此集合添加其他值。
- **协议费用治理**：UNI 治理在设置协议收取的交易费用比例方面具有更大的灵活性（第 6.2.2 节）。
- **改进的价格预言机**：Uniswap v3 提供了一种让用户查询近期价格累加器值的方法，从而避免了在测量 TWAP 的时间段开始和结束时精确检查点累加器值的需要。（第 5.1 节）。

*   *_流动性预言机_：合约暴露了一个时间加权平均流动性预言机（第 5.3 节）。

Uniswap v2 核心合约在设计上是不可升级的，因此 Uniswap v3 是作为一套全新的合约实现的，可在此处获取。Uniswap v3 核心合约也是不可升级的，其中一些参数由治理控制，如第 4 节所述。

## 2. 集中流动性

Uniswap v3 的核心定义思想是_集中流动性_：限定在某个价格范围内的流动性。

在早期版本中，流动性沿着

$x\cdot y=k$ (1)

储备曲线均匀分布，其中 $x$ 和 $y$ 是两种资产 X 和 Y 的各自储备，$k$ 是一个常数 []。换句话说，早期版本旨在提供覆盖整个价格范围 $(0,\infty)$ 的流动性。这实现起来很简单，并且允许流动性被有效地聚合，但意味着池中持有的大部分资产永远不会被动用。

考虑到这一点，允许 LPs 将其流动性集中在比 $(0,\infty)$ 更小的价格范围内似乎是合理的。我们将集中在一个有限范围内的流动性称为一个_头寸_。一个头寸只需要维持足够的储备来支持其范围内的交易，因此可以像在该范围内具有更大储备（我们称之为_虚拟储备_）的恒定乘积池一样运作。

具体来说，一个头寸只需要持有足够的资产 X 来覆盖价格移动到其上边界的情况，因为向上的价格移动1对应于 X 储备的耗尽。类似地，它只需要持有足够的资产 Y 来覆盖价格移动到其下边界的情况。图 1 描绘了对于范围 $\{p_{a},p_{b}\}$ 和当前价格 $p_{c}\in[p_{a},p_{b}]\cdot x_{\text{real}}$ 和 $y_{\text{real}}$ 表示头寸的实际储备的关系。

脚注 1：我们将资产 Y 视为记账单位，这对应于我们实现中的 token1。

当价格超出头寸的范围时，该头寸的流动性不再活跃，并且不再赚取费用。此时，其流动性完全由单一资产组成，因为另一种资产的储备必定已完全耗尽。如果价格重新进入该范围，流动性将再次变为活跃。

提供的流动性量可以通过值 $L$ 来衡量，它等于 $\sqrt{k}$。头寸的实际储备由以下曲线描述：

$(x+\frac{L}{\sqrt{p_{b}}})(y+L\sqrt{p_{a}})=L^{2}$ (2)

该曲线是公式 2.1 的一个平移，使得头寸恰好在其范围内具有偿付能力（图 2）。

流动性提供者可以自由创建任意数量的头寸，每个头寸都有自己的价格范围。通过这种方式，LPs 可以近似在价格空间上的任何期望的流动性分布（参见图 3 了解一些示例）。此外，这作为一种机制，让市场决定流动性应该分配到哪里。理性的 LPs 可以通过将流动性集中在当前价格附近的狭窄区间内，并在价格移动时添加或移除代币以保持其流动性活跃，来降低其资本成本。

### 范围订单

在非常小范围内的头寸行为类似于限价单——如果范围被跨越，头寸从完全由一种资产组成，转变为完全由另一种资产组成（加上应计费用）。这种_范围订单_与传统的限价单有两个区别：

*   头寸的范围可以有多窄是有限制的。当价格在该范围内时，限价单可能会部分执行。
*   当头寸被跨越后，需要将其提取。如果没有提取，并且价格再次跨越该范围，头寸将被交易回来， effectively reversing the trade。

图 1. 虚拟流动性模拟

图 2. 实际储备

## 3. 架构变更

Uniswap v3 进行了一系列架构变更，其中一些是由于引入了集中流动性而必需的，另一些是独立的改进。

### 每对代币多个资金池

在 Uniswap v1 和 v2 中，每对代币对应一个单一的流动性池，对所有交易统一应用 $0.30\%$ 的费用。虽然这个默认费用等级历史上对许多代币来说足够有效，但对某些池（例如两个稳定币之间的池）来说可能太高，而对其他池（例如包含高度波动或很少交易的代币的池）来说可能太低。

Uniswap v3 为每对代币引入了多个资金池，每个池具有不同的交易费用。所有池都由同一个工厂合约创建。工厂合约最初允许以三个费用等级创建池：$0.05\%$、$0.30\%$ 和 $1\%$。额外的费用等级可以由 UNI 治理启用。

### 非匀质化流动性

#### 3.2.1. 非复利费用

在早期版本中赚取的费用会持续作为流动性存入池中。这意味着池中的流动性会随着时间的推移而增长，即使没有明确的存款，并且费用收益会复利。

在 Uniswap v3 中，由于头寸的非匀质化性质，这不再可能。相反，费用收益被单独存储，并作为支付费用的代币持有（见第 6.2.2 节）。

#### 3.2.2. 移除原生流动性代币

在 Uniswap v1 和 v2 中，池合约也是一个 ERC-20 代币合约，其代币代表池中持有的流动性。虽然这很方便，但它实际上与 Uniswap v2 的理念不太相符，即任何不需要在核心合约中的东西都应该在周边，并且指定一个"规范"的 ERC-20 实现阻碍了改进的 ERC-20 代币包装器的创建。可以说，ERC-20 代币实现本应在周边，作为核心合约中单个流动性头寸的包装器。

Uniswap v3 中所做的更改通过使完全可替代的流动性代币变得不可能而迫使解决这个问题。由于自定义流动性提供功能，费用现在作为单个代币由池收集和持有，而不是自动作为流动性重新投入池中。

因此，在 v3 中，池合约不实现 ERC-20 标准。任何人都可以在周边创建一个 ERC-20 代币合约，使流动性头寸更具可替代性，但它必须具有额外的逻辑来处理已收集费用的分配或再投资。或者，任何人都可以创建一个周边合约，将单个流动性头寸（包括已收集的费用）包装在 ERC-721 非匀质化代币中。

## 4. 治理

工厂有一个所有者，最初由 UNI 代币持有者控制。2 所有者没有能力停止任何核心合约的操作。

脚注 2：具体来说，所有者将被初始化为 UNI 治理中的 Timelock 合约，地址为 0x1a9c8182c09f50e8318d769245bea52c32be35bc。

与 Uniswap v2 一样，Uniswap v3 有一个可以由 UNI 治理开启的协议费用。在 Uniswap v3 中，UNI 治理在选择流向协议的交换费用比例方面具有更大的灵活性，并且能够选择任何分数 $\frac{1}{N}$，其中 $4\leq N\leq 10$，或 $0$。此参数可以按每个池进行设置。

UNI 治理还有能力添加额外的费用等级。当它添加新的费用等级时，它还可以定义与该费用等级对应的 tickSpacing（参见第 6.1 节）。一旦费用等级被添加到工厂，就无法移除（并且 tickSpacing 无法更改）。初始支持的费用等级和 tick 间距为 $0.05\%$（tick 间距为 $10$，初始化的 tick 之间大约 $0.10\%$），$0.30\%$（tick 间距为 $60$，初始化的 tick 之间大约 $0.60\%$），和 $1\%$（tick 间距为 $200$，tick 之间大约 $2.02\%$。

最后，UNI 治理有权将所有权转移到另一个地址。

## 5. 预言机升级

Uniswap v3 对 Uniswap v2 引入的时间加权平均价格（TWAP）预言机进行了三项重大更改。

最重要的是，Uniswap v3 消除了预言机用户需要在外部跟踪累加器先前值的需要。Uniswap v2 要求用户在要计算 TWAP 的时间段的开始和结束时刻检查点累加器值。

想要计算 TWAP。Uniswap v3 将累加器检查点纳入核心，允许外部合约在链上计算最近时间段的 TWAP，而无需存储累加器值的检查点。

另一个变化是，Uniswap v3 不再累积价格的总和（允许用户计算算术平均 TWAP），而是跟踪_对数_价格的总和，允许用户计算_几何平均_ TWAP。

最后，Uniswap v3 添加了一个与价格累加器一起跟踪的流动性累加器，它每秒累积 $\frac{1}{t}$。这个流动性累加器对于希望在 Uniswap v3 之上实施流动性挖矿的外部合约非常有用。其他合约也可以使用它来帮助决定对于某个代币对（见第 3.1 节）的哪个池将具有最可靠的 TWAP。

### 预言机观测值

与 Uniswap v2 一样，Uniswap v3 跟踪一个运行累加器，该累加器是每个区块开始时的价格，乘以自上一个区块以来的秒数。

Uniswap v2 中的池只存储此价格累加器的最新值——即，最后一次发生交换的区块中的值。在 Uniswap v2 中计算平均价格时，外部调用者有责任提供价格累加器的先前值。对于许多用户，每个人都必须提供自己的检查点累加器先前值的方法，或者协调共享方法以降低成本。并且无法保证池被触及的每个区块都会反映在累加器中。

在 Uniswap v3 中，池存储价格累加器（以及第 5.3 节描述的流动性累加器）的先前值列表。它通过在每次池在区块中第一次被触及时自动检查点累加器值来实现这一点，循环遍历一个数组，其中最旧的检查点最终被新的检查点覆盖，类似于循环缓冲区。虽然这个数组最初只有一个检查点的空间，但任何人都可以初始化额外的存储槽来延长数组，最多可扩展到 65,536 个检查点。3 这将对希望此交易对检查点更多槽位的人施加初始化此数组额外存储槽的一次性 Gas 成本。

脚注 3：最多 65,536 个检查点允许在检查点被写入后至少 9 天内获取它们，假设每个区块之间经过 13 秒，并且每个区块都写入一个检查点。

池向用户暴露过去观测值的数组，以及一个便利函数，用于在检查点时间段内的任何历史时间戳查找（插值的）累加器值。

### 几何平均价格预言机

Uniswap v2 维护两个价格累加器——一个是 token0 相对于 token1 的价格，另一个是 token1 相对于 token0 的价格。用户可以通过将时间段结束时的累加器值减去时间段开始时的累加器值，然后将差值除以时间段内的秒数，来计算任何时间段内价格的时间加权算术平均值。请注意，token0 和 token1 的累加器是分开跟踪的，因为 token0 的时间加权算术平均价格并不等于 token1 的时间加权算术平均价格的倒数。

使用时间加权_几何_平均价格，正如 Uniswap v3 所做的那样，避免了为这些比率跟踪单独累加器的需要。一组比率的几何平均值是它们倒数几何平均值的倒数。在 Uniswap v3 中，由于其自定义流动性提供的实现（如第 6 节所述），它也易于实现。此外，累加器可以用更少的位数存储，因为它跟踪的是 log $P$ 而不是 $P$，并且 log $P$ 可以以一致的精度表示广泛的价格范围。4 最后，有一个理论论据认为时间加权几何平均价格应该更真实地代表平均价格。5

脚注 4：为了在所有可能的价格范围内支持可容忍的精度，Uniswap v2 将每个价格表示为 224 位定点数。Uniswap v3 只需要将 $log_{1.0001}P$ 表示为有符号 24 位数，并且仍然可以检测到一个 tick 的价格变动，或 1 个基点。

Uniswap v3 不是跟踪价格 $P$ 的累积和，而是累积当前 tick 索引（$log_{1.0001}P$，以 1.0001 为底的价格对数，精确到 1 个基点）的累积和。在任何给定时间的累加器等于合约历史中每一秒的 $log_{1.0001}\left(P\right)$ 的总和：

$a_{t}=\sum_{i=1}^{t}\log_{1.0001}\left(P_{i}\right)$ (5.1)

我们想要估计任何时间段 $t_{1}$ 到 $t_{2}$ 上的几何平均时间加权平均价格 $\left(p_{t_{1},t_{2}}\right)$。

$P_{t_{1},t_{2}}=\left(\prod_{l=t_{1}}^{t_{2}}P_{l}\right)^{\frac{1}{t_{2}-t_{1 }}}$ (5.2)

要计算这个，你可以查看 $t_{1}$ 和 $t_{2}$ 时刻的累加器值，用第二个值减去第一个值，除以经过的秒数，然后计算 $1.0001^{x}$ 来计算时间加权几何平均价格。

$\log_{1.0001}\left(P_{t_{1},t_{2}}\right)=\frac{\sum_{l=t_{1}}^{t_{2}}\log_{1. 0001}\left(P_{l}\right)}{t_{2}-t_{1}}$ (5.3)

$\log_{1.0001}\left(P_{t_{1},t_{2}}\right)=\frac{a_{t_{2}}-a_{t_{1}}}{t_{2}-t_{1}}$ (5.4)

$P_{t_{1},t_{2}}=1.0001^{\frac{a_{t_{2}}-a_{t_{1}}}{t_{2}-t_{1}}}$ (5.5)

### 流动性预言机

除了 $\log_{1.0001}price$ 的秒加权累加器之外，Uniswap v3 还在每个区块开始时跟踪 $\frac{1}{t}$（当前在范围内的虚拟流动性的倒数）的秒加权累加器：secondsPerLiquidityCumulative ($s_{gt}$)。

这可以被外部流动性挖矿合约用来公平地分配奖励。如果一个外部合约想要以每秒 $R$ 个代币的均匀速率向合约中所有活跃的流动性分配奖励，

合约，并且一个具有 $L$ 流动性的头寸在 $t_{0}$ 到 $t_{1}$ 期间是活跃的，那么它在该时间段内的奖励将是 $R$-$L\cdot(s_{pl}(t_{1})-s_{pl}(t_{0}))$。

为了扩展这一点，使得集中流动性仅在其处于范围内时才获得奖励，Uniswap v3 在每次跨越 tick 时存储基于此值的计算检查点，如第 6.3 节所述。

这个累加器也可以被链上合约用来使它们的预言机更强大（例如通过评估使用哪个费用等级池的预言机）。

## 6. 实现集中流动性

本文的其余部分描述了集中流动性提供的工作原理，并对其在合约中的实现进行了高层描述。

### Ticks 和范围

为了实现自定义流动性提供，可能的价格空间由离散的_ticks_划分。流动性提供者可以在任意两个 ticks（不需要相邻）之间的范围内提供流动性。

每个范围可以指定为一对有符号整数_tick 索引_：一个下 tick ($i_{l}$) 和一个上 tick ($i_{u}$)。Ticks 代表合约虚拟流动性可能发生变化的价格。我们假设价格总是表示为一种代币（称为 token0）相对于另一种代币（token1）的价格。将两种代币分配给 token0 和 token1 是任意的，并且不影响合约的逻辑（除了可能的舍入误差）。

从概念上讲，在每一个价格 $p$ 是 1.0001 的整数次幂的地方都有一个 tick。通过整数索引 $i$ 来识别 ticks，每个 tick 的价格由下式给出：

$p(i)=1.0001^{i}$ (6.1)

这具有每个 tick 与其相邻 ticks 的价格移动 .01%（1 个基点）的理想特性。

然而，由于第 6.2.1 节解释的技术原因，池实际上在每个_平方根价格_是 $\sqrt{1.0001}$ 的整数次幂的地方跟踪 ticks。考虑上面的方程，转换到平方根价格空间：

$\sqrt{p}(i)=\sqrt{1.0001}^{i}=1.0001^{\frac{i}{2}}$ (6.2)

例如，$\sqrt{p}(0)$——tick 0 处的平方根价格——是 1，$\sqrt{p}(1)$ 是 $\sqrt{1.0001}\approx 1.00005$，而 $\sqrt{p}(-1)$ 是 $\frac{-1}{\sqrt{1.0001}}\approx 0.99995$。

当向一个范围添加流动性时，如果一个或两个 ticks 尚未被现有头寸用作边界，则该 tick 被_初始化_。

并非每个 tick 都可以被初始化。池在实例化时带有一个参数 tickSpacing ($t_{s}$)，只有索引能被 tickSpacing 整除的 ticks 才能被初始化。例如，如果 tickSpacing 是 2，那么只有偶数 ticks ($...4,\cdot 2,\,0,\,2,\,4...$) 可以被初始化。小的 tickSpacing 选择允许更紧密和更精确的范围，但可能导致交换更耗 Gas（因为交换跨越的每个初始化的 tick 都会给交换者带来 Gas 成本）。

每当价格跨越一个初始化的 tick 时，虚拟流动性被加入或移除。跨越一个初始化 tick 的 Gas 成本是恒定的，并且不依赖于在该 tick 被加入或移除的头寸数量。

确保在 ticks 被跨越时正确数量的流动性被加入和移出池，并确保每个头寸赚取其在范围内期间应得的费用比例，需要在池内进行一些记账。池合约使用存储变量在_全局_（每个池）级别、_每个 tick_ 级别和_每个头寸_级别跟踪状态。

### 全局状态

合约的全局状态包括七个与交换和流动性提供相关的存储变量。（它还有其他用于预言机的存储变量，如第 5 节所述。）

#### 6.2.1. 价格和流动性

在 Uniswap v2 中，每个池合约跟踪池的当前储备 $x$ 和 $y$。在 Uniswap v3 中，合约可以被认为拥有_虚拟储备_——$x$ 和 $y$ 的值，使您能够将合约的行为（在两个相邻的 ticks 之间）描述为好像遵循恒定乘积公式。

然而，池合约不是跟踪那些虚拟储备，而是跟踪两个不同的值：流动性 ($L$) 和 sqrtPrice ($\sqrt{P}$)。这些可以通过以下公式从虚拟储备计算：

$L=\sqrt{xy}$ (6.3)

$\sqrt{P}=\sqrt{\frac{y}{x}}$ (6.4)

反过来，这些值可以用来计算虚拟储备：

$x=\frac{L}{\sqrt{P}}$ (6.5)

$y=L\cdot\sqrt{P}$ (6.6)

使用 $L$ 和 $\sqrt{P}$ 很方便，因为每次只有一个发生变化。价格（以及因此的 $\sqrt{P}$）在 tick 内交换时发生变化；流动性在跨越 tick 时，或者在铸造或销毁流动性时发生变化。这避免了一些如果跟踪虚拟储备可能遇到的舍入误差。

您可能会注意到，流动性公式（基于虚拟储备）类似于 Uniswap v2 中用于初始化流动性代币数量（基于实际储备）的公式。

| 类型       | 变量名                   | 符号        |
|------------|--------------------------|-------------|
| uint128    | liquidity                | $L$         |
| uint160    | sqrtPriceX96             | $\sqrt{P}$  |
| int24      | tick                     | $i_{c}$     |
| uint256    | feedrowthGlobal0X128     | $f_{g,0}$   |
| uint256    | feedrowthGlobal1X128     | $f_{g,1}$   |
| uint128    | protocolFees.token0      | $f_{p,0}$   |
| uint128    | protocolFees.token1      | $f_{p,1}$   |

表 1. 全局状态


在任何费用被赚取之前。在某些方面，流动性可以被视为虚拟流动性代币。

或者，流动性可以被认为是对于给定的 $\sqrt{p}$ 变化，token1 储备（实际或虚拟）的变化量：

脚注 1：从技术上讲，名为 "protocolFee" 的存储变量是这个分数的分母（或者如果 $\phi$ 为零，则为零）。

$L=\frac{\Delta Y}{\Delta\sqrt{p}}$ (6.7)

我们跟踪 $\sqrt{p}$ 而不是 $P$ 是为了利用这种关系，并避免在计算交换时进行任何平方根运算，如第 6.2.3 节所述。

全局状态还将当前 tick 索引跟踪为 tick ($i_{c}$)，一个有符号整数，表示当前 tick（更具体地说，是当前价格下方最近的 tick）。这是一个优化（以及一种避免对数精度问题的方法），因为在任何时候，您都应该能够根据当前的 sqrtPrice 计算当前 tick。具体来说，在任何给定时间，以下等式应该成立：

$i_{c}=\left\lfloor\log_{\sqrt{1,0001}}\sqrt{p}\right\rfloor$ (6.8)

#### 6.2.2. 费用

每个池在初始化时都有一个不可变的值 fee ($y$)，表示交换者支付的费用，单位为百分之一的基点 (0.0001%)。

它还跟踪当前的协议费 $\phi$（初始化为零，但可以由 UNI 治理更改）。2 这个数字告诉您当前流向协议而不是流动性提供者的交换者支付费用的比例。$\phi$ 只有一组有限的允许值：0, 1/4, 1/5, 1/6, 1/7, 1/8, 1/9, 或 1/10。

脚注 2：每轮的总成本为每年 1 亿美元。

全局状态还跟踪两个数字：feedrowthGlobal$(\bm{f}_{g,0})$ 和 feedrowthGlobal$(\bm{f}_{g,1})$。这些表示在合约的整个历史中，每单位虚拟流动性 ($L$) 赚取的总费用量。您可以将它们视为如果从合约首次初始化时就存入 1 单位无界流动性，将会赚取的总费用量。它们存储为定点无符号 128x128 数字。请注意，在 Uniswap v3 中，费用是以代币本身收集的，而不是以流动性形式收集的，原因在第 3.2.1 节中解释。

最后，全局状态跟踪每个代币中累计未收集的协议费总额，protocolFees$\emptyset$$(\bm{f}_{p,0})$ 和 protocolFees1$(\bm{f}_{p,1})$。这是一个无符号 uint128。累积的协议费可以由 UNI 治理通过调用 collectProtocol 函数来收集。

#### 6.2.3. 在单个 Tick 内交换

对于足够小的、不会将价格移动超过一个 tick 的交换，合约的行为类似于一个 $(x\cdot y=k)$ 池。

假设 $(y)$是费用，即 0.003，而 $(y_{in})$ 是发送进来的 token1 的数量。

首先，feedrowthGlobal1 和 protocolFees1 增加：

$\Delta\bm{f}_{g,1}=y_{in}\cdot y\cdot(1-\phi)$ (6.9)

$\Delta\bm{f}_{p,1}=y_{in}\cdot y\cdot\phi$ (6.10)

$\Delta y$ 是 $y$ 的增加量（扣除费用后）。

$\Delta y=y_{in}\cdot(1-y)$ (6.11)

如果您使用计算出的虚拟储备 ($x$ 和 $y$) 作为 token$\emptyset$ 和 token1 的余额，那么可以使用以下公式找出发送出去的 token$\emptyset$ 的数量：

$x_{end}=\frac{x\cdot y}{y+\Delta y}$ (6.12)

但请记住，在 v3 中，合约实际上跟踪的是流动性 ($L$) 和价格的平方根 ($\sqrt{p}$)，而不是 $x$ 和 $y$。我们可以从这些值计算 $x$ 和 $y$，然后用它们来计算交易的执行价格。但事实证明，存在简单的公式来描述给定 $L$ 下 $\Delta\sqrt{p}$ 和 $\Delta y$ 之间的关系（可以从公式 6.7 推导出）：

$\Delta\sqrt{p}=\frac{\Delta y}{L}$ (6.13)

$\Delta y=\Delta\sqrt{p}\cdot L$ (6.14)

还有一些简单的公式描述了 $\Delta\frac{1}{\sqrt{p}}$ 和 $\Delta x$ 之间的关系：

$\Delta\frac{1}{\sqrt{p}}=\frac{\Delta x}{L}$ (6.15)

$\Delta x=\Delta\frac{1}{\sqrt{p}}\cdot L$ (6.16)

当用一种代币交换另一种代币时，池合约可以首先使用公式 6.13 或 6.15 计算新的 $\sqrt{p}$，然后可以使用公式 6.14 或 6.16 计算要发送出去的 token$\emptyset$ 或 token1 的数量。

这些公式适用于任何不会将 $\sqrt{p}$ 推过下一个初始化 tick 价格的交换。如果计算出的 $\Delta\sqrt{p}$ 会导致 $\sqrt{p}$ 移动超过下一个初始化 tick，合约必须只跨越到那个 tick——只使用部分交换——然后跨越该 tick，如第 6.3.1 节所述，然后继续剩余的交换。

#### 6.2.4. 初始化的 Tick 位图

如果一个 tick 没有被任何具有流动性的范围用作端点——也就是说，如果该 tick 未初始化——那么该 tick 可以在交换期间跳过。

作为一种优化，为了使查找下一个初始化的 tick 更高效，池跟踪一个已初始化 ticks 的位图 tickBitmap。位图中对应于 tick 索引的位置如果 tick 已初始化则设置为 1，如果未初始化则设置为 0。

当一个 tick 被用作新头寸的端点，并且该 tick 当前没有被任何其他流动性使用时，该 tick 被初始化，并且位图中的相应位被设置为 1。如果一个已初始化的 tick 的所有以其为端点的流动性都被移除，则该 tick 可以再次变为未初始化，在这种情况下，该 tick 在位图中的位置被清零。

### Tick 索引状态

合约需要存储每个 tick 的信息，以便跟踪当 tick 被跨越时应添加或移除的净流动性量，以及跟踪在该 tick 上方和下方赚取的费用。

合约存储一个从 tick 索引 (int24) 到以下七个值的映射：


| 类型       | 变量名                          | 符号      |
|------------|----------------------------------|-----------|
| int128     | liquidityNet                     | $\Delta L$ |
| uint128    | liquidityCross                   | $L_{g}$   |
| uint256    | feedrowthOutside0X128            | $f_{o,0}$ |
| uint256    | feedrowthOutside1X128            | $f_{o,1}$ |
| uint256    | secondsOutside                   | $s_{o}$   |
| uint256    | tickCumulativeOutside            | $i_{o}$   |
| uint256    | secondsPerLiquidityOutsideX128   | $s_{lo}$  |

每个 tick 跟踪 $\Delta L$，即当 tick 被跨越时应加入或移除的流动性总量。该 tick 只需要跟踪一个有符号整数：当 tick 从左到右被跨越时添加的流动性量（或者，如果为负，则为移除的量）。此值不需要在 tick 被跨越时更新（仅在以其为边界的头寸更新时更新）。

我们希望能够在没有流动性引用该 tick 时取消初始化它。由于 $\Delta L$ 是一个净值，有必要跟踪引用该 tick 的流动性总量，liquidityCross。该值确保即使 tick 处的净流动性为 0，我们仍然可以知道该 tick 是否被至少一个基础头寸引用，这告诉我们是否要更新 tick 位图。

feedrowthOutside{0,1} 用于跟踪在给定范围内累积了多少费用。由于在 token0 和 token1 中收集的费用的公式是相同的，我们将在本节的其余部分省略该下标。

您可以使用一个公式计算在 tick $i$ 上方 ($f_{a}$) 和下方 ($f_{b}$) 每单位流动性在 token 0 中赚取的费用，该公式取决于价格当前是在该范围内还是范围外——也就是说，当前 tick 索引 $i_{c}$ 是否大于或等于 $i$：

$f_{a}(i)=\begin{cases}f_{g}-f_{o}(i)&i_{c}\geq i\\ f_{o}(i)&i_{c}<i\end{cases}$ (6.17)

$f_{b}(i)=\begin{cases}f_{o}(i)&i_{c}\geq i\\ f_{g}-f_{o}(i)&i_{c}<i\end{cases}$ (6.18)

我们可以使用这些函数来计算两个 ticks 之间——一个下 tick $i_{l}$ 和一个上 tick $i_{u}$——范围内每份额的总累计费用 $f_{r}$：

$f_{r}=f_{g}-f_{b}(i_{l})-f_{a}(i_{u})$ (6.19)

$f_{o}$ 需要在每次 tick 被跨越时更新。具体来说，当 tick $i$ 在任一方向上被跨越时，其 $f_{o}$（对于每个代币）应按如下方式更新：

$f_{o}(i):=f_{g}-f_{o}(i)$ (6.20)

$f_{o}$ 仅用于那些被至少一个头寸用作下界或上界的 ticks。因此，为了提高效率，$f_{o}$ 在创建以该 tick 为边界的头寸之前不会被初始化（因此在跨越时不需要更新）。当为 tick $i$ 初始化 $f_{o}$ 时，该值——按照惯例——被选择为好像迄今为止所有赚取的费用都发生在该 tick 下方：

$f_{o}:=\begin{cases}f_{g}&i_{c}\geq i\\ 0&i_{c}<i\end{cases}$ (6.21)

请注意，由于不同 ticks 的 $f_{o}$ 值可能在不同时间初始化，不同 ticks 的 $f_{o}$ 值的比较没有意义，并且不能保证 $f_{o}$ 值的一致性。这不会导致每个头寸的记账问题，因为如下所述，头寸需要知道的只是给定范围内自上次触及该头寸以来 $g$ 的增长。

图 4. 交换控制流

$begin{table} end{table}$

表 2. Tick 索引状态

最后，合约还为每个 tick 存储 secondsOutside ($s_{o}$)、secondsPerliquidityOutside 和 tickCumulativeOutside。这些值不在合约内部使用，但为了需要更细粒度了解池行为的外部合约（用于流动性挖矿等目的）而跟踪。

所有这三个索引的工作方式都与上面描述的费用增长索引类似。但是，feedrowthOutside(0,1) 索引跟踪的是 feedrowthGlobal(0,1)，而 secondsOutside 索引跟踪的是秒数（即当前时间戳），secondsPerliquidityOutside 跟踪的是第 5.3 节描述的 $1/L$ 累加器 (secondsPerliquidityCumulative)，tickCumulativeOutside 跟踪的是第 5.2 节描述的 log${}_{1,0001}\,P$ 累加器。

例如，在给定 tick 上方 ($s_{a}$) 和下方 ($s_{b}$) 花费的秒数根据当前价格是否在该范围内而不同地计算，并且在范围内 ($s_{r}$) 花费的秒数可以使用 $s_{a}$ 和 $s_{b}$ 的值计算：

$t_{a}(i)=\begin{cases}t-t_{o}(i)&i_{c}\geq i\\ t_{o}(i)&i_{c}<i\end{cases}$ (6.22)

$t_{b}(i)=\begin{cases}t_{o}(i)&i_{c}\geq i\\ t-t_{o}(i)&i_{c}<i\end{cases}$ (6.23)

$t_{r}(i_{l},i_{u})=t-t_{b}(i_{l})-t_{a}(i_{u})$ (6.24)

在两个时间 $t_{1}$ 和 $t_{2}$ 之间在某个范围内花费的秒数可以通过记录 $t_{1}$ 和 $t_{2}$ 时刻的 $s_{r}(i_{l},i_{u})$ 值，并用后者减去前者来计算。

与 $f_{o}$ 一样，$s_{o}$ 不需要为不在任何头寸边缘的 ticks 跟踪。因此，在创建以该 tick 为边界的头寸之前，它不会被初始化。按照惯例，它被初始化为好像自 Unix 时间戳 0 以来的每一秒都花费在该 tick 下方：

$t_{o}(i)\coloneqq\begin{cases}t&i_{c}\geq i\\ 0&i_{c}<i\end{cases}$ (6.25)

与 $f_{o}$ 值一样，$t_{o}$ 值在不同 ticks 之间没有可比性。$t_{o}$ 仅在计算某个特定范围内、在某个定义的开始时间（必须在两个 ticks 的 $t_{o}$ 都初始化之后）和某个结束时间之间流动性存在的秒数时才有意义。

#### 6.3.1. 跨越一个 Tick

如第 6.2.3 节所述，Unswap v3 在初始化的 ticks 之间交换时表现得好像遵循恒定乘积公式。然而，当交换跨越一个初始化的 tick 时，合约需要添加或移除流动性，以确保没有流动性提供者资不抵债。这意味着从 tick 获取 $\Delta L$，并将其应用于全局 $L$。

合约还需要更新 tick 自身的状态，以便跟踪在此 tick 界定的范围内赚取的费用（和花费的秒数）。feedrowthOutside(0,1) 和 secondsOutside 值被更新以反映当前值，以及相对于当前 tick 的正确方向：

$f_{o}\coloneqq f_{g}-f_{o}$ (6.26)

$t_{o}\coloneqq t-t_{o}$ (6.27)

一旦 tick 被跨越，交换可以按照第 6.2.3 节的描述继续，直到到达下一个初始化的 tick。

### 头寸索引状态
合约有一个从用户（地址）、下界（tick 索引，int24）和上界（tick 索引，int24）到特定 Position 结构的映射。每个 Position 跟踪三个值：

| 类型       | 变量名                      | 符号            |
|------------|-----------------------------|-----------------|
| uint128    | liquidity                   | $l$             |
| uint256    | feedrowthInside0LastX128    | $f_{r,0}(t_{0})$ |
| uint256    | feedrowthInside1LastX128    | $f_{r,1}(t_{0})$ |

**表 3：头寸索引状态**

流动性 () 表示该头寸上次被触及时所代表的虚拟流动性量。具体来说，流动性可以被认为是 $\sqrt{x\cdot y}$，其中 $x$ 和 $y$ 分别是该流动性在任何时候在范围内为池贡献的虚拟 token$\emptyset$ 和虚拟 token$1$ 的数量。与 Unswap v2 中的池份额（每个份额的价值随时间增长）不同，流动性的单位不随费用累积而变化；它总是测量为 $\sqrt{x\cdot y}$，其中 $x$ 和 $y$ 分别是 token$\emptyset$ 和 token$1$ 的数量。

这个流动性数字不反映自合约上次被触及以来累积的费用，我们称之为_未收集费用_。计算这些未收集的费用需要在头寸上存储额外的值，feedrowthInside@Last ($f_{r,0}(t_{0})$) 和 feedrowthInsideLast ($f_{r,1}(t_{0})$)，如下所述。

#### 6.4.1. setPosition

setPosition 函数允许流动性提供者更新他们的头寸。

setPosition 的两个参数 - lowerTick 和 upperTick - 与 msg.sender 结合，共同指定一个头寸。

该函数接受一个附加参数 liquidityDelta，以指定用户想要添加或（如果为负）移除多少虚拟流动性。

首先，该函数计算头寸有权获得的每个代币的未收集费用 ($f_{u}$)。7 收取的费用金额计入用户贷方，并与其为虚拟流动性存款将要存入或取出的金额相抵。

脚注 7：由于计算每个代币未收集费用的公式相同，我们将在本节的其余部分省略该下标。

要计算一个代币的未收集费用，您需要知道自上次为该头寸收集费用以来，该头寸范围的 $f_{r}$（根据范围的 $i_{l}$ 和 $i_{r}$ 计算，如第 6.3 节所述）增长了多少。在时间 $t_{0}$ 和 $t_{1}$ 之间，给定范围内每单位流动性的费用增长就是 $f_{r}(t_{1})-f_{r}(t_{0})$（其中 $f_{r}(t_{0})$ 存储在头寸中作为 feedrowthInside(0,1)Last，而 $f_{r}(t_{1})$ 可以从 ticks 的当前状态计算）。将其乘以头寸的流动性，我们得到该头寸在 token 0 中的总未收集费用：

$f_{u}=I\cdot(f_{r}(t_{1})-f_{r}(t_{0}))$ (6.28)

然后，合约通过添加 liquidityDelta 来更新头寸的流动性。它还将 liquidityDelta 添加到范围底部 tick 的 liquidityNet 值，并从上部 tick 的 liquidityNet 中减去它（以反映当价格向上跨越下部 tick 时将添加此新流动性，当价格向上跨越上部 tick 时将减去它）。如果池的当前价格在此头寸的范围内，合约还将 liquidityDelta 添加到合约的全局流动性值。

最后，池根据铸造或销毁的流动性量，将代币从用户转移（或者，如果 liquidityDelta 为负，则转移给用户）。

需要存入的 token0 ($\Delta X$) 或 token1 ($\Delta Y$) 的数量可以被认为是如果价格从当前价格 ($P$) 移动到上 tick 或下 tick（分别对应 token0 或 token1），从头寸中卖出的数量。这些公式可以从公式 6.14 和 6.16 推导出来，并取决于当前价格是低于、在范围内还是高于头寸的范围：

$\Delta Y=\begin{cases}0&i_{c}<i_{l}\\ \Delta L\cdot(\sqrt{P}-\sqrt{P(i_{l})})&i_{l}\leq i_{c}<i_{u}\\ \Delta L\cdot(\sqrt{P(i_{u})}-\sqrt{P(i_{l})})&i_{c}\geq i_{u}\end{cases}$ (6.29)

$\Delta X=\begin{cases}\Delta L\cdot(\frac{1}{\sqrt{P(i_{l})}}-\frac{1}{\sqrt{P( i_{u})}})&i_{c}<i_{l}\\ \Delta L\cdot(\frac{1}{\sqrt{P}}-\frac{1}{\sqrt{P(i_{u})}})&i_{l}\leq i_{c}<i_{u }\\ 0&i_{c}\geq i_{u}\end{cases}$ (6.30)

## 参考文献

*   [1] Hayden Adams, Noah Zimmelster, and Dan Robinson. 2020. _Uniswap v2 Core_. Retrieved Feb 24, 2021 from https://uniswap.org/whitepaper.pdf
*   [2] Guillermo Angeris and Tarun Chiria. 2020. Improved Price Oracles: Constant Function Market Makers. In _Proceedings of the 2nd ACM Conference on Advances in Financial Technologies__(AFT '20)_. Association for Computing Machinery, New York, NY, United States, pp. 40-91. https://doi.org/10.1145/3419614.3424253
*   [3] Michael Rogrov. 2019. _StableSwap - Efficient Mechanics for Stablecoin Liquidity_. Retrieved Feb 24, 2021 from https://www.curve.fi/stableswap-paper.pdf
*   [4] Allan Niemerg, Dan Robinson, and Lev Livnev. 2020. _YieldSpace: An Automated Liquidity Provider for Fixed Yield Tokens_. Retrieved Feb 24, 2021 from https://yield.is?tickSpace.pdf
*   [5] Abraham Ohlman. 2012. _Automated Market Making: Theory and Practice_. Ph.D. Dissertation. Carnegie Mellon University.

## 免责声明

本文仅供一般信息用途。它不构成投资建议或推荐，也不是购买或出售任何投资的邀约，不应用于评估做出任何投资决策的优点。它不应被依赖用于会计、法律或税务建议或投资推荐。本文反映了作者当前的观点，不代表 Uniswap Labs、Paradigm 或其关联公司，也不一定反映 Uniswap Labs、Paradigm、其关联公司或与之相关的个人的观点。本文反映的观点可能会发生变化，恕不另行更新。